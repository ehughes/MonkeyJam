   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"arm_cm4.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.stop,"ax",%progbits
  19              		.align	2
  20              		.global	stop
  21              		.thumb
  22              		.thumb_func
  24              	stop:
  25              	.LFB0:
  26              		.file 1 "../Sources/cpu/arm_cm4.c"
   1:../Sources/cpu/arm_cm4.c **** /*
   2:../Sources/cpu/arm_cm4.c ****  * File:		arm_cm4.c
   3:../Sources/cpu/arm_cm4.c ****  * Purpose:		Generic high-level routines for ARM Cortex M4 processors
   4:../Sources/cpu/arm_cm4.c ****  *
   5:../Sources/cpu/arm_cm4.c ****  * Notes:
   6:../Sources/cpu/arm_cm4.c ****  */
   7:../Sources/cpu/arm_cm4.c **** 
   8:../Sources/cpu/arm_cm4.c **** /***********************************************************************/
   9:../Sources/cpu/arm_cm4.c **** 
  10:../Sources/cpu/arm_cm4.c **** /*
  11:../Sources/cpu/arm_cm4.c ****  * Configures the ARM system control register for STOP (deep sleep) mode
  12:../Sources/cpu/arm_cm4.c ****  * and then executes the WFI instruction to enter the mode.
  13:../Sources/cpu/arm_cm4.c ****  *
  14:../Sources/cpu/arm_cm4.c ****  * Parameters:
  15:../Sources/cpu/arm_cm4.c ****  * none
  16:../Sources/cpu/arm_cm4.c ****  *
  17:../Sources/cpu/arm_cm4.c ****  * Note: Might want to change this later to allow for passing in a parameter
  18:../Sources/cpu/arm_cm4.c ****  *       to optionally set the sleep on exit bit.
  19:../Sources/cpu/arm_cm4.c ****  */
  20:../Sources/cpu/arm_cm4.c **** 
  21:../Sources/cpu/arm_cm4.c **** #include "derivative.h" /* include peripheral declarations */
  22:../Sources/cpu/arm_cm4.c **** #include "arm_cm4.h"
  23:../Sources/cpu/arm_cm4.c **** 
  24:../Sources/cpu/arm_cm4.c **** /* */
  25:../Sources/cpu/arm_cm4.c **** 
  26:../Sources/cpu/arm_cm4.c **** void stop(void)
  27:../Sources/cpu/arm_cm4.c **** {
  27              		.loc 1 27 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  28:../Sources/cpu/arm_cm4.c ****     /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
  29:../Sources/cpu/arm_cm4.c **** 
  30:../Sources/cpu/arm_cm4.c ****     SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
  32              		.loc 1 30 0
  33 0000 4FF0E023 		mov	r3, #-536813568
  34 0004 D3F8102D 		ldr	r2, [r3, #3344]
  35 0008 42F00400 		orr	r0, r2, #4
  36 000c C3F8100D 		str	r0, [r3, #3344]
  31:../Sources/cpu/arm_cm4.c **** 
  32:../Sources/cpu/arm_cm4.c ****     /* WFI instruction will start entry into STOP mode */
  33:../Sources/cpu/arm_cm4.c **** 
  34:../Sources/cpu/arm_cm4.c ****     #ifndef KEIL
  35:../Sources/cpu/arm_cm4.c ****     asm("WFI");
  37              		.loc 1 35 0
  38              	@ 35 "../Sources/cpu/arm_cm4.c" 1
  39 0010 30BF     		WFI
  40              	@ 0 "" 2
  41              		.thumb
  42 0012 7047     		bx	lr
  43              		.cfi_endproc
  44              	.LFE0:
  46              		.section	.text.wait,"ax",%progbits
  47              		.align	2
  48              		.global	wait
  49              		.thumb
  50              		.thumb_func
  52              	wait:
  53              	.LFB1:
  36:../Sources/cpu/arm_cm4.c ****     #else
  37:../Sources/cpu/arm_cm4.c ****     __wfi();
  38:../Sources/cpu/arm_cm4.c ****     #endif
  39:../Sources/cpu/arm_cm4.c **** }
  40:../Sources/cpu/arm_cm4.c **** 
  41:../Sources/cpu/arm_cm4.c **** /***********************************************************************/
  42:../Sources/cpu/arm_cm4.c **** 
  43:../Sources/cpu/arm_cm4.c **** /*
  44:../Sources/cpu/arm_cm4.c ****  * Configures the ARM system control register for WAIT (sleep) mode
  45:../Sources/cpu/arm_cm4.c ****  * and then executes the WFI instruction to enter the mode.
  46:../Sources/cpu/arm_cm4.c ****  *
  47:../Sources/cpu/arm_cm4.c ****  * Parameters:
  48:../Sources/cpu/arm_cm4.c ****  * none
  49:../Sources/cpu/arm_cm4.c ****  *
  50:../Sources/cpu/arm_cm4.c ****  * Note: Might want to change this later to allow for passing in a parameter
  51:../Sources/cpu/arm_cm4.c ****  *       to optionally set the sleep on exit bit.
  52:../Sources/cpu/arm_cm4.c ****  */
  53:../Sources/cpu/arm_cm4.c **** 
  54:../Sources/cpu/arm_cm4.c **** void wait(void)
  55:../Sources/cpu/arm_cm4.c **** {
  54              		.loc 1 55 0
  55              		.cfi_startproc
  56              		@ args = 0, pretend = 0, frame = 0
  57              		@ frame_needed = 0, uses_anonymous_args = 0
  58              		@ link register save eliminated.
  56:../Sources/cpu/arm_cm4.c ****     /* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) mode instead
  57:../Sources/cpu/arm_cm4.c ****      * of deep sleep.
  58:../Sources/cpu/arm_cm4.c ****      */
  59:../Sources/cpu/arm_cm4.c **** 
  60:../Sources/cpu/arm_cm4.c ****     SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
  59              		.loc 1 60 0
  60 0000 4FF0E023 		mov	r3, #-536813568
  61 0004 D3F8102D 		ldr	r2, [r3, #3344]
  62 0008 22F00400 		bic	r0, r2, #4
  63 000c C3F8100D 		str	r0, [r3, #3344]
  61:../Sources/cpu/arm_cm4.c **** 
  62:../Sources/cpu/arm_cm4.c ****     /* WFI instruction will start entry into WAIT mode */
  63:../Sources/cpu/arm_cm4.c **** 
  64:../Sources/cpu/arm_cm4.c ****     #ifndef KEIL
  65:../Sources/cpu/arm_cm4.c ****     asm("WFI");
  64              		.loc 1 65 0
  65              	@ 65 "../Sources/cpu/arm_cm4.c" 1
  66 0010 30BF     		WFI
  67              	@ 0 "" 2
  68              		.thumb
  69 0012 7047     		bx	lr
  70              		.cfi_endproc
  71              	.LFE1:
  73              		.section	.text.write_vtor,"ax",%progbits
  74              		.align	2
  75              		.global	write_vtor
  76              		.thumb
  77              		.thumb_func
  79              	write_vtor:
  80              	.LFB2:
  66:../Sources/cpu/arm_cm4.c ****     #else
  67:../Sources/cpu/arm_cm4.c ****     __wfi();
  68:../Sources/cpu/arm_cm4.c ****     #endif
  69:../Sources/cpu/arm_cm4.c **** }
  70:../Sources/cpu/arm_cm4.c **** 
  71:../Sources/cpu/arm_cm4.c **** /***********************************************************************/
  72:../Sources/cpu/arm_cm4.c **** 
  73:../Sources/cpu/arm_cm4.c **** /*
  74:../Sources/cpu/arm_cm4.c ****  * Change the value of the vector table offset register to the specified value.
  75:../Sources/cpu/arm_cm4.c ****  *
  76:../Sources/cpu/arm_cm4.c ****  * Parameters:
  77:../Sources/cpu/arm_cm4.c ****  * vtor     new value to write to the VTOR
  78:../Sources/cpu/arm_cm4.c ****  */
  79:../Sources/cpu/arm_cm4.c **** 
  80:../Sources/cpu/arm_cm4.c **** void write_vtor
  81:../Sources/cpu/arm_cm4.c **** (int vtor)
  82:../Sources/cpu/arm_cm4.c **** {
  81              		.loc 1 82 0
  82              		.cfi_startproc
  83              		@ args = 0, pretend = 0, frame = 0
  84              		@ frame_needed = 0, uses_anonymous_args = 0
  85              		@ link register save eliminated.
  86              	.LVL0:
  83:../Sources/cpu/arm_cm4.c ****     /* Write the VTOR with the new value */
  84:../Sources/cpu/arm_cm4.c **** 
  85:../Sources/cpu/arm_cm4.c ****     SCB_VTOR = vtor;
  87              		.loc 1 85 0
  88 0000 4FF0E023 		mov	r3, #-536813568
  89 0004 C3F8080D 		str	r0, [r3, #3336]
  90 0008 7047     		bx	lr
  91              		.cfi_endproc
  92              	.LFE2:
  94 000a 00BF     		.section	.text.enable_irq,"ax",%progbits
  95              		.align	2
  96              		.global	enable_irq
  97              		.thumb
  98              		.thumb_func
 100              	enable_irq:
 101              	.LFB3:
  86:../Sources/cpu/arm_cm4.c **** }
  87:../Sources/cpu/arm_cm4.c **** 
  88:../Sources/cpu/arm_cm4.c **** /***********************************************************************/
  89:../Sources/cpu/arm_cm4.c **** 
  90:../Sources/cpu/arm_cm4.c **** /*
  91:../Sources/cpu/arm_cm4.c ****  * Initialize the NVIC to enable the specified IRQ.
  92:../Sources/cpu/arm_cm4.c ****  *
  93:../Sources/cpu/arm_cm4.c ****  * NOTE: The function only initializes the NVIC to enable a single IRQ.
  94:../Sources/cpu/arm_cm4.c ****  * Interrupts will also need to be enabled in the ARM core. This can be
  95:../Sources/cpu/arm_cm4.c ****  * done using the EnableInterrupts macro.
  96:../Sources/cpu/arm_cm4.c ****  *
  97:../Sources/cpu/arm_cm4.c ****  * Parameters:
  98:../Sources/cpu/arm_cm4.c ****  * irq    irq number to be enabled (the irq number NOT the vector number)
  99:../Sources/cpu/arm_cm4.c ****  */
 100:../Sources/cpu/arm_cm4.c **** 
 101:../Sources/cpu/arm_cm4.c **** void enable_irq
 102:../Sources/cpu/arm_cm4.c **** (int irq)
 103:../Sources/cpu/arm_cm4.c **** {
 102              		.loc 1 103 0
 103              		.cfi_startproc
 104              		@ args = 0, pretend = 0, frame = 0
 105              		@ frame_needed = 0, uses_anonymous_args = 0
 106              		@ link register save eliminated.
 107              	.LVL1:
 104:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 105:../Sources/cpu/arm_cm4.c **** 
 106:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 107:../Sources/cpu/arm_cm4.c **** 
 108:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 109:../Sources/cpu/arm_cm4.c **** 
 110:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 111:../Sources/cpu/arm_cm4.c **** 
 112:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 113:../Sources/cpu/arm_cm4.c **** 
 114:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 115:../Sources/cpu/arm_cm4.c **** 
 116:../Sources/cpu/arm_cm4.c ****     int div;
 117:../Sources/cpu/arm_cm4.c **** 
 118:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 119:../Sources/cpu/arm_cm4.c **** 
 120:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 121:../Sources/cpu/arm_cm4.c **** 
 122:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 123:../Sources/cpu/arm_cm4.c **** 
 124:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 125:../Sources/cpu/arm_cm4.c **** 
 126:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 127:../Sources/cpu/arm_cm4.c **** 
 128:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 129:../Sources/cpu/arm_cm4.c **** 
 130:../Sources/cpu/arm_cm4.c ****     /* Make sure that the IRQ is an allowable number. Right now up to 61 is
 131:../Sources/cpu/arm_cm4.c ****      * used.
 132:../Sources/cpu/arm_cm4.c ****      */
 133:../Sources/cpu/arm_cm4.c **** 
 134:../Sources/cpu/arm_cm4.c ****     /// if (irq > 61)
 135:../Sources/cpu/arm_cm4.c ****     //printf("\nERR! Invalid IRQ value passed to enable irq function!\n");
 136:../Sources/cpu/arm_cm4.c **** 
 137:../Sources/cpu/arm_cm4.c ****     /* Determine which of the NVICISERs corresponds to the irq */
 138:../Sources/cpu/arm_cm4.c **** 
 139:../Sources/cpu/arm_cm4.c ****     div = irq / 32;
 108              		.loc 1 139 0
 109 0000 0028     		cmp	r0, #0
 110 0002 0346     		mov	r3, r0
 111 0004 B8BF     		it	lt
 112 0006 00F11F03 		addlt	r3, r0, #31
 113 000a 5911     		asrs	r1, r3, #5
 140:../Sources/cpu/arm_cm4.c **** 
 141:../Sources/cpu/arm_cm4.c ****     switch(div)
 114              		.loc 1 141 0
 115 000c 0129     		cmp	r1, #1
 116 000e 28D0     		beq	.L7
 117 0010 0229     		cmp	r1, #2
 118 0012 11D0     		beq	.L8
 119 0014 21BB     		cbnz	r1, .L4
 142:../Sources/cpu/arm_cm4.c ****     {
 143:../Sources/cpu/arm_cm4.c ****         case 0x0:   NVICICPR0 = 1 << (irq % 32); NVICISER0 = 1 << (irq % 32); break;
 120              		.loc 1 143 0
 121 0016 1F23     		movs	r3, #31
 122 0018 C8F20003 		movt	r3, 32768
 123 001c 0340     		ands	r3, r3, r0
 124 001e 002B     		cmp	r3, #0
 125 0020 35DB     		blt	.L14
 126              	.LVL2:
 127              	.L10:
 128 0022 4FF46140 		mov	r0, #57600
 129 0026 CEF20000 		movt	r0, 57344
 130 002a 0121     		movs	r1, #1
 131 002c 01FA03F2 		lsl	r2, r1, r3
 132 0030 C0F88021 		str	r2, [r0, #384]
 133 0034 0260     		str	r2, [r0, #0]
 134 0036 7047     		bx	lr
 135              	.LVL3:
 136              	.L8:
 144:../Sources/cpu/arm_cm4.c ****         case 0x1:   NVICICPR1 = 1 << (irq % 32); NVICISER1 = 1 << (irq % 32); break;
 145:../Sources/cpu/arm_cm4.c ****         case 0x2:   NVICICPR2 = 1 << (irq % 32); NVICISER2 = 1 << (irq % 32); break;
 137              		.loc 1 145 0
 138 0038 1F23     		movs	r3, #31
 139 003a C8F20003 		movt	r3, 32768
 140 003e 0340     		ands	r3, r3, r0
 141 0040 002B     		cmp	r3, #0
 142 0042 03DA     		bge	.L12
 143 0044 013B     		subs	r3, r3, #1
 144 0046 63F01F00 		orn	r0, r3, #31
 145              	.LVL4:
 146 004a 431C     		adds	r3, r0, #1
 147              	.L12:
 148 004c 4FF46142 		mov	r2, #57600
 149 0050 CEF20002 		movt	r2, 57344
 150 0054 0121     		movs	r1, #1
 151 0056 01FA03F0 		lsl	r0, r1, r3
 152 005a C2F88801 		str	r0, [r2, #392]
 153 005e 9060     		str	r0, [r2, #8]
 154              	.L4:
 155 0060 7047     		bx	lr
 156              	.LVL5:
 157              	.L7:
 144:../Sources/cpu/arm_cm4.c ****         case 0x1:   NVICICPR1 = 1 << (irq % 32); NVICISER1 = 1 << (irq % 32); break;
 158              		.loc 1 144 0
 159 0062 1F23     		movs	r3, #31
 160 0064 C8F20003 		movt	r3, 32768
 161 0068 0340     		ands	r3, r3, r0
 162 006a 002B     		cmp	r3, #0
 163 006c 0ADB     		blt	.L15
 164              	.L11:
 165 006e 4FF46140 		mov	r0, #57600
 166              	.LVL6:
 167 0072 CEF20000 		movt	r0, 57344
 168 0076 0121     		movs	r1, #1
 169 0078 01FA03F2 		lsl	r2, r1, r3
 170 007c C0F88421 		str	r2, [r0, #388]
 171 0080 4260     		str	r2, [r0, #4]
 172 0082 7047     		bx	lr
 173              	.LVL7:
 174              	.L15:
 175 0084 013B     		subs	r3, r3, #1
 176 0086 63F01F02 		orn	r2, r3, #31
 177 008a 531C     		adds	r3, r2, #1
 178 008c EFE7     		b	.L11
 179              	.L14:
 143:../Sources/cpu/arm_cm4.c ****         case 0x0:   NVICICPR0 = 1 << (irq % 32); NVICISER0 = 1 << (irq % 32); break;
 180              		.loc 1 143 0
 181 008e 581E     		subs	r0, r3, #1
 182              	.LVL8:
 183 0090 60F01F02 		orn	r2, r0, #31
 184 0094 531C     		adds	r3, r2, #1
 185 0096 C4E7     		b	.L10
 186              		.cfi_endproc
 187              	.LFE3:
 189              		.section	.text.disable_irq,"ax",%progbits
 190              		.align	2
 191              		.global	disable_irq
 192              		.thumb
 193              		.thumb_func
 195              	disable_irq:
 196              	.LFB4:
 146:../Sources/cpu/arm_cm4.c ****     }
 147:../Sources/cpu/arm_cm4.c **** }
 148:../Sources/cpu/arm_cm4.c **** 
 149:../Sources/cpu/arm_cm4.c **** /***********************************************************************/
 150:../Sources/cpu/arm_cm4.c **** 
 151:../Sources/cpu/arm_cm4.c **** /*
 152:../Sources/cpu/arm_cm4.c ****  * Initialize the NVIC to disable the specified IRQ.
 153:../Sources/cpu/arm_cm4.c ****  *
 154:../Sources/cpu/arm_cm4.c ****  * NOTE: The function only initializes the NVIC to disable a single IRQ.
 155:../Sources/cpu/arm_cm4.c ****  * If you want to disable all interrupts, then use the DisableInterrupts
 156:../Sources/cpu/arm_cm4.c ****  * macro instead.
 157:../Sources/cpu/arm_cm4.c ****  *
 158:../Sources/cpu/arm_cm4.c ****  * Parameters:
 159:../Sources/cpu/arm_cm4.c ****  * irq    irq number to be disabled (the irq number NOT the vector number)
 160:../Sources/cpu/arm_cm4.c ****  */
 161:../Sources/cpu/arm_cm4.c **** 
 162:../Sources/cpu/arm_cm4.c **** void disable_irq
 163:../Sources/cpu/arm_cm4.c **** (int irq)
 164:../Sources/cpu/arm_cm4.c **** {
 197              		.loc 1 164 0
 198              		.cfi_startproc
 199              		@ args = 0, pretend = 0, frame = 0
 200              		@ frame_needed = 0, uses_anonymous_args = 0
 201              		@ link register save eliminated.
 202              	.LVL9:
 165:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 166:../Sources/cpu/arm_cm4.c **** 
 167:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 168:../Sources/cpu/arm_cm4.c **** 
 169:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 170:../Sources/cpu/arm_cm4.c **** 
 171:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 172:../Sources/cpu/arm_cm4.c **** 
 173:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 174:../Sources/cpu/arm_cm4.c **** 
 175:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 176:../Sources/cpu/arm_cm4.c **** 
 177:../Sources/cpu/arm_cm4.c ****     int div;
 178:../Sources/cpu/arm_cm4.c **** 
 179:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 180:../Sources/cpu/arm_cm4.c **** 
 181:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 182:../Sources/cpu/arm_cm4.c **** 
 183:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 184:../Sources/cpu/arm_cm4.c **** 
 185:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 186:../Sources/cpu/arm_cm4.c **** 
 187:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 188:../Sources/cpu/arm_cm4.c **** 
 189:../Sources/cpu/arm_cm4.c ****     /*~~~~*/
 190:../Sources/cpu/arm_cm4.c **** 
 191:../Sources/cpu/arm_cm4.c ****     /* Make sure that the IRQ is an allowable number. Right now up to 91 is
 192:../Sources/cpu/arm_cm4.c ****      * used.
 193:../Sources/cpu/arm_cm4.c ****      */
 194:../Sources/cpu/arm_cm4.c **** 
 195:../Sources/cpu/arm_cm4.c ****     if(irq > 91)
 203              		.loc 1 195 0
 204 0000 5B28     		cmp	r0, #91
 196:../Sources/cpu/arm_cm4.c ****         //    printf("\nERR! Invalid IRQ value passed to disable irq function!\n");
 197:../Sources/cpu/arm_cm4.c **** 
 198:../Sources/cpu/arm_cm4.c ****         /* Determine which of the NVICICERs corresponds to the irq */
 199:../Sources/cpu/arm_cm4.c **** 
 200:../Sources/cpu/arm_cm4.c ****         div = irq / 32;
 205              		.loc 1 200 0
 206 0002 C8BF     		it	gt
 207 0004 4311     		asrgt	r3, r0, #5
 208              	.LVL10:
 201:../Sources/cpu/arm_cm4.c **** 
 202:../Sources/cpu/arm_cm4.c ****     switch(div)
 209              		.loc 1 202 0
 210 0006 022B     		cmp	r3, #2
 211 0008 00D0     		beq	.L21
 212 000a 7047     		bx	lr
 213              	.L21:
 203:../Sources/cpu/arm_cm4.c ****     {
 204:../Sources/cpu/arm_cm4.c ****         case 0x0:   NVICICER0 = 1 << (irq % 32); break;
 205:../Sources/cpu/arm_cm4.c ****         case 0x1:   NVICICER1 = 1 << (irq % 32); break;
 206:../Sources/cpu/arm_cm4.c ****         case 0x2:   NVICICER2 = 1 << (irq % 32); break;
 214              		.loc 1 206 0
 215 000c 1F23     		movs	r3, #31
 216              	.LVL11:
 217 000e C8F20003 		movt	r3, 32768
 218 0012 0340     		ands	r3, r3, r0
 219 0014 002B     		cmp	r3, #0
 220 0016 09DB     		blt	.L22
 221              	.LVL12:
 222              	.L20:
 223 0018 4FF46142 		mov	r2, #57600
 224 001c CEF20002 		movt	r2, 57344
 225 0020 0121     		movs	r1, #1
 226 0022 01FA03F0 		lsl	r0, r1, r3
 227 0026 C2F88800 		str	r0, [r2, #136]
 228 002a 7047     		bx	lr
 229              	.LVL13:
 230              	.L22:
 231 002c 013B     		subs	r3, r3, #1
 232 002e 63F01F00 		orn	r0, r3, #31
 233              	.LVL14:
 234 0032 431C     		adds	r3, r0, #1
 235 0034 F0E7     		b	.L20
 236              		.cfi_endproc
 237              	.LFE4:
 239 0036 00BF     		.section	.text.set_irq_priority,"ax",%progbits
 240              		.align	2
 241              		.global	set_irq_priority
 242              		.thumb
 243              		.thumb_func
 245              	set_irq_priority:
 246              	.LFB5:
 207:../Sources/cpu/arm_cm4.c ****     }
 208:../Sources/cpu/arm_cm4.c **** }
 209:../Sources/cpu/arm_cm4.c **** 
 210:../Sources/cpu/arm_cm4.c **** /***********************************************************************/
 211:../Sources/cpu/arm_cm4.c **** 
 212:../Sources/cpu/arm_cm4.c **** /*
 213:../Sources/cpu/arm_cm4.c ****  * Initialize the NVIC to set specified IRQ priority.
 214:../Sources/cpu/arm_cm4.c ****  *
 215:../Sources/cpu/arm_cm4.c ****  * NOTE: The function only initializes the NVIC to set a single IRQ priority.
 216:../Sources/cpu/arm_cm4.c ****  * Interrupts will also need to be enabled in the ARM core. This can be
 217:../Sources/cpu/arm_cm4.c ****  * done using the EnableInterrupts macro.
 218:../Sources/cpu/arm_cm4.c ****  *
 219:../Sources/cpu/arm_cm4.c ****  * Parameters:
 220:../Sources/cpu/arm_cm4.c ****  * irq    irq number to be enabled (the irq number NOT the vector number)
 221:../Sources/cpu/arm_cm4.c ****  * prio   irq priority. 0-15 levels. 0 max priority
 222:../Sources/cpu/arm_cm4.c ****  */
 223:../Sources/cpu/arm_cm4.c **** 
 224:../Sources/cpu/arm_cm4.c **** void set_irq_priority
 225:../Sources/cpu/arm_cm4.c **** (
 226:../Sources/cpu/arm_cm4.c ****     int irq,
 227:../Sources/cpu/arm_cm4.c ****     int prio
 228:../Sources/cpu/arm_cm4.c **** )
 229:../Sources/cpu/arm_cm4.c **** {
 247              		.loc 1 229 0
 248              		.cfi_startproc
 249              		@ args = 0, pretend = 0, frame = 0
 250              		@ frame_needed = 0, uses_anonymous_args = 0
 251              		@ link register save eliminated.
 252              	.LVL15:
 230:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 231:../Sources/cpu/arm_cm4.c **** 
 232:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 233:../Sources/cpu/arm_cm4.c **** 
 234:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 235:../Sources/cpu/arm_cm4.c **** 
 236:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 237:../Sources/cpu/arm_cm4.c **** 
 238:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 239:../Sources/cpu/arm_cm4.c **** 
 240:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 241:../Sources/cpu/arm_cm4.c **** 
 242:../Sources/cpu/arm_cm4.c ****     /*irq priority pointer*/
 243:../Sources/cpu/arm_cm4.c **** 
 244:../Sources/cpu/arm_cm4.c ****     uint8   *prio_reg;
 245:../Sources/cpu/arm_cm4.c **** 
 246:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 247:../Sources/cpu/arm_cm4.c **** 
 248:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 249:../Sources/cpu/arm_cm4.c **** 
 250:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 251:../Sources/cpu/arm_cm4.c **** 
 252:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 253:../Sources/cpu/arm_cm4.c **** 
 254:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 255:../Sources/cpu/arm_cm4.c **** 
 256:../Sources/cpu/arm_cm4.c ****     /*~~~~~~~~~~~~~~*/
 257:../Sources/cpu/arm_cm4.c **** 
 258:../Sources/cpu/arm_cm4.c ****     /* Make sure that the IRQ is an allowable number. Right now up to 91 is
 259:../Sources/cpu/arm_cm4.c ****      * used.
 260:../Sources/cpu/arm_cm4.c ****      */
 261:../Sources/cpu/arm_cm4.c **** 
 262:../Sources/cpu/arm_cm4.c ****     if(irq > 91)
 253              		.loc 1 262 0
 254 0000 5B28     		cmp	r0, #91
 255 0002 05DD     		ble	.L24
 263:../Sources/cpu/arm_cm4.c ****     {
 264:../Sources/cpu/arm_cm4.c ****         //  printf("\nERR! Invalid IRQ value passed to priority irq function!\n");
 265:../Sources/cpu/arm_cm4.c **** 
 266:../Sources/cpu/arm_cm4.c ****         if(prio > 15)
 256              		.loc 1 266 0
 257 0004 0F29     		cmp	r1, #15
 267:../Sources/cpu/arm_cm4.c ****             // printf("\nERR! Invalid priority value passed to priority irq function!\n");
 268:../Sources/cpu/arm_cm4.c **** 
 269:../Sources/cpu/arm_cm4.c ****             /* Determine which of the NVICIPx corresponds to the irq */
 270:../Sources/cpu/arm_cm4.c **** 
 271:../Sources/cpu/arm_cm4.c ****             prio_reg = (uint8 *) (((uint32) & NVICIP0) + irq);
 258              		.loc 1 271 0
 259 0006 C4BF     		itt	gt
 260 0008 00F16040 		addgt	r0, r0, #-536870912
 261              	.LVL16:
 262 000c 00F56443 		addgt	r3, r0, #58368
 263              	.LVL17:
 264              	.L24:
 272:../Sources/cpu/arm_cm4.c ****     }
 273:../Sources/cpu/arm_cm4.c **** 
 274:../Sources/cpu/arm_cm4.c ****     /* Assign priority to IRQ */
 275:../Sources/cpu/arm_cm4.c **** 
 276:../Sources/cpu/arm_cm4.c ****     *prio_reg = ((prio & 0xF) << (8 - ARM_INTERRUPT_LEVEL_BITS));
 265              		.loc 1 276 0
 266 0010 0901     		lsls	r1, r1, #4
 267              	.LVL18:
 268 0012 1970     		strb	r1, [r3, #0]
 269 0014 7047     		bx	lr
 270              		.cfi_endproc
 271              	.LFE5:
 273 0016 00BF     		.text
 274              	.Letext0:
 275              		.file 2 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 276              		.file 3 "C:/Users/ehughes/Dropbox/FRDM/FRDM-JAM/SRC/MonkeyJam/MonkeyJam/Project_Headers/MK20D5.h"
 277              		.file 4 "../Sources/cpu/arm_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 arm_cm4.c
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:19     .text.stop:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:24     .text.stop:00000000 stop
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:47     .text.wait:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:52     .text.wait:00000000 wait
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:74     .text.write_vtor:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:79     .text.write_vtor:00000000 write_vtor
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:95     .text.enable_irq:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:100    .text.enable_irq:00000000 enable_irq
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:190    .text.disable_irq:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:195    .text.disable_irq:00000000 disable_irq
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:240    .text.set_irq_priority:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\ccMR4iXT.s:245    .text.set_irq_priority:00000000 set_irq_priority
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
