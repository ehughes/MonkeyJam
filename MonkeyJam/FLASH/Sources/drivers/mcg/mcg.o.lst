   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"mcg.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.comm	drs_val,1,1
  19              		.comm	dmx32_val,1,1
  20              		.section	.text.pll_init,"ax",%progbits
  21              		.align	2
  22              		.global	pll_init
  23              		.thumb
  24              		.thumb_func
  26              	pll_init:
  27              	.LFB0:
  28              		.file 1 "../Sources/drivers/mcg/mcg.c"
   1:../Sources/drivers/mcg/mcg.c **** /*
   2:../Sources/drivers/mcg/mcg.c ****  * File:    mcg.c
   3:../Sources/drivers/mcg/mcg.c ****  *
   4:../Sources/drivers/mcg/mcg.c ****  * MCG drivers for Freescale Kinetis L - series devices
   5:../Sources/drivers/mcg/mcg.c ****  * Notes:
   6:../Sources/drivers/mcg/mcg.c ****  * Assumes the MCG mode is in the default FEI mode out of reset
   7:../Sources/drivers/mcg/mcg.c ****  */
   8:../Sources/drivers/mcg/mcg.c **** 
   9:../Sources/drivers/mcg/mcg.c **** #include "derivative.h"
  10:../Sources/drivers/mcg/mcg.c **** #include "mcg.h"
  11:../Sources/drivers/mcg/mcg.c **** 
  12:../Sources/drivers/mcg/mcg.c **** // global variables
  13:../Sources/drivers/mcg/mcg.c **** 
  14:../Sources/drivers/mcg/mcg.c **** extern int      core_clk_khz;
  15:../Sources/drivers/mcg/mcg.c **** 
  16:../Sources/drivers/mcg/mcg.c **** char            drs_val, dmx32_val;
  17:../Sources/drivers/mcg/mcg.c **** 
  18:../Sources/drivers/mcg/mcg.c **** // prototypes
  19:../Sources/drivers/mcg/mcg.c **** 
  20:../Sources/drivers/mcg/mcg.c **** void            rtc_as_refclk(void);
  21:../Sources/drivers/mcg/mcg.c **** int             fee_fei(int slow_irc_freq);
  22:../Sources/drivers/mcg/mcg.c **** int             fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  23:../Sources/drivers/mcg/mcg.c **** int             fbe_fei(int slow_irc_freq);
  24:../Sources/drivers/mcg/mcg.c **** int             fei_fbi(int irc_freq, unsigned char irc_select);
  25:../Sources/drivers/mcg/mcg.c **** int             fbi_fei(int slow_irc_freq);
  26:../Sources/drivers/mcg/mcg.c **** int             fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  27:../Sources/drivers/mcg/mcg.c **** int             pbe_pee(int crystal_val);
  28:../Sources/drivers/mcg/mcg.c **** int             pee_pbe(int crystal_val);
  29:../Sources/drivers/mcg/mcg.c **** int             pbe_fbe(int crystal_val);
  30:../Sources/drivers/mcg/mcg.c **** int             fbe_fbi(int irc_freq, unsigned char irc_select);
  31:../Sources/drivers/mcg/mcg.c **** int             fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  32:../Sources/drivers/mcg/mcg.c **** int             fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  33:../Sources/drivers/mcg/mcg.c **** int             fbe_fee(int crystal_val);
  34:../Sources/drivers/mcg/mcg.c **** int             fee_fbe(int crystal_val);
  35:../Sources/drivers/mcg/mcg.c **** int             pbe_blpe(int crystal_val);
  36:../Sources/drivers/mcg/mcg.c **** int             blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  37:../Sources/drivers/mcg/mcg.c **** int             blpe_fbe(int crystal_val);
  38:../Sources/drivers/mcg/mcg.c **** int             fbi_blpi(int irc_freq, unsigned char irc_select);
  39:../Sources/drivers/mcg/mcg.c **** int             blpi_fbi(int irc_freq, unsigned char irc_select);
  40:../Sources/drivers/mcg/mcg.c **** int             fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  41:../Sources/drivers/mcg/mcg.c **** int             fee_fbi(int irc_freq, unsigned char irc_select);
  42:../Sources/drivers/mcg/mcg.c **** int             fbe_blpe(int crystal_val);
  43:../Sources/drivers/mcg/mcg.c **** 
  44:../Sources/drivers/mcg/mcg.c **** int             new_pll_freq(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  45:../Sources/drivers/mcg/mcg.c **** 
  46:../Sources/drivers/mcg/mcg.c **** int             fll_freq(int fll_ref);
  47:../Sources/drivers/mcg/mcg.c **** unsigned char   what_mcg_mode(void);
  48:../Sources/drivers/mcg/mcg.c **** unsigned char   atc(unsigned char irc_select, int irc_freq, int mcg_out_freq);
  49:../Sources/drivers/mcg/mcg.c **** void            clk_monitor_0(unsigned char en_dis);
  50:../Sources/drivers/mcg/mcg.c **** unsigned char   chk_for_resistor(void);
  51:../Sources/drivers/mcg/mcg.c **** 
  52:../Sources/drivers/mcg/mcg.c **** /*********************************************************************************************/
  53:../Sources/drivers/mcg/mcg.c **** 
  54:../Sources/drivers/mcg/mcg.c **** /* Functon name : pll_init
  55:../Sources/drivers/mcg/mcg.c ****  *
  56:../Sources/drivers/mcg/mcg.c ****  * Mode transition: Option to move from FEI to PEE mode or to just initialize the PLL
  57:../Sources/drivers/mcg/mcg.c ****  *
  58:../Sources/drivers/mcg/mcg.c ****  * This function initializess PLL0. Either OSC0 is selected for the
  59:../Sources/drivers/mcg/mcg.c ****  * reference clock source. The oscillators can be configured to use a crystal or take in an
  60:../Sources/drivers/mcg/mcg.c ****  * external square wave clock.
  61:../Sources/drivers/mcg/mcg.c ****  * Using the function parameter names the PLL frequency is calculated as follows:
  62:../Sources/drivers/mcg/mcg.c ****  * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
  63:../Sources/drivers/mcg/mcg.c ****  * Refer to the readme file in the mcg driver directory for examples of pll_init configurations.
  64:../Sources/drivers/mcg/mcg.c ****  * All parameters must be provided, for example crystal_val must be provided even if the
  65:../Sources/drivers/mcg/mcg.c ****  * oscillator associated with that parameter is already initialized.
  66:../Sources/drivers/mcg/mcg.c ****  * The various passed parameters are checked to ensure they are within the allowed range. If any
  67:../Sources/drivers/mcg/mcg.c ****  * of these checks fail the driver will exit and return a fail/error code. An error code will
  68:../Sources/drivers/mcg/mcg.c ****  * also be returned if any error occurs during the PLL initialization sequence. Refer to the
  69:../Sources/drivers/mcg/mcg.c ****  * readme file in the mcg driver directory for a list of all these codes.
  70:../Sources/drivers/mcg/mcg.c ****  *
  71:../Sources/drivers/mcg/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
  72:../Sources/drivers/mcg/mcg.c ****  *                           wave clock source
  73:../Sources/drivers/mcg/mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
  74:../Sources/drivers/mcg/mcg.c ****  *                           for the crystal oscillator. This has no meaning if an
  75:../Sources/drivers/mcg/mcg.c ****  *                           external clock is used.
  76:../Sources/drivers/mcg/mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
  77:../Sources/drivers/mcg/mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
  78:../Sources/drivers/mcg/mcg.c ****  *                           PLL reference clock frequency
  79:../Sources/drivers/mcg/mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
  80:../Sources/drivers/mcg/mcg.c ****  *             mcgout_select  - 0 if the PLL is just to be enabled, non-zero if the PLL is used
  81:../Sources/drivers/mcg/mcg.c ****  *                              to provide the MCGOUT clock for the system.
  82:../Sources/drivers/mcg/mcg.c ****  *
  83:../Sources/drivers/mcg/mcg.c ****  * Return value : PLL frequency (Hz) or error code
  84:../Sources/drivers/mcg/mcg.c ****  */
  85:../Sources/drivers/mcg/mcg.c **** 
  86:../Sources/drivers/mcg/mcg.c **** int pll_init
  87:../Sources/drivers/mcg/mcg.c **** (
  88:../Sources/drivers/mcg/mcg.c ****     int             crystal_val,
  89:../Sources/drivers/mcg/mcg.c ****     unsigned char   hgo_val,
  90:../Sources/drivers/mcg/mcg.c ****     unsigned char   erefs_val,
  91:../Sources/drivers/mcg/mcg.c ****     signed char     prdiv_val,
  92:../Sources/drivers/mcg/mcg.c ****     signed char     vdiv_val,
  93:../Sources/drivers/mcg/mcg.c ****     unsigned char   mcgout_select
  94:../Sources/drivers/mcg/mcg.c **** )
  95:../Sources/drivers/mcg/mcg.c **** {
  29              		.loc 1 95 0
  30              		.cfi_startproc
  31              		@ args = 8, pretend = 0, frame = 24
  32              		@ frame_needed = 1, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  34 0000 80B4     		push	{r7}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 4
  37              		.cfi_offset 7, -4
  38 0002 87B0     		sub	sp, sp, #28
  39              	.LCFI1:
  40              		.cfi_def_cfa_offset 32
  41 0004 00AF     		add	r7, sp, #0
  42              	.LCFI2:
  43              		.cfi_def_cfa_register 7
  44 0006 7860     		str	r0, [r7, #4]
  45 0008 F970     		strb	r1, [r7, #3]
  46 000a BA70     		strb	r2, [r7, #2]
  47 000c 7B70     		strb	r3, [r7, #1]
  96:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
  97:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
  98:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
  99:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 100:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 101:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 102:../Sources/drivers/mcg/mcg.c ****     unsigned char   frdiv_val;
 103:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
 104:../Sources/drivers/mcg/mcg.c ****     unsigned char   prdiv, vdiv;
 105:../Sources/drivers/mcg/mcg.c ****     short           i;
 106:../Sources/drivers/mcg/mcg.c ****     int             ref_freq;
 107:../Sources/drivers/mcg/mcg.c ****     int             pll_freq;
 108:../Sources/drivers/mcg/mcg.c **** 
 109:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 110:../Sources/drivers/mcg/mcg.c **** 
 111:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 112:../Sources/drivers/mcg/mcg.c **** 
 113:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 114:../Sources/drivers/mcg/mcg.c **** 
 115:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 116:../Sources/drivers/mcg/mcg.c **** 
 117:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 118:../Sources/drivers/mcg/mcg.c **** 
 119:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 120:../Sources/drivers/mcg/mcg.c **** 
 121:../Sources/drivers/mcg/mcg.c ****     // check if in FEI mode
 122:../Sources/drivers/mcg/mcg.c **** 
 123:../Sources/drivers/mcg/mcg.c ****     if
 124:../Sources/drivers/mcg/mcg.c ****     (
 125:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
  48              		.loc 1 125 0
  49 000e 4FF48043 		mov	r3, #16384
  50 0012 C4F20603 		movt	r3, 16390
  51 0016 9B79     		ldrb	r3, [r3, #6]
  52 0018 DBB2     		uxtb	r3, r3
  53 001a 03F00C03 		and	r3, r3, #12
  54 001e 4FEA9303 		lsr	r3, r3, #2
 124:../Sources/drivers/mcg/mcg.c ****     (
  55              		.loc 1 124 0
  56 0022 002B     		cmp	r3, #0
  57 0024 13D1     		bne	.L2
 126:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
  58              		.loc 1 126 0
  59 0026 4FF48043 		mov	r3, #16384
  60 002a C4F20603 		movt	r3, 16390
  61 002e 9B79     		ldrb	r3, [r3, #6]
  62 0030 DBB2     		uxtb	r3, r3
  63 0032 03F01003 		and	r3, r3, #16
  64 0036 002B     		cmp	r3, #0
  65 0038 09D0     		beq	.L2
 127:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))
  66              		.loc 1 127 0
  67 003a 4FF48043 		mov	r3, #16384
  68 003e C4F20603 		movt	r3, 16390
  69 0042 9B79     		ldrb	r3, [r3, #6]
  70 0044 DBB2     		uxtb	r3, r3
  71 0046 03F02003 		and	r3, r3, #32
 125:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
  72              		.loc 1 125 0
  73 004a 002B     		cmp	r3, #0
  74 004c 02D0     		beq	.L3
  75              	.L2:
 128:../Sources/drivers/mcg/mcg.c ****          )
 129:../Sources/drivers/mcg/mcg.c ****     )                       // check PLLS mux has selected FLL
 130:../Sources/drivers/mcg/mcg.c ****         {
 131:../Sources/drivers/mcg/mcg.c ****             return 0x1;         // return error code
  76              		.loc 1 131 0
  77 004e 4FF00103 		mov	r3, #1
  78 0052 62E2     		b	.L4
  79              	.L3:
 132:../Sources/drivers/mcg/mcg.c ****         }
 133:../Sources/drivers/mcg/mcg.c **** 
 134:../Sources/drivers/mcg/mcg.c ****     // check external frequency is less than the maximum frequency
 135:../Sources/drivers/mcg/mcg.c **** 
 136:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
  80              		.loc 1 136 0
  81 0054 7A68     		ldr	r2, [r7, #4]
  82 0056 4FF28003 		movw	r3, #61568
  83 005a C0F2FA23 		movt	r3, 762
  84 005e 9A42     		cmp	r2, r3
  85 0060 02DD     		ble	.L5
 137:../Sources/drivers/mcg/mcg.c ****         {
 138:../Sources/drivers/mcg/mcg.c ****             return 0x21;
  86              		.loc 1 138 0
  87 0062 4FF02103 		mov	r3, #33
  88 0066 58E2     		b	.L4
  89              	.L5:
 139:../Sources/drivers/mcg/mcg.c ****         }
 140:../Sources/drivers/mcg/mcg.c **** 
 141:../Sources/drivers/mcg/mcg.c ****     // check crystal frequency is within spec. if crystal osc is being used as PLL ref
 142:../Sources/drivers/mcg/mcg.c **** 
 143:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
  90              		.loc 1 143 0
  91 0068 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
  92 006a 002B     		cmp	r3, #0
  93 006c 10D0     		beq	.L6
 144:../Sources/drivers/mcg/mcg.c ****         {
 145:../Sources/drivers/mcg/mcg.c ****             if((crystal_val < 3000000) || (crystal_val > 32000000))
  94              		.loc 1 145 0
  95 006e 7A68     		ldr	r2, [r7, #4]
  96 0070 4CF2BF63 		movw	r3, #50879
  97 0074 C0F22D03 		movt	r3, 45
  98 0078 9A42     		cmp	r2, r3
  99 007a 06DD     		ble	.L7
 100              		.loc 1 145 0 is_stmt 0
 101 007c 7A68     		ldr	r2, [r7, #4]
 102 007e 4FF49043 		mov	r3, #18432
 103 0082 C0F2E813 		movt	r3, 488
 104 0086 9A42     		cmp	r2, r3
 105 0088 02DD     		ble	.L6
 106              	.L7:
 146:../Sources/drivers/mcg/mcg.c ****                 {
 147:../Sources/drivers/mcg/mcg.c ****                     return 0x22;    // return 1 if one of the available crystal options is not avai
 107              		.loc 1 147 0 is_stmt 1
 108 008a 4FF02203 		mov	r3, #34
 109 008e 44E2     		b	.L4
 110              	.L6:
 148:../Sources/drivers/mcg/mcg.c ****                 }
 149:../Sources/drivers/mcg/mcg.c ****         }
 150:../Sources/drivers/mcg/mcg.c **** 
 151:../Sources/drivers/mcg/mcg.c ****     // make sure HGO will never be greater than 1. Could return an error instead if desired.
 152:../Sources/drivers/mcg/mcg.c **** 
 153:../Sources/drivers/mcg/mcg.c ****     if(hgo_val > 0)
 111              		.loc 1 153 0
 112 0090 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 113 0092 002B     		cmp	r3, #0
 114 0094 02D0     		beq	.L8
 154:../Sources/drivers/mcg/mcg.c ****         {
 155:../Sources/drivers/mcg/mcg.c ****             hgo_val = 1;        // force hgo_val to 1 if > 0
 115              		.loc 1 155 0
 116 0096 4FF00103 		mov	r3, #1
 117 009a FB70     		strb	r3, [r7, #3]
 118              	.L8:
 156:../Sources/drivers/mcg/mcg.c ****         }
 157:../Sources/drivers/mcg/mcg.c **** 
 158:../Sources/drivers/mcg/mcg.c ****     // Check PLL divider settings are within spec.
 159:../Sources/drivers/mcg/mcg.c **** 
 160:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 119              		.loc 1 160 0
 120 009c 97F90130 		ldrsb	r3, [r7, #1]
 121 00a0 002B     		cmp	r3, #0
 122 00a2 03DD     		ble	.L9
 123              		.loc 1 160 0 is_stmt 0
 124 00a4 97F90130 		ldrsb	r3, [r7, #1]
 125 00a8 192B     		cmp	r3, #25
 126 00aa 02DD     		ble	.L10
 127              	.L9:
 161:../Sources/drivers/mcg/mcg.c ****         {
 162:../Sources/drivers/mcg/mcg.c ****             return 0x41;
 128              		.loc 1 162 0 is_stmt 1
 129 00ac 4FF04103 		mov	r3, #65
 130 00b0 33E2     		b	.L4
 131              	.L10:
 163:../Sources/drivers/mcg/mcg.c ****         }
 164:../Sources/drivers/mcg/mcg.c **** 
 165:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 132              		.loc 1 165 0
 133 00b2 97F92030 		ldrsb	r3, [r7, #32]
 134 00b6 172B     		cmp	r3, #23
 135 00b8 03DD     		ble	.L11
 136              		.loc 1 165 0 is_stmt 0
 137 00ba 97F92030 		ldrsb	r3, [r7, #32]
 138 00be 322B     		cmp	r3, #50
 139 00c0 02DD     		ble	.L12
 140              	.L11:
 166:../Sources/drivers/mcg/mcg.c ****         {
 167:../Sources/drivers/mcg/mcg.c ****             return 0x42;
 141              		.loc 1 167 0 is_stmt 1
 142 00c2 4FF04203 		mov	r3, #66
 143 00c6 28E2     		b	.L4
 144              	.L12:
 168:../Sources/drivers/mcg/mcg.c ****         }
 169:../Sources/drivers/mcg/mcg.c **** 
 170:../Sources/drivers/mcg/mcg.c ****     // Check PLL reference clock frequency is within spec.
 171:../Sources/drivers/mcg/mcg.c ****     ref_freq = crystal_val / prdiv_val;
 145              		.loc 1 171 0
 146 00c8 97F90130 		ldrsb	r3, [r7, #1]
 147 00cc 7A68     		ldr	r2, [r7, #4]
 148 00ce 92FBF3F3 		sdiv	r3, r2, r3
 149 00d2 3B61     		str	r3, [r7, #16]
 172:../Sources/drivers/mcg/mcg.c **** 
 173:../Sources/drivers/mcg/mcg.c ****     if((ref_freq < 2000000) || (ref_freq > 4000000))
 150              		.loc 1 173 0
 151 00d4 3A69     		ldr	r2, [r7, #16]
 152 00d6 48F27F43 		movw	r3, #33919
 153 00da C0F21E03 		movt	r3, 30
 154 00de 9A42     		cmp	r2, r3
 155 00e0 06DD     		ble	.L13
 156              		.loc 1 173 0 is_stmt 0
 157 00e2 3A69     		ldr	r2, [r7, #16]
 158 00e4 4FF41063 		mov	r3, #2304
 159 00e8 C0F23D03 		movt	r3, 61
 160 00ec 9A42     		cmp	r2, r3
 161 00ee 02DD     		ble	.L14
 162              	.L13:
 174:../Sources/drivers/mcg/mcg.c ****         {
 175:../Sources/drivers/mcg/mcg.c ****             return 0x43;
 163              		.loc 1 175 0 is_stmt 1
 164 00f0 4FF04303 		mov	r3, #67
 165 00f4 11E2     		b	.L4
 166              	.L14:
 176:../Sources/drivers/mcg/mcg.c ****         }
 177:../Sources/drivers/mcg/mcg.c **** 
 178:../Sources/drivers/mcg/mcg.c ****     // Check PLL output frequency is within spec.
 179:../Sources/drivers/mcg/mcg.c ****     pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 167              		.loc 1 179 0
 168 00f6 97F90130 		ldrsb	r3, [r7, #1]
 169 00fa 7A68     		ldr	r2, [r7, #4]
 170 00fc 92FBF3F3 		sdiv	r3, r2, r3
 171 0100 97F92020 		ldrsb	r2, [r7, #32]
 172 0104 02FB03F3 		mul	r3, r2, r3
 173 0108 FB60     		str	r3, [r7, #12]
 180:../Sources/drivers/mcg/mcg.c **** 
 181:../Sources/drivers/mcg/mcg.c ****     if((pll_freq < 48000000) || (pll_freq > 100000000))
 174              		.loc 1 181 0
 175 010a FA68     		ldr	r2, [r7, #12]
 176 010c 46F6FF33 		movw	r3, #27647
 177 0110 C0F2DC23 		movt	r3, 732
 178 0114 9A42     		cmp	r2, r3
 179 0116 06DD     		ble	.L15
 180              		.loc 1 181 0 is_stmt 0
 181 0118 FA68     		ldr	r2, [r7, #12]
 182 011a 4FF46143 		mov	r3, #57600
 183 011e C0F2F553 		movt	r3, 1525
 184 0122 9A42     		cmp	r2, r3
 185 0124 02DD     		ble	.L16
 186              	.L15:
 182:../Sources/drivers/mcg/mcg.c ****         {
 183:../Sources/drivers/mcg/mcg.c ****             return 0x45;
 187              		.loc 1 183 0 is_stmt 1
 188 0126 4FF04503 		mov	r3, #69
 189 012a F6E1     		b	.L4
 190              	.L16:
 184:../Sources/drivers/mcg/mcg.c ****         }
 185:../Sources/drivers/mcg/mcg.c **** 
 186:../Sources/drivers/mcg/mcg.c ****     // configure the MCG_C2 register
 187:../Sources/drivers/mcg/mcg.c ****     // the RANGE value is determined by the external frequency. Since the RANGE parameter affects t
 188:../Sources/drivers/mcg/mcg.c ****     // it still needs to be set correctly even if the oscillator is not being used
 189:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 191              		.loc 1 189 0
 192 012c 4FF48043 		mov	r3, #16384
 193 0130 C4F20603 		movt	r3, 16390
 194 0134 5B78     		ldrb	r3, [r3, #1]
 195 0136 BB75     		strb	r3, [r7, #22]
 190:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 196              		.loc 1 190 0
 197 0138 BB7D     		ldrb	r3, [r7, #22]
 198 013a 23F03C03 		bic	r3, r3, #60
 199 013e BB75     		strb	r3, [r7, #22]
 191:../Sources/drivers/mcg/mcg.c **** 
 192:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 8000000)
 200              		.loc 1 192 0
 201 0140 7A68     		ldr	r2, [r7, #4]
 202 0142 4FF49053 		mov	r3, #4608
 203 0146 C0F27A03 		movt	r3, 122
 204 014a 9A42     		cmp	r2, r3
 205 014c 10DC     		bgt	.L17
 193:../Sources/drivers/mcg/mcg.c ****         {
 194:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 206              		.loc 1 194 0
 207 014e FB78     		ldrb	r3, [r7, #3]
 208 0150 4FEAC303 		lsl	r3, r3, #3
 209 0154 DAB2     		uxtb	r2, r3
 210 0156 BB78     		ldrb	r3, [r7, #2]
 211 0158 4FEA8303 		lsl	r3, r3, #2
 212 015c DBB2     		uxtb	r3, r3
 213 015e 1343     		orrs	r3, r3, r2
 214 0160 DAB2     		uxtb	r2, r3
 215 0162 BB7D     		ldrb	r3, [r7, #22]
 216 0164 1343     		orrs	r3, r3, r2
 217 0166 DBB2     		uxtb	r3, r3
 218 0168 43F01003 		orr	r3, r3, #16
 219 016c BB75     		strb	r3, [r7, #22]
 220 016e 0FE0     		b	.L18
 221              	.L17:
 195:../Sources/drivers/mcg/mcg.c ****         }
 196:../Sources/drivers/mcg/mcg.c ****     else
 197:../Sources/drivers/mcg/mcg.c ****         {
 198:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 222              		.loc 1 198 0
 223 0170 FB78     		ldrb	r3, [r7, #3]
 224 0172 4FEAC303 		lsl	r3, r3, #3
 225 0176 DAB2     		uxtb	r2, r3
 226 0178 BB78     		ldrb	r3, [r7, #2]
 227 017a 4FEA8303 		lsl	r3, r3, #2
 228 017e DBB2     		uxtb	r3, r3
 229 0180 1343     		orrs	r3, r3, r2
 230 0182 DAB2     		uxtb	r2, r3
 231 0184 BB7D     		ldrb	r3, [r7, #22]
 232 0186 1343     		orrs	r3, r3, r2
 233 0188 DBB2     		uxtb	r3, r3
 234 018a 43F02003 		orr	r3, r3, #32
 235 018e BB75     		strb	r3, [r7, #22]
 236              	.L18:
 199:../Sources/drivers/mcg/mcg.c ****         }
 200:../Sources/drivers/mcg/mcg.c **** 
 201:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 237              		.loc 1 201 0
 238 0190 4FF48043 		mov	r3, #16384
 239 0194 C4F20603 		movt	r3, 16390
 240 0198 BA7D     		ldrb	r2, [r7, #22]
 241 019a 5A70     		strb	r2, [r3, #1]
 202:../Sources/drivers/mcg/mcg.c **** 
 203:../Sources/drivers/mcg/mcg.c ****     // determine FRDIV based on reference clock frequency
 204:../Sources/drivers/mcg/mcg.c ****     // since the external frequency has already been checked only the maximum frequency for each FR
 205:../Sources/drivers/mcg/mcg.c **** 
 206:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 242              		.loc 1 206 0
 243 019c 7A68     		ldr	r2, [r7, #4]
 244 019e 41F2D023 		movw	r3, #4816
 245 01a2 C0F21303 		movt	r3, 19
 246 01a6 9A42     		cmp	r2, r3
 247 01a8 03DC     		bgt	.L19
 207:../Sources/drivers/mcg/mcg.c ****         {
 208:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 0;
 248              		.loc 1 208 0
 249 01aa 4FF00003 		mov	r3, #0
 250 01ae FB75     		strb	r3, [r7, #23]
 251 01b0 2EE0     		b	.L20
 252              	.L19:
 209:../Sources/drivers/mcg/mcg.c ****         }
 210:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 253              		.loc 1 210 0
 254 01b2 7A68     		ldr	r2, [r7, #4]
 255 01b4 42F2A053 		movw	r3, #9632
 256 01b8 C0F22603 		movt	r3, 38
 257 01bc 9A42     		cmp	r2, r3
 258 01be 03DC     		bgt	.L21
 211:../Sources/drivers/mcg/mcg.c ****         {
 212:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 1;
 259              		.loc 1 212 0
 260 01c0 4FF00103 		mov	r3, #1
 261 01c4 FB75     		strb	r3, [r7, #23]
 262 01c6 23E0     		b	.L20
 263              	.L21:
 213:../Sources/drivers/mcg/mcg.c ****         }
 214:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 264              		.loc 1 214 0
 265 01c8 7A68     		ldr	r2, [r7, #4]
 266 01ca 44F64033 		movw	r3, #19264
 267 01ce C0F24C03 		movt	r3, 76
 268 01d2 9A42     		cmp	r2, r3
 269 01d4 03DC     		bgt	.L22
 215:../Sources/drivers/mcg/mcg.c ****         {
 216:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 2;
 270              		.loc 1 216 0
 271 01d6 4FF00203 		mov	r3, #2
 272 01da FB75     		strb	r3, [r7, #23]
 273 01dc 18E0     		b	.L20
 274              	.L22:
 217:../Sources/drivers/mcg/mcg.c ****         }
 218:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 275              		.loc 1 218 0
 276 01de 7A68     		ldr	r2, [r7, #4]
 277 01e0 49F28063 		movw	r3, #38528
 278 01e4 C0F29803 		movt	r3, 152
 279 01e8 9A42     		cmp	r2, r3
 280 01ea 03DC     		bgt	.L23
 219:../Sources/drivers/mcg/mcg.c ****         {
 220:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 3;
 281              		.loc 1 220 0
 282 01ec 4FF00303 		mov	r3, #3
 283 01f0 FB75     		strb	r3, [r7, #23]
 284 01f2 0DE0     		b	.L20
 285              	.L23:
 221:../Sources/drivers/mcg/mcg.c ****         }
 222:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 286              		.loc 1 222 0
 287 01f4 7A68     		ldr	r2, [r7, #4]
 288 01f6 4FF43453 		mov	r3, #11520
 289 01fa C0F23113 		movt	r3, 305
 290 01fe 9A42     		cmp	r2, r3
 291 0200 03DC     		bgt	.L24
 223:../Sources/drivers/mcg/mcg.c ****         {
 224:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 4;
 292              		.loc 1 224 0
 293 0202 4FF00403 		mov	r3, #4
 294 0206 FB75     		strb	r3, [r7, #23]
 295 0208 02E0     		b	.L20
 296              	.L24:
 225:../Sources/drivers/mcg/mcg.c ****         }
 226:../Sources/drivers/mcg/mcg.c ****     else
 227:../Sources/drivers/mcg/mcg.c ****         {
 228:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 5;
 297              		.loc 1 228 0
 298 020a 4FF00503 		mov	r3, #5
 299 020e FB75     		strb	r3, [r7, #23]
 300              	.L20:
 229:../Sources/drivers/mcg/mcg.c ****         }
 230:../Sources/drivers/mcg/mcg.c **** 
 231:../Sources/drivers/mcg/mcg.c ****     // Select external oscillator and Reference Divider and clear IREFS to start ext osc
 232:../Sources/drivers/mcg/mcg.c ****     // If IRCLK is required it must be enabled outside of this driver, existing state will be maint
 233:../Sources/drivers/mcg/mcg.c ****     // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
 234:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 301              		.loc 1 234 0
 302 0210 4FF48043 		mov	r3, #16384
 303 0214 C4F20603 		movt	r3, 16390
 304 0218 1B78     		ldrb	r3, [r3, #0]
 305 021a BB75     		strb	r3, [r7, #22]
 235:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
 306              		.loc 1 235 0
 307 021c BB7D     		ldrb	r3, [r7, #22]
 308 021e 03F00303 		and	r3, r3, #3
 309 0222 BB75     		strb	r3, [r7, #22]
 236:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 310              		.loc 1 236 0
 311 0224 FB7D     		ldrb	r3, [r7, #23]
 312 0226 4FEAC303 		lsl	r3, r3, #3
 313 022a DBB2     		uxtb	r3, r3
 314 022c 03F03803 		and	r3, r3, #56
 315 0230 DAB2     		uxtb	r2, r3
 316 0232 BB7D     		ldrb	r3, [r7, #22]
 317 0234 1343     		orrs	r3, r3, r2
 318 0236 DBB2     		uxtb	r3, r3
 319 0238 63F07F03 		orn	r3, r3, #127
 320 023c BB75     		strb	r3, [r7, #22]
 237:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 321              		.loc 1 237 0
 322 023e 4FF48043 		mov	r3, #16384
 323 0242 C4F20603 		movt	r3, 16390
 324 0246 BA7D     		ldrb	r2, [r7, #22]
 325 0248 1A70     		strb	r2, [r3, #0]
 238:../Sources/drivers/mcg/mcg.c **** 
 239:../Sources/drivers/mcg/mcg.c ****     // if the external oscillator is used need to wait for OSCINIT to set
 240:../Sources/drivers/mcg/mcg.c **** 
 241:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 326              		.loc 1 241 0
 327 024a BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 328 024c 002B     		cmp	r3, #0
 329 024e 26D0     		beq	.L25
 242:../Sources/drivers/mcg/mcg.c ****         {
 243:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 20000; i++)
 330              		.loc 1 243 0
 331 0250 4FF00003 		mov	r3, #0
 332 0254 BB82     		strh	r3, [r7, #20]	@ movhi
 333 0256 0DE0     		b	.L26
 334              	.L29:
 244:../Sources/drivers/mcg/mcg.c ****                 {
 245:../Sources/drivers/mcg/mcg.c ****                     if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out ear
 335              		.loc 1 245 0
 336 0258 4FF48043 		mov	r3, #16384
 337 025c C4F20603 		movt	r3, 16390
 338 0260 9B79     		ldrb	r3, [r3, #6]
 339 0262 DBB2     		uxtb	r3, r3
 340 0264 03F00203 		and	r3, r3, #2
 341 0268 002B     		cmp	r3, #0
 342 026a 0AD1     		bne	.L55
 343              	.L27:
 243:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 20000; i++)
 344              		.loc 1 243 0
 345 026c BB8A     		ldrh	r3, [r7, #20]	@ movhi
 346 026e 03F10103 		add	r3, r3, #1
 347 0272 BB82     		strh	r3, [r7, #20]	@ movhi
 348              	.L26:
 243:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 20000; i++)
 349              		.loc 1 243 0 is_stmt 0
 350 0274 B7F91420 		ldrsh	r2, [r7, #20]
 351 0278 44F61F63 		movw	r3, #19999
 352 027c 9A42     		cmp	r2, r3
 353 027e EBDD     		ble	.L29
 354 0280 00E0     		b	.L28
 355              	.L55:
 356              		.loc 1 245 0 is_stmt 1
 357 0282 00BF     		nop
 358              	.L28:
 246:../Sources/drivers/mcg/mcg.c ****                 }
 247:../Sources/drivers/mcg/mcg.c **** 
 248:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is rea
 359              		.loc 1 248 0
 360 0284 4FF48043 		mov	r3, #16384
 361 0288 C4F20603 		movt	r3, 16390
 362 028c 9B79     		ldrb	r3, [r3, #6]
 363 028e DBB2     		uxtb	r3, r3
 364 0290 03F00203 		and	r3, r3, #2
 365 0294 002B     		cmp	r3, #0
 366 0296 02D1     		bne	.L25
 367              		.loc 1 248 0 is_stmt 0
 368 0298 4FF02303 		mov	r3, #35
 369 029c 3DE1     		b	.L4
 370              	.L25:
 249:../Sources/drivers/mcg/mcg.c ****         }
 250:../Sources/drivers/mcg/mcg.c **** 
 251:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
 252:../Sources/drivers/mcg/mcg.c **** 
 253:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 371              		.loc 1 253 0 is_stmt 1
 372 029e 4FF00003 		mov	r3, #0
 373 02a2 BB82     		strh	r3, [r7, #20]	@ movhi
 374 02a4 0DE0     		b	.L30
 375              	.L33:
 254:../Sources/drivers/mcg/mcg.c ****         {
 255:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early i
 376              		.loc 1 255 0
 377 02a6 4FF48043 		mov	r3, #16384
 378 02aa C4F20603 		movt	r3, 16390
 379 02ae 9B79     		ldrb	r3, [r3, #6]
 380 02b0 DBB2     		uxtb	r3, r3
 381 02b2 03F01003 		and	r3, r3, #16
 382 02b6 002B     		cmp	r3, #0
 383 02b8 0AD0     		beq	.L56
 384              	.L31:
 253:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 385              		.loc 1 253 0
 386 02ba BB8A     		ldrh	r3, [r7, #20]	@ movhi
 387 02bc 03F10103 		add	r3, r3, #1
 388 02c0 BB82     		strh	r3, [r7, #20]	@ movhi
 389              	.L30:
 253:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 390              		.loc 1 253 0 is_stmt 0
 391 02c2 B7F91420 		ldrsh	r2, [r7, #20]
 392 02c6 40F2CF73 		movw	r3, #1999
 393 02ca 9A42     		cmp	r2, r3
 394 02cc EBDD     		ble	.L33
 395 02ce 00E0     		b	.L32
 396              	.L56:
 397              		.loc 1 255 0 is_stmt 1
 398 02d0 00BF     		nop
 399              	.L32:
 256:../Sources/drivers/mcg/mcg.c ****         }
 257:../Sources/drivers/mcg/mcg.c **** 
 258:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 400              		.loc 1 258 0
 401 02d2 4FF48043 		mov	r3, #16384
 402 02d6 C4F20603 		movt	r3, 16390
 403 02da 9B79     		ldrb	r3, [r3, #6]
 404 02dc DBB2     		uxtb	r3, r3
 405 02de 03F01003 		and	r3, r3, #16
 406 02e2 002B     		cmp	r3, #0
 407 02e4 02D0     		beq	.L34
 408              		.loc 1 258 0 is_stmt 0
 409 02e6 4FF01103 		mov	r3, #17
 410 02ea 16E1     		b	.L4
 411              	.L34:
 259:../Sources/drivers/mcg/mcg.c **** 
 260:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
 261:../Sources/drivers/mcg/mcg.c **** 
 262:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 412              		.loc 1 262 0 is_stmt 1
 413 02ec 4FF00003 		mov	r3, #0
 414 02f0 BB82     		strh	r3, [r7, #20]	@ movhi
 415 02f2 0FE0     		b	.L35
 416              	.L38:
 263:../Sources/drivers/mcg/mcg.c ****         {
 264:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early i
 417              		.loc 1 264 0
 418 02f4 4FF48043 		mov	r3, #16384
 419 02f8 C4F20603 		movt	r3, 16390
 420 02fc 9B79     		ldrb	r3, [r3, #6]
 421 02fe DBB2     		uxtb	r3, r3
 422 0300 03F00C03 		and	r3, r3, #12
 423 0304 4FEA9303 		lsr	r3, r3, #2
 424 0308 022B     		cmp	r3, #2
 425 030a 0AD0     		beq	.L57
 426              	.L36:
 262:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 427              		.loc 1 262 0
 428 030c BB8A     		ldrh	r3, [r7, #20]	@ movhi
 429 030e 03F10103 		add	r3, r3, #1
 430 0312 BB82     		strh	r3, [r7, #20]	@ movhi
 431              	.L35:
 262:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 432              		.loc 1 262 0 is_stmt 0
 433 0314 B7F91420 		ldrsh	r2, [r7, #20]
 434 0318 40F2CF73 		movw	r3, #1999
 435 031c 9A42     		cmp	r2, r3
 436 031e E9DD     		ble	.L38
 437 0320 00E0     		b	.L37
 438              	.L57:
 439              		.loc 1 264 0 is_stmt 1
 440 0322 00BF     		nop
 441              	.L37:
 265:../Sources/drivers/mcg/mcg.c ****         }
 266:../Sources/drivers/mcg/mcg.c **** 
 267:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 442              		.loc 1 267 0
 443 0324 4FF48043 		mov	r3, #16384
 444 0328 C4F20603 		movt	r3, 16390
 445 032c 9B79     		ldrb	r3, [r3, #6]
 446 032e DBB2     		uxtb	r3, r3
 447 0330 03F00C03 		and	r3, r3, #12
 448 0334 4FEA9303 		lsr	r3, r3, #2
 449 0338 022B     		cmp	r3, #2
 450 033a 02D0     		beq	.L39
 451              		.loc 1 267 0 is_stmt 0
 452 033c 4FF01A03 		mov	r3, #26
 453 0340 EBE0     		b	.L4
 454              	.L39:
 268:../Sources/drivers/mcg/mcg.c **** 
 269:../Sources/drivers/mcg/mcg.c ****     // Now in FBE
 270:../Sources/drivers/mcg/mcg.c ****     // It is recommended that the clock monitor is enabled when using an external clock as the cloc
 271:../Sources/drivers/mcg/mcg.c ****     // It is enabled here but can be removed if this is not required.
 272:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 455              		.loc 1 272 0 is_stmt 1
 456 0342 4FF48043 		mov	r3, #16384
 457 0346 C4F20603 		movt	r3, 16390
 458 034a 4FF48042 		mov	r2, #16384
 459 034e C4F20602 		movt	r2, 16390
 460 0352 5279     		ldrb	r2, [r2, #5]
 461 0354 D2B2     		uxtb	r2, r2
 462 0356 42F02002 		orr	r2, r2, #32
 463 035a D2B2     		uxtb	r2, r2
 464 035c 5A71     		strb	r2, [r3, #5]
 273:../Sources/drivers/mcg/mcg.c ****     // Configure PLL
 274:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C5
 275:../Sources/drivers/mcg/mcg.c ****     // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user 
 276:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 465              		.loc 1 276 0
 466 035e 4FF48043 		mov	r3, #16384
 467 0362 C4F20603 		movt	r3, 16390
 468 0366 1B79     		ldrb	r3, [r3, #4]
 469 0368 BB75     		strb	r3, [r7, #22]
 277:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 470              		.loc 1 277 0
 471 036a BB7D     		ldrb	r3, [r7, #22]
 472 036c 23F01F03 		bic	r3, r3, #31
 473 0370 BB75     		strb	r3, [r7, #22]
 278:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 474              		.loc 1 278 0
 475 0372 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 476 0374 03F1FF33 		add	r3, r3, #-1
 477 0378 DBB2     		uxtb	r3, r3
 478 037a 03F01F03 		and	r3, r3, #31
 479 037e DAB2     		uxtb	r2, r3
 480 0380 BB7D     		ldrb	r3, [r7, #22]
 481 0382 1343     		orrs	r3, r3, r2
 482 0384 BB75     		strb	r3, [r7, #22]
 279:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 483              		.loc 1 279 0
 484 0386 4FF48043 		mov	r3, #16384
 485 038a C4F20603 		movt	r3, 16390
 486 038e BA7D     		ldrb	r2, [r7, #22]
 487 0390 1A71     		strb	r2, [r3, #4]
 280:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C6
 281:../Sources/drivers/mcg/mcg.c ****     // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 282:../Sources/drivers/mcg/mcg.c ****     // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 283:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 488              		.loc 1 283 0
 489 0392 4FF48043 		mov	r3, #16384
 490 0396 C4F20603 		movt	r3, 16390
 491 039a 5B79     		ldrb	r3, [r3, #5]
 492 039c BB75     		strb	r3, [r7, #22]
 284:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 493              		.loc 1 284 0
 494 039e BB7D     		ldrb	r3, [r7, #22]
 495 03a0 23F01F03 		bic	r3, r3, #31
 496 03a4 BB75     		strb	r3, [r7, #22]
 285:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 497              		.loc 1 285 0
 498 03a6 97F82030 		ldrb	r3, [r7, #32]	@ zero_extendqisi2
 499 03aa A3F11803 		sub	r3, r3, #24
 500 03ae DBB2     		uxtb	r3, r3
 501 03b0 03F01F03 		and	r3, r3, #31
 502 03b4 DAB2     		uxtb	r2, r3
 503 03b6 BB7D     		ldrb	r3, [r7, #22]
 504 03b8 1343     		orrs	r3, r3, r2
 505 03ba DBB2     		uxtb	r3, r3
 506 03bc 43F04003 		orr	r3, r3, #64
 507 03c0 BB75     		strb	r3, [r7, #22]
 286:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 508              		.loc 1 286 0
 509 03c2 4FF48043 		mov	r3, #16384
 510 03c6 C4F20603 		movt	r3, 16390
 511 03ca BA7D     		ldrb	r2, [r7, #22]
 512 03cc 5A71     		strb	r2, [r3, #5]
 287:../Sources/drivers/mcg/mcg.c **** 
 288:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to set
 289:../Sources/drivers/mcg/mcg.c **** 
 290:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 513              		.loc 1 290 0
 514 03ce 4FF00003 		mov	r3, #0
 515 03d2 BB82     		strh	r3, [r7, #20]	@ movhi
 516 03d4 0DE0     		b	.L40
 517              	.L43:
 291:../Sources/drivers/mcg/mcg.c ****         {
 292:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishe
 518              		.loc 1 292 0
 519 03d6 4FF48043 		mov	r3, #16384
 520 03da C4F20603 		movt	r3, 16390
 521 03de 9B79     		ldrb	r3, [r3, #6]
 522 03e0 DBB2     		uxtb	r3, r3
 523 03e2 03F02003 		and	r3, r3, #32
 524 03e6 002B     		cmp	r3, #0
 525 03e8 0AD1     		bne	.L58
 526              	.L41:
 290:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 527              		.loc 1 290 0
 528 03ea BB8A     		ldrh	r3, [r7, #20]	@ movhi
 529 03ec 03F10103 		add	r3, r3, #1
 530 03f0 BB82     		strh	r3, [r7, #20]	@ movhi
 531              	.L40:
 290:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 532              		.loc 1 290 0 is_stmt 0
 533 03f2 B7F91420 		ldrsh	r2, [r7, #20]
 534 03f6 40F2CF73 		movw	r3, #1999
 535 03fa 9A42     		cmp	r2, r3
 536 03fc EBDD     		ble	.L43
 537 03fe 00E0     		b	.L42
 538              	.L58:
 539              		.loc 1 292 0 is_stmt 1
 540 0400 00BF     		nop
 541              	.L42:
 293:../Sources/drivers/mcg/mcg.c ****         }
 294:../Sources/drivers/mcg/mcg.c **** 
 295:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 542              		.loc 1 295 0
 543 0402 4FF48043 		mov	r3, #16384
 544 0406 C4F20603 		movt	r3, 16390
 545 040a 9B79     		ldrb	r3, [r3, #6]
 546 040c DBB2     		uxtb	r3, r3
 547 040e 03F02003 		and	r3, r3, #32
 548 0412 002B     		cmp	r3, #0
 549 0414 02D1     		bne	.L44
 550              		.loc 1 295 0 is_stmt 0
 551 0416 4FF01603 		mov	r3, #22
 552 041a 7EE0     		b	.L4
 553              	.L44:
 296:../Sources/drivers/mcg/mcg.c **** 
 297:../Sources/drivers/mcg/mcg.c ****     // Wait for LOCK bit to set
 298:../Sources/drivers/mcg/mcg.c **** 
 299:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 4000; i++)
 554              		.loc 1 299 0 is_stmt 1
 555 041c 4FF00003 		mov	r3, #0
 556 0420 BB82     		strh	r3, [r7, #20]	@ movhi
 557 0422 0DE0     		b	.L45
 558              	.L48:
 300:../Sources/drivers/mcg/mcg.c ****         {
 301:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop 
 559              		.loc 1 301 0
 560 0424 4FF48043 		mov	r3, #16384
 561 0428 C4F20603 		movt	r3, 16390
 562 042c 9B79     		ldrb	r3, [r3, #6]
 563 042e DBB2     		uxtb	r3, r3
 564 0430 03F04003 		and	r3, r3, #64
 565 0434 002B     		cmp	r3, #0
 566 0436 0AD1     		bne	.L59
 567              	.L46:
 299:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 4000; i++)
 568              		.loc 1 299 0
 569 0438 BB8A     		ldrh	r3, [r7, #20]	@ movhi
 570 043a 03F10103 		add	r3, r3, #1
 571 043e BB82     		strh	r3, [r7, #20]	@ movhi
 572              	.L45:
 299:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 4000; i++)
 573              		.loc 1 299 0 is_stmt 0
 574 0440 B7F91420 		ldrsh	r2, [r7, #20]
 575 0444 40F69F73 		movw	r3, #3999
 576 0448 9A42     		cmp	r2, r3
 577 044a EBDD     		ble	.L48
 578 044c 00E0     		b	.L47
 579              	.L59:
 580              		.loc 1 301 0 is_stmt 1
 581 044e 00BF     		nop
 582              	.L47:
 302:../Sources/drivers/mcg/mcg.c ****         }
 303:../Sources/drivers/mcg/mcg.c **** 
 304:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 583              		.loc 1 304 0
 584 0450 4FF48043 		mov	r3, #16384
 585 0454 C4F20603 		movt	r3, 16390
 586 0458 9B79     		ldrb	r3, [r3, #6]
 587 045a DBB2     		uxtb	r3, r3
 588 045c 03F04003 		and	r3, r3, #64
 589 0460 002B     		cmp	r3, #0
 590 0462 02D1     		bne	.L49
 591              		.loc 1 304 0 is_stmt 0
 592 0464 4FF04403 		mov	r3, #68
 593 0468 57E0     		b	.L4
 594              	.L49:
 305:../Sources/drivers/mcg/mcg.c **** 
 306:../Sources/drivers/mcg/mcg.c ****     // Use actual PLL settings to calculate PLL frequency
 307:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 595              		.loc 1 307 0 is_stmt 1
 596 046a 4FF48043 		mov	r3, #16384
 597 046e C4F20603 		movt	r3, 16390
 598 0472 1B79     		ldrb	r3, [r3, #4]
 599 0474 DBB2     		uxtb	r3, r3
 600 0476 03F01F03 		and	r3, r3, #31
 601 047a DBB2     		uxtb	r3, r3
 602 047c 03F10103 		add	r3, r3, #1
 603 0480 FB72     		strb	r3, [r7, #11]
 308:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 604              		.loc 1 308 0
 605 0482 4FF48043 		mov	r3, #16384
 606 0486 C4F20603 		movt	r3, 16390
 607 048a 5B79     		ldrb	r3, [r3, #5]
 608 048c DBB2     		uxtb	r3, r3
 609 048e 03F01F03 		and	r3, r3, #31
 610 0492 DBB2     		uxtb	r3, r3
 611 0494 03F11803 		add	r3, r3, #24
 612 0498 BB72     		strb	r3, [r7, #10]
 309:../Sources/drivers/mcg/mcg.c ****     // now in PBE
 310:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 613              		.loc 1 310 0
 614 049a 4FF48043 		mov	r3, #16384
 615 049e C4F20603 		movt	r3, 16390
 616 04a2 4FF48042 		mov	r2, #16384
 617 04a6 C4F20602 		movt	r2, 16390
 618 04aa 1278     		ldrb	r2, [r2, #0]
 619 04ac D2B2     		uxtb	r2, r2
 620 04ae 02F03F02 		and	r2, r2, #63
 621 04b2 D2B2     		uxtb	r2, r2
 622 04b4 1A70     		strb	r2, [r3, #0]
 311:../Sources/drivers/mcg/mcg.c **** 
 312:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
 313:../Sources/drivers/mcg/mcg.c **** 
 314:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 623              		.loc 1 314 0
 624 04b6 4FF00003 		mov	r3, #0
 625 04ba BB82     		strh	r3, [r7, #20]	@ movhi
 626 04bc 0FE0     		b	.L50
 627              	.L53:
 315:../Sources/drivers/mcg/mcg.c ****         {
 316:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break;     // jump out ear
 628              		.loc 1 316 0
 629 04be 4FF48043 		mov	r3, #16384
 630 04c2 C4F20603 		movt	r3, 16390
 631 04c6 9B79     		ldrb	r3, [r3, #6]
 632 04c8 DBB2     		uxtb	r3, r3
 633 04ca 03F00C03 		and	r3, r3, #12
 634 04ce 4FEA9303 		lsr	r3, r3, #2
 635 04d2 032B     		cmp	r3, #3
 636 04d4 0AD0     		beq	.L60
 637              	.L51:
 314:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 638              		.loc 1 314 0
 639 04d6 BB8A     		ldrh	r3, [r7, #20]	@ movhi
 640 04d8 03F10103 		add	r3, r3, #1
 641 04dc BB82     		strh	r3, [r7, #20]	@ movhi
 642              	.L50:
 314:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 643              		.loc 1 314 0 is_stmt 0
 644 04de B7F91420 		ldrsh	r2, [r7, #20]
 645 04e2 40F2CF73 		movw	r3, #1999
 646 04e6 9A42     		cmp	r2, r3
 647 04e8 E9DD     		ble	.L53
 648 04ea 00E0     		b	.L52
 649              	.L60:
 650              		.loc 1 316 0 is_stmt 1
 651 04ec 00BF     		nop
 652              	.L52:
 317:../Sources/drivers/mcg/mcg.c ****         }
 318:../Sources/drivers/mcg/mcg.c **** 
 319:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B;   // check CLKST is s
 653              		.loc 1 319 0
 654 04ee 4FF48043 		mov	r3, #16384
 655 04f2 C4F20603 		movt	r3, 16390
 656 04f6 9B79     		ldrb	r3, [r3, #6]
 657 04f8 DBB2     		uxtb	r3, r3
 658 04fa 03F00C03 		and	r3, r3, #12
 659 04fe 4FEA9303 		lsr	r3, r3, #2
 660 0502 032B     		cmp	r3, #3
 661 0504 02D0     		beq	.L54
 662              		.loc 1 319 0 is_stmt 0
 663 0506 4FF01B03 		mov	r3, #27
 664 050a 06E0     		b	.L4
 665              	.L54:
 320:../Sources/drivers/mcg/mcg.c **** 
 321:../Sources/drivers/mcg/mcg.c ****     // Now in PEE
 322:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 666              		.loc 1 322 0 is_stmt 1
 667 050c FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 668 050e 7A68     		ldr	r2, [r7, #4]
 669 0510 92FBF3F3 		sdiv	r3, r2, r3
 670 0514 BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 671 0516 02FB03F3 		mul	r3, r2, r3
 672              	.L4:
 323:../Sources/drivers/mcg/mcg.c **** }   // pll_init
 673              		.loc 1 323 0
 674 051a 1846     		mov	r0, r3
 675 051c 07F11C07 		add	r7, r7, #28
 676 0520 BD46     		mov	sp, r7
 677 0522 80BC     		pop	{r7}
 678 0524 7047     		bx	lr
 679              		.cfi_endproc
 680              	.LFE0:
 682 0526 00BF     		.section	.text.new_pll_freq,"ax",%progbits
 683              		.align	2
 684              		.global	new_pll_freq
 685              		.thumb
 686              		.thumb_func
 688              	new_pll_freq:
 689              	.LFB1:
 324:../Sources/drivers/mcg/mcg.c **** 
 325:../Sources/drivers/mcg/mcg.c **** /*********************************************************************************************/
 326:../Sources/drivers/mcg/mcg.c **** 
 327:../Sources/drivers/mcg/mcg.c **** /* Functon name : new_pll_freq
 328:../Sources/drivers/mcg/mcg.c ****  *
 329:../Sources/drivers/mcg/mcg.c ****  * Mode transition: Moves from PEE to PBE mode before changing PLL settings and moves back to PEE m
 330:../Sources/drivers/mcg/mcg.c ****  *
 331:../Sources/drivers/mcg/mcg.c ****  * This function provides a safe means of updating the PLL configurations to ensure the system
 332:../Sources/drivers/mcg/mcg.c ****  * does not lose the clock source or is over-clocked as the PLL frequency changes.
 333:../Sources/drivers/mcg/mcg.c ****  * Using the function parameter names the PLL frequency is calculated as follows:
 334:../Sources/drivers/mcg/mcg.c ****  * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
 335:../Sources/drivers/mcg/mcg.c ****  * The various passed parameters are checked to ensure they are within the allowed range. If any
 336:../Sources/drivers/mcg/mcg.c ****  * of these checks fail the driver will exit and return a fail/error code. An error code will
 337:../Sources/drivers/mcg/mcg.c ****  * also be returned if any error occurs during the PLL initialization sequence. Refer to the
 338:../Sources/drivers/mcg/mcg.c ****  * readme file in the mcg driver directory for a list of all these codes.
 339:../Sources/drivers/mcg/mcg.c ****  * This function first moves the MCG to PBE mode to use the external reference clock to provide the
 340:../Sources/drivers/mcg/mcg.c ****  * system clock. The PLL settings are then updated. Once the PLL has re-locked the MCG is moved bac
 341:../Sources/drivers/mcg/mcg.c ****  * to PEE to use the PLL as the system clock.
 342:../Sources/drivers/mcg/mcg.c ****  * Only the PLL PRDIV0 and VDIV0 fields are changed.
 343:../Sources/drivers/mcg/mcg.c ****  *
 344:../Sources/drivers/mcg/mcg.c ****  * Prerequisistes : The MCG must be in PEE mode before calling this routine. It is the responsibili
 345:../Sources/drivers/mcg/mcg.c ****  * of the calling routine to ensure the SIM_CLKDIV1 system clock dividers and any peripheral clock
 346:../Sources/drivers/mcg/mcg.c ****  * dividers are set correctly before or after calling this function to ensure the appropriate clock
 347:../Sources/drivers/mcg/mcg.c ****  * are kept within specification. You would typically change the divider values before calling this
 348:../Sources/drivers/mcg/mcg.c ****  * routine.
 349:../Sources/drivers/mcg/mcg.c ****  *
 350:../Sources/drivers/mcg/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
 351:../Sources/drivers/mcg/mcg.c ****  *                           wave clock source
 352:../Sources/drivers/mcg/mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 353:../Sources/drivers/mcg/mcg.c ****  *                           PLL reference clock frequency
 354:../Sources/drivers/mcg/mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 355:../Sources/drivers/mcg/mcg.c ****  *
 356:../Sources/drivers/mcg/mcg.c ****  * Return value : PLL frequency (Hz) or error code
 357:../Sources/drivers/mcg/mcg.c ****  */
 358:../Sources/drivers/mcg/mcg.c **** 
 359:../Sources/drivers/mcg/mcg.c **** int new_pll_freq
 360:../Sources/drivers/mcg/mcg.c **** (
 361:../Sources/drivers/mcg/mcg.c ****     int         crystal_val,
 362:../Sources/drivers/mcg/mcg.c ****     signed char prdiv_val,
 363:../Sources/drivers/mcg/mcg.c ****     signed char vdiv_val
 364:../Sources/drivers/mcg/mcg.c **** )
 365:../Sources/drivers/mcg/mcg.c **** {
 690              		.loc 1 365 0
 691              		.cfi_startproc
 692              		@ args = 0, pretend = 0, frame = 24
 693              		@ frame_needed = 1, uses_anonymous_args = 0
 694              		@ link register save eliminated.
 695 0000 80B4     		push	{r7}
 696              	.LCFI3:
 697              		.cfi_def_cfa_offset 4
 698              		.cfi_offset 7, -4
 699 0002 87B0     		sub	sp, sp, #28
 700              	.LCFI4:
 701              		.cfi_def_cfa_offset 32
 702 0004 00AF     		add	r7, sp, #0
 703              	.LCFI5:
 704              		.cfi_def_cfa_register 7
 705 0006 7860     		str	r0, [r7, #4]
 706 0008 1346     		mov	r3, r2
 707 000a 0A46     		mov	r2, r1
 708 000c FA70     		strb	r2, [r7, #3]
 709 000e BB70     		strb	r3, [r7, #2]
 366:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 367:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 368:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 369:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 370:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 371:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 372:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
 373:../Sources/drivers/mcg/mcg.c ****     unsigned char   prdiv, vdiv;
 374:../Sources/drivers/mcg/mcg.c ****     short           i;
 375:../Sources/drivers/mcg/mcg.c ****     int             ref_freq;
 376:../Sources/drivers/mcg/mcg.c ****     int             pll_freq;
 377:../Sources/drivers/mcg/mcg.c **** 
 378:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 379:../Sources/drivers/mcg/mcg.c **** 
 380:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 381:../Sources/drivers/mcg/mcg.c **** 
 382:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 383:../Sources/drivers/mcg/mcg.c **** 
 384:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 385:../Sources/drivers/mcg/mcg.c **** 
 386:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 387:../Sources/drivers/mcg/mcg.c **** 
 388:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 389:../Sources/drivers/mcg/mcg.c **** 
 390:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PEE mode
 391:../Sources/drivers/mcg/mcg.c **** 
 392:../Sources/drivers/mcg/mcg.c ****     if
 393:../Sources/drivers/mcg/mcg.c ****     (
 394:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3)    // check CLKS mux has selct
 710              		.loc 1 394 0
 711 0010 4FF48043 		mov	r3, #16384
 712 0014 C4F20603 		movt	r3, 16390
 713 0018 9B79     		ldrb	r3, [r3, #6]
 714 001a DBB2     		uxtb	r3, r3
 715 001c 03F00C03 		and	r3, r3, #12
 716 0020 4FEA9303 		lsr	r3, r3, #2
 393:../Sources/drivers/mcg/mcg.c ****     (
 717              		.loc 1 393 0
 718 0024 032B     		cmp	r3, #3
 719 0026 13D1     		bne	.L62
 395:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 720              		.loc 1 395 0
 721 0028 4FF48043 		mov	r3, #16384
 722 002c C4F20603 		movt	r3, 16390
 723 0030 9B79     		ldrb	r3, [r3, #6]
 724 0032 DBB2     		uxtb	r3, r3
 725 0034 03F01003 		and	r3, r3, #16
 726 0038 002B     		cmp	r3, #0
 727 003a 09D1     		bne	.L62
 396:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_PLLST_MASK)
 728              		.loc 1 396 0
 729 003c 4FF48043 		mov	r3, #16384
 730 0040 C4F20603 		movt	r3, 16390
 731 0044 9B79     		ldrb	r3, [r3, #6]
 732 0046 DBB2     		uxtb	r3, r3
 733 0048 03F02003 		and	r3, r3, #32
 394:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3)    // check CLKS mux has selct
 734              		.loc 1 394 0
 735 004c 002B     		cmp	r3, #0
 736 004e 02D1     		bne	.L63
 737              	.L62:
 397:../Sources/drivers/mcg/mcg.c ****          )
 398:../Sources/drivers/mcg/mcg.c ****     )               // check PLLS mux has selected PLL
 399:../Sources/drivers/mcg/mcg.c ****         {
 400:../Sources/drivers/mcg/mcg.c ****             return 0x8; // return error code
 738              		.loc 1 400 0
 739 0050 4FF00803 		mov	r3, #8
 740 0054 5DE1     		b	.L64
 741              	.L63:
 401:../Sources/drivers/mcg/mcg.c ****         }
 402:../Sources/drivers/mcg/mcg.c **** 
 403:../Sources/drivers/mcg/mcg.c ****     // Check PLL divider settings are within spec.
 404:../Sources/drivers/mcg/mcg.c **** 
 405:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 742              		.loc 1 405 0
 743 0056 97F90330 		ldrsb	r3, [r7, #3]
 744 005a 002B     		cmp	r3, #0
 745 005c 03DD     		ble	.L65
 746              		.loc 1 405 0 is_stmt 0
 747 005e 97F90330 		ldrsb	r3, [r7, #3]
 748 0062 192B     		cmp	r3, #25
 749 0064 02DD     		ble	.L66
 750              	.L65:
 406:../Sources/drivers/mcg/mcg.c ****         {
 407:../Sources/drivers/mcg/mcg.c ****             return 0x41;
 751              		.loc 1 407 0 is_stmt 1
 752 0066 4FF04103 		mov	r3, #65
 753 006a 52E1     		b	.L64
 754              	.L66:
 408:../Sources/drivers/mcg/mcg.c ****         }
 409:../Sources/drivers/mcg/mcg.c **** 
 410:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 755              		.loc 1 410 0
 756 006c 97F90230 		ldrsb	r3, [r7, #2]
 757 0070 172B     		cmp	r3, #23
 758 0072 03DD     		ble	.L67
 759              		.loc 1 410 0 is_stmt 0
 760 0074 97F90230 		ldrsb	r3, [r7, #2]
 761 0078 322B     		cmp	r3, #50
 762 007a 02DD     		ble	.L68
 763              	.L67:
 411:../Sources/drivers/mcg/mcg.c ****         {
 412:../Sources/drivers/mcg/mcg.c ****             return 0x42;
 764              		.loc 1 412 0 is_stmt 1
 765 007c 4FF04203 		mov	r3, #66
 766 0080 47E1     		b	.L64
 767              	.L68:
 413:../Sources/drivers/mcg/mcg.c ****         }
 414:../Sources/drivers/mcg/mcg.c **** 
 415:../Sources/drivers/mcg/mcg.c ****     // Check PLL reference clock frequency is within spec.
 416:../Sources/drivers/mcg/mcg.c ****     ref_freq = crystal_val / prdiv_val;
 768              		.loc 1 416 0
 769 0082 97F90330 		ldrsb	r3, [r7, #3]
 770 0086 7A68     		ldr	r2, [r7, #4]
 771 0088 92FBF3F3 		sdiv	r3, r2, r3
 772 008c 3B61     		str	r3, [r7, #16]
 417:../Sources/drivers/mcg/mcg.c **** 
 418:../Sources/drivers/mcg/mcg.c ****     if((ref_freq < 2000000) || (ref_freq > 4000000))
 773              		.loc 1 418 0
 774 008e 3A69     		ldr	r2, [r7, #16]
 775 0090 48F27F43 		movw	r3, #33919
 776 0094 C0F21E03 		movt	r3, 30
 777 0098 9A42     		cmp	r2, r3
 778 009a 06DD     		ble	.L69
 779              		.loc 1 418 0 is_stmt 0
 780 009c 3A69     		ldr	r2, [r7, #16]
 781 009e 4FF41063 		mov	r3, #2304
 782 00a2 C0F23D03 		movt	r3, 61
 783 00a6 9A42     		cmp	r2, r3
 784 00a8 02DD     		ble	.L70
 785              	.L69:
 419:../Sources/drivers/mcg/mcg.c ****         {
 420:../Sources/drivers/mcg/mcg.c ****             return 0x43;
 786              		.loc 1 420 0 is_stmt 1
 787 00aa 4FF04303 		mov	r3, #67
 788 00ae 30E1     		b	.L64
 789              	.L70:
 421:../Sources/drivers/mcg/mcg.c ****         }
 422:../Sources/drivers/mcg/mcg.c **** 
 423:../Sources/drivers/mcg/mcg.c ****     // Check PLL output frequency is within spec.
 424:../Sources/drivers/mcg/mcg.c ****     pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 790              		.loc 1 424 0
 791 00b0 97F90330 		ldrsb	r3, [r7, #3]
 792 00b4 7A68     		ldr	r2, [r7, #4]
 793 00b6 92FBF3F3 		sdiv	r3, r2, r3
 794 00ba 97F90220 		ldrsb	r2, [r7, #2]
 795 00be 02FB03F3 		mul	r3, r2, r3
 796 00c2 FB60     		str	r3, [r7, #12]
 425:../Sources/drivers/mcg/mcg.c **** 
 426:../Sources/drivers/mcg/mcg.c ****     if((pll_freq < 48000000) || (pll_freq > 100000000))
 797              		.loc 1 426 0
 798 00c4 FA68     		ldr	r2, [r7, #12]
 799 00c6 46F6FF33 		movw	r3, #27647
 800 00ca C0F2DC23 		movt	r3, 732
 801 00ce 9A42     		cmp	r2, r3
 802 00d0 06DD     		ble	.L71
 803              		.loc 1 426 0 is_stmt 0
 804 00d2 FA68     		ldr	r2, [r7, #12]
 805 00d4 4FF46143 		mov	r3, #57600
 806 00d8 C0F2F553 		movt	r3, 1525
 807 00dc 9A42     		cmp	r2, r3
 808 00de 02DD     		ble	.L72
 809              	.L71:
 427:../Sources/drivers/mcg/mcg.c ****         {
 428:../Sources/drivers/mcg/mcg.c ****             return 0x45;
 810              		.loc 1 428 0 is_stmt 1
 811 00e0 4FF04503 		mov	r3, #69
 812 00e4 15E1     		b	.L64
 813              	.L72:
 429:../Sources/drivers/mcg/mcg.c ****         }
 430:../Sources/drivers/mcg/mcg.c **** 
 431:../Sources/drivers/mcg/mcg.c ****     // First move to PBE mode so that the PLL frequency can be safely changed.
 432:../Sources/drivers/mcg/mcg.c ****     // As we are running from the PLL by default the PLL and external clock settings are valid
 433:../Sources/drivers/mcg/mcg.c ****     // To move to PBE from PEE simply requires the switching of the CLKS mux to select the ext cloc
 434:../Sources/drivers/mcg/mcg.c ****     // As CLKS is already 0 the CLKS value can simply be OR'ed into the register
 435:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(2);   // switch CLKS mux to select external reference clock as MCG_OUT
 814              		.loc 1 435 0
 815 00e6 4FF48043 		mov	r3, #16384
 816 00ea C4F20603 		movt	r3, 16390
 817 00ee 4FF48042 		mov	r2, #16384
 818 00f2 C4F20602 		movt	r2, 16390
 819 00f6 1278     		ldrb	r2, [r2, #0]
 820 00f8 D2B2     		uxtb	r2, r2
 821 00fa 62F07F02 		orn	r2, r2, #127
 822 00fe D2B2     		uxtb	r2, r2
 823 0100 1A70     		strb	r2, [r3, #0]
 436:../Sources/drivers/mcg/mcg.c **** 
 437:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
 438:../Sources/drivers/mcg/mcg.c **** 
 439:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 824              		.loc 1 439 0
 825 0102 4FF00003 		mov	r3, #0
 826 0106 FB82     		strh	r3, [r7, #22]	@ movhi
 827 0108 0FE0     		b	.L73
 828              	.L76:
 440:../Sources/drivers/mcg/mcg.c ****         {
 441:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out ear
 829              		.loc 1 441 0
 830 010a 4FF48043 		mov	r3, #16384
 831 010e C4F20603 		movt	r3, 16390
 832 0112 9B79     		ldrb	r3, [r3, #6]
 833 0114 DBB2     		uxtb	r3, r3
 834 0116 03F00C03 		and	r3, r3, #12
 835 011a 4FEA9303 		lsr	r3, r3, #2
 836 011e 022B     		cmp	r3, #2
 837 0120 0AD0     		beq	.L93
 838              	.L74:
 439:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 839              		.loc 1 439 0
 840 0122 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 841 0124 03F10103 		add	r3, r3, #1
 842 0128 FB82     		strh	r3, [r7, #22]	@ movhi
 843              	.L73:
 439:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 844              		.loc 1 439 0 is_stmt 0
 845 012a B7F91620 		ldrsh	r2, [r7, #22]
 846 012e 40F2CF73 		movw	r3, #1999
 847 0132 9A42     		cmp	r2, r3
 848 0134 E9DD     		ble	.L76
 849 0136 00E0     		b	.L75
 850              	.L93:
 851              		.loc 1 441 0 is_stmt 1
 852 0138 00BF     		nop
 853              	.L75:
 442:../Sources/drivers/mcg/mcg.c ****         }
 443:../Sources/drivers/mcg/mcg.c **** 
 444:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 854              		.loc 1 444 0
 855 013a 4FF48043 		mov	r3, #16384
 856 013e C4F20603 		movt	r3, 16390
 857 0142 9B79     		ldrb	r3, [r3, #6]
 858 0144 DBB2     		uxtb	r3, r3
 859 0146 03F00C03 		and	r3, r3, #12
 860 014a 4FEA9303 		lsr	r3, r3, #2
 861 014e 022B     		cmp	r3, #2
 862 0150 02D0     		beq	.L77
 863              		.loc 1 444 0 is_stmt 0
 864 0152 4FF01A03 		mov	r3, #26
 865 0156 DCE0     		b	.L64
 866              	.L77:
 445:../Sources/drivers/mcg/mcg.c **** 
 446:../Sources/drivers/mcg/mcg.c ****     // Now in PBE mode
 447:../Sources/drivers/mcg/mcg.c ****     // System is clocked off the external clock.
 448:../Sources/drivers/mcg/mcg.c ****     // Now update the PLL settings and wait for the PLL to re-lock
 449:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C5
 450:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 867              		.loc 1 450 0 is_stmt 1
 868 0158 4FF48043 		mov	r3, #16384
 869 015c C4F20603 		movt	r3, 16390
 870 0160 1B79     		ldrb	r3, [r3, #4]
 871 0162 FB72     		strb	r3, [r7, #11]
 451:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 872              		.loc 1 451 0
 873 0164 FB7A     		ldrb	r3, [r7, #11]
 874 0166 23F01F03 		bic	r3, r3, #31
 875 016a FB72     		strb	r3, [r7, #11]
 452:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 876              		.loc 1 452 0
 877 016c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 878 016e 03F1FF33 		add	r3, r3, #-1
 879 0172 DBB2     		uxtb	r3, r3
 880 0174 03F01F03 		and	r3, r3, #31
 881 0178 DAB2     		uxtb	r2, r3
 882 017a FB7A     		ldrb	r3, [r7, #11]
 883 017c 1343     		orrs	r3, r3, r2
 884 017e FB72     		strb	r3, [r7, #11]
 453:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 885              		.loc 1 453 0
 886 0180 4FF48043 		mov	r3, #16384
 887 0184 C4F20603 		movt	r3, 16390
 888 0188 FA7A     		ldrb	r2, [r7, #11]
 889 018a 1A71     		strb	r2, [r3, #4]
 454:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C6
 455:../Sources/drivers/mcg/mcg.c ****     // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 456:../Sources/drivers/mcg/mcg.c ****     // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 457:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 890              		.loc 1 457 0
 891 018c 4FF48043 		mov	r3, #16384
 892 0190 C4F20603 		movt	r3, 16390
 893 0194 5B79     		ldrb	r3, [r3, #5]
 894 0196 FB72     		strb	r3, [r7, #11]
 458:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 895              		.loc 1 458 0
 896 0198 FB7A     		ldrb	r3, [r7, #11]
 897 019a 23F01F03 		bic	r3, r3, #31
 898 019e FB72     		strb	r3, [r7, #11]
 459:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 899              		.loc 1 459 0
 900 01a0 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 901 01a2 A3F11803 		sub	r3, r3, #24
 902 01a6 DBB2     		uxtb	r3, r3
 903 01a8 03F01F03 		and	r3, r3, #31
 904 01ac DAB2     		uxtb	r2, r3
 905 01ae FB7A     		ldrb	r3, [r7, #11]
 906 01b0 1343     		orrs	r3, r3, r2
 907 01b2 DBB2     		uxtb	r3, r3
 908 01b4 43F04003 		orr	r3, r3, #64
 909 01b8 FB72     		strb	r3, [r7, #11]
 460:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 910              		.loc 1 460 0
 911 01ba 4FF48043 		mov	r3, #16384
 912 01be C4F20603 		movt	r3, 16390
 913 01c2 FA7A     		ldrb	r2, [r7, #11]
 914 01c4 5A71     		strb	r2, [r3, #5]
 461:../Sources/drivers/mcg/mcg.c **** 
 462:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to set
 463:../Sources/drivers/mcg/mcg.c **** 
 464:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 915              		.loc 1 464 0
 916 01c6 4FF00003 		mov	r3, #0
 917 01ca FB82     		strh	r3, [r7, #22]	@ movhi
 918 01cc 0DE0     		b	.L78
 919              	.L81:
 465:../Sources/drivers/mcg/mcg.c ****         {
 466:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishe
 920              		.loc 1 466 0
 921 01ce 4FF48043 		mov	r3, #16384
 922 01d2 C4F20603 		movt	r3, 16390
 923 01d6 9B79     		ldrb	r3, [r3, #6]
 924 01d8 DBB2     		uxtb	r3, r3
 925 01da 03F02003 		and	r3, r3, #32
 926 01de 002B     		cmp	r3, #0
 927 01e0 0AD1     		bne	.L94
 928              	.L79:
 464:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 929              		.loc 1 464 0
 930 01e2 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 931 01e4 03F10103 		add	r3, r3, #1
 932 01e8 FB82     		strh	r3, [r7, #22]	@ movhi
 933              	.L78:
 464:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 934              		.loc 1 464 0 is_stmt 0
 935 01ea B7F91620 		ldrsh	r2, [r7, #22]
 936 01ee 40F2CF73 		movw	r3, #1999
 937 01f2 9A42     		cmp	r2, r3
 938 01f4 EBDD     		ble	.L81
 939 01f6 00E0     		b	.L80
 940              	.L94:
 941              		.loc 1 466 0 is_stmt 1
 942 01f8 00BF     		nop
 943              	.L80:
 467:../Sources/drivers/mcg/mcg.c ****         }
 468:../Sources/drivers/mcg/mcg.c **** 
 469:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 944              		.loc 1 469 0
 945 01fa 4FF48043 		mov	r3, #16384
 946 01fe C4F20603 		movt	r3, 16390
 947 0202 9B79     		ldrb	r3, [r3, #6]
 948 0204 DBB2     		uxtb	r3, r3
 949 0206 03F02003 		and	r3, r3, #32
 950 020a 002B     		cmp	r3, #0
 951 020c 02D1     		bne	.L82
 952              		.loc 1 469 0 is_stmt 0
 953 020e 4FF01603 		mov	r3, #22
 954 0212 7EE0     		b	.L64
 955              	.L82:
 470:../Sources/drivers/mcg/mcg.c **** 
 471:../Sources/drivers/mcg/mcg.c ****     // Wait for LOCK bit to set
 472:../Sources/drivers/mcg/mcg.c **** 
 473:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 4000; i++)
 956              		.loc 1 473 0 is_stmt 1
 957 0214 4FF00003 		mov	r3, #0
 958 0218 FB82     		strh	r3, [r7, #22]	@ movhi
 959 021a 0DE0     		b	.L83
 960              	.L86:
 474:../Sources/drivers/mcg/mcg.c ****         {
 475:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop 
 961              		.loc 1 475 0
 962 021c 4FF48043 		mov	r3, #16384
 963 0220 C4F20603 		movt	r3, 16390
 964 0224 9B79     		ldrb	r3, [r3, #6]
 965 0226 DBB2     		uxtb	r3, r3
 966 0228 03F04003 		and	r3, r3, #64
 967 022c 002B     		cmp	r3, #0
 968 022e 0AD1     		bne	.L95
 969              	.L84:
 473:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 4000; i++)
 970              		.loc 1 473 0
 971 0230 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 972 0232 03F10103 		add	r3, r3, #1
 973 0236 FB82     		strh	r3, [r7, #22]	@ movhi
 974              	.L83:
 473:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 4000; i++)
 975              		.loc 1 473 0 is_stmt 0
 976 0238 B7F91620 		ldrsh	r2, [r7, #22]
 977 023c 40F69F73 		movw	r3, #3999
 978 0240 9A42     		cmp	r2, r3
 979 0242 EBDD     		ble	.L86
 980 0244 00E0     		b	.L85
 981              	.L95:
 982              		.loc 1 475 0 is_stmt 1
 983 0246 00BF     		nop
 984              	.L85:
 476:../Sources/drivers/mcg/mcg.c ****         }
 477:../Sources/drivers/mcg/mcg.c **** 
 478:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 985              		.loc 1 478 0
 986 0248 4FF48043 		mov	r3, #16384
 987 024c C4F20603 		movt	r3, 16390
 988 0250 9B79     		ldrb	r3, [r3, #6]
 989 0252 DBB2     		uxtb	r3, r3
 990 0254 03F04003 		and	r3, r3, #64
 991 0258 002B     		cmp	r3, #0
 992 025a 02D1     		bne	.L87
 993              		.loc 1 478 0 is_stmt 0
 994 025c 4FF04403 		mov	r3, #68
 995 0260 57E0     		b	.L64
 996              	.L87:
 479:../Sources/drivers/mcg/mcg.c **** 
 480:../Sources/drivers/mcg/mcg.c ****     // Change CLKS mux to now select the PLL output
 481:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 997              		.loc 1 481 0 is_stmt 1
 998 0262 4FF48043 		mov	r3, #16384
 999 0266 C4F20603 		movt	r3, 16390
 1000 026a 4FF48042 		mov	r2, #16384
 1001 026e C4F20602 		movt	r2, 16390
 1002 0272 1278     		ldrb	r2, [r2, #0]
 1003 0274 D2B2     		uxtb	r2, r2
 1004 0276 02F03F02 		and	r2, r2, #63
 1005 027a D2B2     		uxtb	r2, r2
 1006 027c 1A70     		strb	r2, [r3, #0]
 482:../Sources/drivers/mcg/mcg.c **** 
 483:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
 484:../Sources/drivers/mcg/mcg.c **** 
 485:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1007              		.loc 1 485 0
 1008 027e 4FF00003 		mov	r3, #0
 1009 0282 FB82     		strh	r3, [r7, #22]	@ movhi
 1010 0284 0FE0     		b	.L88
 1011              	.L91:
 486:../Sources/drivers/mcg/mcg.c ****         {
 487:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break;     // jump out ear
 1012              		.loc 1 487 0
 1013 0286 4FF48043 		mov	r3, #16384
 1014 028a C4F20603 		movt	r3, 16390
 1015 028e 9B79     		ldrb	r3, [r3, #6]
 1016 0290 DBB2     		uxtb	r3, r3
 1017 0292 03F00C03 		and	r3, r3, #12
 1018 0296 4FEA9303 		lsr	r3, r3, #2
 1019 029a 032B     		cmp	r3, #3
 1020 029c 0AD0     		beq	.L96
 1021              	.L89:
 485:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1022              		.loc 1 485 0
 1023 029e FB8A     		ldrh	r3, [r7, #22]	@ movhi
 1024 02a0 03F10103 		add	r3, r3, #1
 1025 02a4 FB82     		strh	r3, [r7, #22]	@ movhi
 1026              	.L88:
 485:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1027              		.loc 1 485 0 is_stmt 0
 1028 02a6 B7F91620 		ldrsh	r2, [r7, #22]
 1029 02aa 40F2CF73 		movw	r3, #1999
 1030 02ae 9A42     		cmp	r2, r3
 1031 02b0 E9DD     		ble	.L91
 1032 02b2 00E0     		b	.L90
 1033              	.L96:
 1034              		.loc 1 487 0 is_stmt 1
 1035 02b4 00BF     		nop
 1036              	.L90:
 488:../Sources/drivers/mcg/mcg.c ****         }
 489:../Sources/drivers/mcg/mcg.c **** 
 490:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B;   // check CLKST is s
 1037              		.loc 1 490 0
 1038 02b6 4FF48043 		mov	r3, #16384
 1039 02ba C4F20603 		movt	r3, 16390
 1040 02be 9B79     		ldrb	r3, [r3, #6]
 1041 02c0 DBB2     		uxtb	r3, r3
 1042 02c2 03F00C03 		and	r3, r3, #12
 1043 02c6 4FEA9303 		lsr	r3, r3, #2
 1044 02ca 032B     		cmp	r3, #3
 1045 02cc 02D0     		beq	.L92
 1046              		.loc 1 490 0 is_stmt 0
 1047 02ce 4FF01B03 		mov	r3, #27
 1048 02d2 1EE0     		b	.L64
 1049              	.L92:
 491:../Sources/drivers/mcg/mcg.c **** 
 492:../Sources/drivers/mcg/mcg.c ****     // Now in PEE
 493:../Sources/drivers/mcg/mcg.c ****     // Use actual PLL settings to calculate PLL frequency
 494:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 1050              		.loc 1 494 0 is_stmt 1
 1051 02d4 4FF48043 		mov	r3, #16384
 1052 02d8 C4F20603 		movt	r3, 16390
 1053 02dc 1B79     		ldrb	r3, [r3, #4]
 1054 02de DBB2     		uxtb	r3, r3
 1055 02e0 03F01F03 		and	r3, r3, #31
 1056 02e4 DBB2     		uxtb	r3, r3
 1057 02e6 03F10103 		add	r3, r3, #1
 1058 02ea BB72     		strb	r3, [r7, #10]
 495:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 1059              		.loc 1 495 0
 1060 02ec 4FF48043 		mov	r3, #16384
 1061 02f0 C4F20603 		movt	r3, 16390
 1062 02f4 5B79     		ldrb	r3, [r3, #5]
 1063 02f6 DBB2     		uxtb	r3, r3
 1064 02f8 03F01F03 		and	r3, r3, #31
 1065 02fc DBB2     		uxtb	r3, r3
 1066 02fe 03F11803 		add	r3, r3, #24
 1067 0302 7B72     		strb	r3, [r7, #9]
 496:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 1068              		.loc 1 496 0
 1069 0304 BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 1070 0306 7A68     		ldr	r2, [r7, #4]
 1071 0308 92FBF3F3 		sdiv	r3, r2, r3
 1072 030c 7A7A     		ldrb	r2, [r7, #9]	@ zero_extendqisi2
 1073 030e 02FB03F3 		mul	r3, r2, r3
 1074              	.L64:
 497:../Sources/drivers/mcg/mcg.c **** }   // new_pll_freq
 1075              		.loc 1 497 0
 1076 0312 1846     		mov	r0, r3
 1077 0314 07F11C07 		add	r7, r7, #28
 1078 0318 BD46     		mov	sp, r7
 1079 031a 80BC     		pop	{r7}
 1080 031c 7047     		bx	lr
 1081              		.cfi_endproc
 1082              	.LFE1:
 1084 031e 00BF     		.section	.text.pee_pbe,"ax",%progbits
 1085              		.align	2
 1086              		.global	pee_pbe
 1087              		.thumb
 1088              		.thumb_func
 1090              	pee_pbe:
 1091              	.LFB2:
 498:../Sources/drivers/mcg/mcg.c **** 
 499:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
 500:../Sources/drivers/mcg/mcg.c **** 
 501:../Sources/drivers/mcg/mcg.c **** int pee_pbe
 502:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
 503:../Sources/drivers/mcg/mcg.c **** {
 1092              		.loc 1 503 0
 1093              		.cfi_startproc
 1094              		@ args = 0, pretend = 0, frame = 16
 1095              		@ frame_needed = 1, uses_anonymous_args = 0
 1096              		@ link register save eliminated.
 1097 0000 80B4     		push	{r7}
 1098              	.LCFI6:
 1099              		.cfi_def_cfa_offset 4
 1100              		.cfi_offset 7, -4
 1101 0002 85B0     		sub	sp, sp, #20
 1102              	.LCFI7:
 1103              		.cfi_def_cfa_offset 24
 1104 0004 00AF     		add	r7, sp, #0
 1105              	.LCFI8:
 1106              		.cfi_def_cfa_register 7
 1107 0006 7860     		str	r0, [r7, #4]
 504:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 505:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 506:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 507:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 508:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 509:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 510:../Sources/drivers/mcg/mcg.c ****     short   i;
 511:../Sources/drivers/mcg/mcg.c **** 
 512:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 513:../Sources/drivers/mcg/mcg.c **** 
 514:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 515:../Sources/drivers/mcg/mcg.c **** 
 516:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 517:../Sources/drivers/mcg/mcg.c **** 
 518:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 519:../Sources/drivers/mcg/mcg.c **** 
 520:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 521:../Sources/drivers/mcg/mcg.c **** 
 522:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 523:../Sources/drivers/mcg/mcg.c **** 
 524:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PEE mode
 525:../Sources/drivers/mcg/mcg.c **** 
 526:../Sources/drivers/mcg/mcg.c ****     if
 527:../Sources/drivers/mcg/mcg.c ****     (
 528:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3)    // check CLKS mux has selct
 1108              		.loc 1 528 0
 1109 0008 4FF48043 		mov	r3, #16384
 1110 000c C4F20603 		movt	r3, 16390
 1111 0010 9B79     		ldrb	r3, [r3, #6]
 1112 0012 DBB2     		uxtb	r3, r3
 1113 0014 03F00C03 		and	r3, r3, #12
 1114 0018 4FEA9303 		lsr	r3, r3, #2
 527:../Sources/drivers/mcg/mcg.c ****     (
 1115              		.loc 1 527 0
 1116 001c 032B     		cmp	r3, #3
 1117 001e 13D1     		bne	.L98
 529:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1118              		.loc 1 529 0
 1119 0020 4FF48043 		mov	r3, #16384
 1120 0024 C4F20603 		movt	r3, 16390
 1121 0028 9B79     		ldrb	r3, [r3, #6]
 1122 002a DBB2     		uxtb	r3, r3
 1123 002c 03F01003 		and	r3, r3, #16
 1124 0030 002B     		cmp	r3, #0
 1125 0032 09D1     		bne	.L98
 530:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_PLLST_MASK)
 1126              		.loc 1 530 0
 1127 0034 4FF48043 		mov	r3, #16384
 1128 0038 C4F20603 		movt	r3, 16390
 1129 003c 9B79     		ldrb	r3, [r3, #6]
 1130 003e DBB2     		uxtb	r3, r3
 1131 0040 03F02003 		and	r3, r3, #32
 528:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3)    // check CLKS mux has selct
 1132              		.loc 1 528 0
 1133 0044 002B     		cmp	r3, #0
 1134 0046 02D1     		bne	.L99
 1135              	.L98:
 531:../Sources/drivers/mcg/mcg.c ****          )
 532:../Sources/drivers/mcg/mcg.c ****     )               // check PLLS mux has selected PLL
 533:../Sources/drivers/mcg/mcg.c ****         {
 534:../Sources/drivers/mcg/mcg.c ****             return 0x8; // return error code
 1136              		.loc 1 534 0
 1137 0048 4FF00803 		mov	r3, #8
 1138 004c 39E0     		b	.L100
 1139              	.L99:
 535:../Sources/drivers/mcg/mcg.c ****         }
 536:../Sources/drivers/mcg/mcg.c **** 
 537:../Sources/drivers/mcg/mcg.c ****     // As we are running from the PLL by default the PLL and external clock settings are valid
 538:../Sources/drivers/mcg/mcg.c ****     // To move to PBE from PEE simply requires the switching of the CLKS mux to select the ext cloc
 539:../Sources/drivers/mcg/mcg.c ****     // As CLKS is already 0 the CLKS value can simply be OR'ed into the register
 540:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(2);   // switch CLKS mux to select external reference clock as MCG_OUT
 1140              		.loc 1 540 0
 1141 004e 4FF48043 		mov	r3, #16384
 1142 0052 C4F20603 		movt	r3, 16390
 1143 0056 4FF48042 		mov	r2, #16384
 1144 005a C4F20602 		movt	r2, 16390
 1145 005e 1278     		ldrb	r2, [r2, #0]
 1146 0060 D2B2     		uxtb	r2, r2
 1147 0062 62F07F02 		orn	r2, r2, #127
 1148 0066 D2B2     		uxtb	r2, r2
 1149 0068 1A70     		strb	r2, [r3, #0]
 541:../Sources/drivers/mcg/mcg.c **** 
 542:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
 543:../Sources/drivers/mcg/mcg.c **** 
 544:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1150              		.loc 1 544 0
 1151 006a 4FF00003 		mov	r3, #0
 1152 006e FB81     		strh	r3, [r7, #14]	@ movhi
 1153 0070 0FE0     		b	.L101
 1154              	.L104:
 545:../Sources/drivers/mcg/mcg.c ****         {
 546:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out ear
 1155              		.loc 1 546 0
 1156 0072 4FF48043 		mov	r3, #16384
 1157 0076 C4F20603 		movt	r3, 16390
 1158 007a 9B79     		ldrb	r3, [r3, #6]
 1159 007c DBB2     		uxtb	r3, r3
 1160 007e 03F00C03 		and	r3, r3, #12
 1161 0082 4FEA9303 		lsr	r3, r3, #2
 1162 0086 022B     		cmp	r3, #2
 1163 0088 0AD0     		beq	.L106
 1164              	.L102:
 544:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1165              		.loc 1 544 0
 1166 008a FB89     		ldrh	r3, [r7, #14]	@ movhi
 1167 008c 03F10103 		add	r3, r3, #1
 1168 0090 FB81     		strh	r3, [r7, #14]	@ movhi
 1169              	.L101:
 544:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1170              		.loc 1 544 0 is_stmt 0
 1171 0092 B7F90E20 		ldrsh	r2, [r7, #14]
 1172 0096 40F2CF73 		movw	r3, #1999
 1173 009a 9A42     		cmp	r2, r3
 1174 009c E9DD     		ble	.L104
 1175 009e 00E0     		b	.L103
 1176              	.L106:
 1177              		.loc 1 546 0 is_stmt 1
 1178 00a0 00BF     		nop
 1179              	.L103:
 547:../Sources/drivers/mcg/mcg.c ****         }
 548:../Sources/drivers/mcg/mcg.c **** 
 549:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 1180              		.loc 1 549 0
 1181 00a2 4FF48043 		mov	r3, #16384
 1182 00a6 C4F20603 		movt	r3, 16390
 1183 00aa 9B79     		ldrb	r3, [r3, #6]
 1184 00ac DBB2     		uxtb	r3, r3
 1185 00ae 03F00C03 		and	r3, r3, #12
 1186 00b2 4FEA9303 		lsr	r3, r3, #2
 1187 00b6 022B     		cmp	r3, #2
 1188 00b8 02D0     		beq	.L105
 1189              		.loc 1 549 0 is_stmt 0
 1190 00ba 4FF01A03 		mov	r3, #26
 1191 00be 00E0     		b	.L100
 1192              	.L105:
 550:../Sources/drivers/mcg/mcg.c **** 
 551:../Sources/drivers/mcg/mcg.c ****     // Now in PBE mode
 552:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 1193              		.loc 1 552 0 is_stmt 1
 1194 00c0 7B68     		ldr	r3, [r7, #4]
 1195              	.L100:
 553:../Sources/drivers/mcg/mcg.c **** }                       // pee_pbe
 1196              		.loc 1 553 0
 1197 00c2 1846     		mov	r0, r3
 1198 00c4 07F11407 		add	r7, r7, #20
 1199 00c8 BD46     		mov	sp, r7
 1200 00ca 80BC     		pop	{r7}
 1201 00cc 7047     		bx	lr
 1202              		.cfi_endproc
 1203              	.LFE2:
 1205 00ce 00BF     		.section	.text.pbe_pee,"ax",%progbits
 1206              		.align	2
 1207              		.global	pbe_pee
 1208              		.thumb
 1209              		.thumb_func
 1211              	pbe_pee:
 1212              	.LFB3:
 554:../Sources/drivers/mcg/mcg.c **** 
 555:../Sources/drivers/mcg/mcg.c **** /* */
 556:../Sources/drivers/mcg/mcg.c **** 
 557:../Sources/drivers/mcg/mcg.c **** int pbe_pee
 558:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
 559:../Sources/drivers/mcg/mcg.c **** {
 1213              		.loc 1 559 0
 1214              		.cfi_startproc
 1215              		@ args = 0, pretend = 0, frame = 16
 1216              		@ frame_needed = 1, uses_anonymous_args = 0
 1217              		@ link register save eliminated.
 1218 0000 80B4     		push	{r7}
 1219              	.LCFI9:
 1220              		.cfi_def_cfa_offset 4
 1221              		.cfi_offset 7, -4
 1222 0002 85B0     		sub	sp, sp, #20
 1223              	.LCFI10:
 1224              		.cfi_def_cfa_offset 24
 1225 0004 00AF     		add	r7, sp, #0
 1226              	.LCFI11:
 1227              		.cfi_def_cfa_register 7
 1228 0006 7860     		str	r0, [r7, #4]
 560:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 561:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 562:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 563:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 564:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 565:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 566:../Sources/drivers/mcg/mcg.c ****     unsigned char   prdiv, vdiv;
 567:../Sources/drivers/mcg/mcg.c ****     short           i;
 568:../Sources/drivers/mcg/mcg.c **** 
 569:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 570:../Sources/drivers/mcg/mcg.c **** 
 571:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 572:../Sources/drivers/mcg/mcg.c **** 
 573:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 574:../Sources/drivers/mcg/mcg.c **** 
 575:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 576:../Sources/drivers/mcg/mcg.c **** 
 577:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 578:../Sources/drivers/mcg/mcg.c **** 
 579:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 580:../Sources/drivers/mcg/mcg.c **** 
 581:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PBE mode
 582:../Sources/drivers/mcg/mcg.c **** 
 583:../Sources/drivers/mcg/mcg.c ****     if
 584:../Sources/drivers/mcg/mcg.c ****     (
 585:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1229              		.loc 1 585 0
 1230 0008 4FF48043 		mov	r3, #16384
 1231 000c C4F20603 		movt	r3, 16390
 1232 0010 9B79     		ldrb	r3, [r3, #6]
 1233 0012 DBB2     		uxtb	r3, r3
 1234 0014 03F00C03 		and	r3, r3, #12
 1235 0018 4FEA9303 		lsr	r3, r3, #2
 584:../Sources/drivers/mcg/mcg.c ****     (
 1236              		.loc 1 584 0
 1237 001c 022B     		cmp	r3, #2
 1238 001e 1DD1     		bne	.L108
 586:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1239              		.loc 1 586 0
 1240 0020 4FF48043 		mov	r3, #16384
 1241 0024 C4F20603 		movt	r3, 16390
 1242 0028 9B79     		ldrb	r3, [r3, #6]
 1243 002a DBB2     		uxtb	r3, r3
 1244 002c 03F01003 		and	r3, r3, #16
 1245 0030 002B     		cmp	r3, #0
 1246 0032 13D1     		bne	.L108
 587:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 1247              		.loc 1 587 0
 1248 0034 4FF48043 		mov	r3, #16384
 1249 0038 C4F20603 		movt	r3, 16390
 1250 003c 9B79     		ldrb	r3, [r3, #6]
 1251 003e DBB2     		uxtb	r3, r3
 1252 0040 03F02003 		and	r3, r3, #32
 1253 0044 002B     		cmp	r3, #0
 1254 0046 09D0     		beq	.L108
 588:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 1255              		.loc 1 588 0
 1256 0048 4FF48043 		mov	r3, #16384
 1257 004c C4F20603 		movt	r3, 16390
 1258 0050 5B78     		ldrb	r3, [r3, #1]
 1259 0052 DBB2     		uxtb	r3, r3
 1260 0054 03F00203 		and	r3, r3, #2
 585:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1261              		.loc 1 585 0
 1262 0058 002B     		cmp	r3, #0
 1263 005a 02D0     		beq	.L109
 1264              	.L108:
 589:../Sources/drivers/mcg/mcg.c ****          )
 590:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
 591:../Sources/drivers/mcg/mcg.c ****         {
 592:../Sources/drivers/mcg/mcg.c ****             return 0x7; // return error code
 1265              		.loc 1 592 0
 1266 005c 4FF00703 		mov	r3, #7
 1267 0060 7EE0     		b	.L110
 1268              	.L109:
 593:../Sources/drivers/mcg/mcg.c ****         }
 594:../Sources/drivers/mcg/mcg.c **** 
 595:../Sources/drivers/mcg/mcg.c ****     // As the PLL settings have already been checked when PBE mode was enterred they are not checke
 596:../Sources/drivers/mcg/mcg.c ****     // Check the PLL state before transitioning to PEE mode
 597:../Sources/drivers/mcg/mcg.c ****     // Check LOCK bit is set before transitioning MCG to PLL output (already checked in fbe_pbe but
 598:../Sources/drivers/mcg/mcg.c ****     // to re-check before switch to use PLL)
 599:../Sources/drivers/mcg/mcg.c **** 
 600:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1269              		.loc 1 600 0
 1270 0062 4FF00003 		mov	r3, #0
 1271 0066 FB81     		strh	r3, [r7, #14]	@ movhi
 1272 0068 0DE0     		b	.L111
 1273              	.L114:
 601:../Sources/drivers/mcg/mcg.c ****         {
 602:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop 
 1274              		.loc 1 602 0
 1275 006a 4FF48043 		mov	r3, #16384
 1276 006e C4F20603 		movt	r3, 16390
 1277 0072 9B79     		ldrb	r3, [r3, #6]
 1278 0074 DBB2     		uxtb	r3, r3
 1279 0076 03F04003 		and	r3, r3, #64
 1280 007a 002B     		cmp	r3, #0
 1281 007c 0AD1     		bne	.L121
 1282              	.L112:
 600:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1283              		.loc 1 600 0
 1284 007e FB89     		ldrh	r3, [r7, #14]	@ movhi
 1285 0080 03F10103 		add	r3, r3, #1
 1286 0084 FB81     		strh	r3, [r7, #14]	@ movhi
 1287              	.L111:
 600:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1288              		.loc 1 600 0 is_stmt 0
 1289 0086 B7F90E20 		ldrsh	r2, [r7, #14]
 1290 008a 40F2CF73 		movw	r3, #1999
 1291 008e 9A42     		cmp	r2, r3
 1292 0090 EBDD     		ble	.L114
 1293 0092 00E0     		b	.L113
 1294              	.L121:
 1295              		.loc 1 602 0 is_stmt 1
 1296 0094 00BF     		nop
 1297              	.L113:
 603:../Sources/drivers/mcg/mcg.c ****         }
 604:../Sources/drivers/mcg/mcg.c **** 
 605:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 1298              		.loc 1 605 0
 1299 0096 4FF48043 		mov	r3, #16384
 1300 009a C4F20603 		movt	r3, 16390
 1301 009e 9B79     		ldrb	r3, [r3, #6]
 1302 00a0 DBB2     		uxtb	r3, r3
 1303 00a2 03F04003 		and	r3, r3, #64
 1304 00a6 002B     		cmp	r3, #0
 1305 00a8 02D1     		bne	.L115
 1306              		.loc 1 605 0 is_stmt 0
 1307 00aa 4FF04403 		mov	r3, #68
 1308 00ae 57E0     		b	.L110
 1309              	.L115:
 606:../Sources/drivers/mcg/mcg.c **** 
 607:../Sources/drivers/mcg/mcg.c ****     // Use actual PLL settings to calculate PLL frequency
 608:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 1310              		.loc 1 608 0 is_stmt 1
 1311 00b0 4FF48043 		mov	r3, #16384
 1312 00b4 C4F20603 		movt	r3, 16390
 1313 00b8 1B79     		ldrb	r3, [r3, #4]
 1314 00ba DBB2     		uxtb	r3, r3
 1315 00bc 03F01F03 		and	r3, r3, #31
 1316 00c0 DBB2     		uxtb	r3, r3
 1317 00c2 03F10103 		add	r3, r3, #1
 1318 00c6 7B73     		strb	r3, [r7, #13]
 609:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 1319              		.loc 1 609 0
 1320 00c8 4FF48043 		mov	r3, #16384
 1321 00cc C4F20603 		movt	r3, 16390
 1322 00d0 5B79     		ldrb	r3, [r3, #5]
 1323 00d2 DBB2     		uxtb	r3, r3
 1324 00d4 03F01F03 		and	r3, r3, #31
 1325 00d8 DBB2     		uxtb	r3, r3
 1326 00da 03F11803 		add	r3, r3, #24
 1327 00de 3B73     		strb	r3, [r7, #12]
 610:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 1328              		.loc 1 610 0
 1329 00e0 4FF48043 		mov	r3, #16384
 1330 00e4 C4F20603 		movt	r3, 16390
 1331 00e8 4FF48042 		mov	r2, #16384
 1332 00ec C4F20602 		movt	r2, 16390
 1333 00f0 1278     		ldrb	r2, [r2, #0]
 1334 00f2 D2B2     		uxtb	r2, r2
 1335 00f4 02F03F02 		and	r2, r2, #63
 1336 00f8 D2B2     		uxtb	r2, r2
 1337 00fa 1A70     		strb	r2, [r3, #0]
 611:../Sources/drivers/mcg/mcg.c **** 
 612:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
 613:../Sources/drivers/mcg/mcg.c **** 
 614:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1338              		.loc 1 614 0
 1339 00fc 4FF00003 		mov	r3, #0
 1340 0100 FB81     		strh	r3, [r7, #14]	@ movhi
 1341 0102 0FE0     		b	.L116
 1342              	.L119:
 615:../Sources/drivers/mcg/mcg.c ****         {
 616:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break;     // jump out ear
 1343              		.loc 1 616 0
 1344 0104 4FF48043 		mov	r3, #16384
 1345 0108 C4F20603 		movt	r3, 16390
 1346 010c 9B79     		ldrb	r3, [r3, #6]
 1347 010e DBB2     		uxtb	r3, r3
 1348 0110 03F00C03 		and	r3, r3, #12
 1349 0114 4FEA9303 		lsr	r3, r3, #2
 1350 0118 032B     		cmp	r3, #3
 1351 011a 0AD0     		beq	.L122
 1352              	.L117:
 614:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1353              		.loc 1 614 0
 1354 011c FB89     		ldrh	r3, [r7, #14]	@ movhi
 1355 011e 03F10103 		add	r3, r3, #1
 1356 0122 FB81     		strh	r3, [r7, #14]	@ movhi
 1357              	.L116:
 614:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1358              		.loc 1 614 0 is_stmt 0
 1359 0124 B7F90E20 		ldrsh	r2, [r7, #14]
 1360 0128 40F2CF73 		movw	r3, #1999
 1361 012c 9A42     		cmp	r2, r3
 1362 012e E9DD     		ble	.L119
 1363 0130 00E0     		b	.L118
 1364              	.L122:
 1365              		.loc 1 616 0 is_stmt 1
 1366 0132 00BF     		nop
 1367              	.L118:
 617:../Sources/drivers/mcg/mcg.c ****         }
 618:../Sources/drivers/mcg/mcg.c **** 
 619:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B;   // check CLKST is s
 1368              		.loc 1 619 0
 1369 0134 4FF48043 		mov	r3, #16384
 1370 0138 C4F20603 		movt	r3, 16390
 1371 013c 9B79     		ldrb	r3, [r3, #6]
 1372 013e DBB2     		uxtb	r3, r3
 1373 0140 03F00C03 		and	r3, r3, #12
 1374 0144 4FEA9303 		lsr	r3, r3, #2
 1375 0148 032B     		cmp	r3, #3
 1376 014a 02D0     		beq	.L120
 1377              		.loc 1 619 0 is_stmt 0
 1378 014c 4FF01B03 		mov	r3, #27
 1379 0150 06E0     		b	.L110
 1380              	.L120:
 620:../Sources/drivers/mcg/mcg.c **** 
 621:../Sources/drivers/mcg/mcg.c ****     // Now in PEE
 622:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 1381              		.loc 1 622 0 is_stmt 1
 1382 0152 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 1383 0154 7A68     		ldr	r2, [r7, #4]
 1384 0156 92FBF3F3 		sdiv	r3, r2, r3
 1385 015a 3A7B     		ldrb	r2, [r7, #12]	@ zero_extendqisi2
 1386 015c 02FB03F3 		mul	r3, r2, r3
 1387              	.L110:
 623:../Sources/drivers/mcg/mcg.c **** }   // pbe_pee
 1388              		.loc 1 623 0
 1389 0160 1846     		mov	r0, r3
 1390 0162 07F11407 		add	r7, r7, #20
 1391 0166 BD46     		mov	sp, r7
 1392 0168 80BC     		pop	{r7}
 1393 016a 7047     		bx	lr
 1394              		.cfi_endproc
 1395              	.LFE3:
 1397              		.section	.text.pbe_fbe,"ax",%progbits
 1398              		.align	2
 1399              		.global	pbe_fbe
 1400              		.thumb
 1401              		.thumb_func
 1403              	pbe_fbe:
 1404              	.LFB4:
 624:../Sources/drivers/mcg/mcg.c **** 
 625:../Sources/drivers/mcg/mcg.c **** /* */
 626:../Sources/drivers/mcg/mcg.c **** 
 627:../Sources/drivers/mcg/mcg.c **** int pbe_fbe
 628:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
 629:../Sources/drivers/mcg/mcg.c **** {
 1405              		.loc 1 629 0
 1406              		.cfi_startproc
 1407              		@ args = 0, pretend = 0, frame = 16
 1408              		@ frame_needed = 1, uses_anonymous_args = 0
 1409              		@ link register save eliminated.
 1410 0000 80B4     		push	{r7}
 1411              	.LCFI12:
 1412              		.cfi_def_cfa_offset 4
 1413              		.cfi_offset 7, -4
 1414 0002 85B0     		sub	sp, sp, #20
 1415              	.LCFI13:
 1416              		.cfi_def_cfa_offset 24
 1417 0004 00AF     		add	r7, sp, #0
 1418              	.LCFI14:
 1419              		.cfi_def_cfa_register 7
 1420 0006 7860     		str	r0, [r7, #4]
 630:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 631:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 632:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 633:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 634:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 635:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 636:../Sources/drivers/mcg/mcg.c ****     short   i;
 637:../Sources/drivers/mcg/mcg.c **** 
 638:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 639:../Sources/drivers/mcg/mcg.c **** 
 640:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 641:../Sources/drivers/mcg/mcg.c **** 
 642:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 643:../Sources/drivers/mcg/mcg.c **** 
 644:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 645:../Sources/drivers/mcg/mcg.c **** 
 646:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 647:../Sources/drivers/mcg/mcg.c **** 
 648:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 649:../Sources/drivers/mcg/mcg.c **** 
 650:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PBE mode
 651:../Sources/drivers/mcg/mcg.c **** 
 652:../Sources/drivers/mcg/mcg.c ****     if
 653:../Sources/drivers/mcg/mcg.c ****     (
 654:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1421              		.loc 1 654 0
 1422 0008 4FF48043 		mov	r3, #16384
 1423 000c C4F20603 		movt	r3, 16390
 1424 0010 9B79     		ldrb	r3, [r3, #6]
 1425 0012 DBB2     		uxtb	r3, r3
 1426 0014 03F00C03 		and	r3, r3, #12
 1427 0018 4FEA9303 		lsr	r3, r3, #2
 653:../Sources/drivers/mcg/mcg.c ****     (
 1428              		.loc 1 653 0
 1429 001c 022B     		cmp	r3, #2
 1430 001e 1DD1     		bne	.L124
 655:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1431              		.loc 1 655 0
 1432 0020 4FF48043 		mov	r3, #16384
 1433 0024 C4F20603 		movt	r3, 16390
 1434 0028 9B79     		ldrb	r3, [r3, #6]
 1435 002a DBB2     		uxtb	r3, r3
 1436 002c 03F01003 		and	r3, r3, #16
 1437 0030 002B     		cmp	r3, #0
 1438 0032 13D1     		bne	.L124
 656:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 1439              		.loc 1 656 0
 1440 0034 4FF48043 		mov	r3, #16384
 1441 0038 C4F20603 		movt	r3, 16390
 1442 003c 9B79     		ldrb	r3, [r3, #6]
 1443 003e DBB2     		uxtb	r3, r3
 1444 0040 03F02003 		and	r3, r3, #32
 1445 0044 002B     		cmp	r3, #0
 1446 0046 09D0     		beq	.L124
 657:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 1447              		.loc 1 657 0
 1448 0048 4FF48043 		mov	r3, #16384
 1449 004c C4F20603 		movt	r3, 16390
 1450 0050 5B78     		ldrb	r3, [r3, #1]
 1451 0052 DBB2     		uxtb	r3, r3
 1452 0054 03F00203 		and	r3, r3, #2
 654:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1453              		.loc 1 654 0
 1454 0058 002B     		cmp	r3, #0
 1455 005a 02D0     		beq	.L125
 1456              	.L124:
 658:../Sources/drivers/mcg/mcg.c ****          )
 659:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
 660:../Sources/drivers/mcg/mcg.c ****         {
 661:../Sources/drivers/mcg/mcg.c ****             return 0x7; // return error code
 1457              		.loc 1 661 0
 1458 005c 4FF00703 		mov	r3, #7
 1459 0060 35E0     		b	.L126
 1460              	.L125:
 662:../Sources/drivers/mcg/mcg.c ****         }
 663:../Sources/drivers/mcg/mcg.c **** 
 664:../Sources/drivers/mcg/mcg.c ****     // As we are running from the ext clock, by default the external clock settings are valid
 665:../Sources/drivers/mcg/mcg.c ****     // To move to FBE from PBE simply requires the switching of the PLLS mux to disable the PLL
 666:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_PLLS_MASK;                // clear PLLS to disable PLL, still clocked from ex
 1461              		.loc 1 666 0
 1462 0062 4FF48043 		mov	r3, #16384
 1463 0066 C4F20603 		movt	r3, 16390
 1464 006a 4FF48042 		mov	r2, #16384
 1465 006e C4F20602 		movt	r2, 16390
 1466 0072 5279     		ldrb	r2, [r2, #5]
 1467 0074 D2B2     		uxtb	r2, r2
 1468 0076 22F04002 		bic	r2, r2, #64
 1469 007a D2B2     		uxtb	r2, r2
 1470 007c 5A71     		strb	r2, [r3, #5]
 667:../Sources/drivers/mcg/mcg.c **** 
 668:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to set
 669:../Sources/drivers/mcg/mcg.c **** 
 670:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1471              		.loc 1 670 0
 1472 007e 4FF00003 		mov	r3, #0
 1473 0082 FB81     		strh	r3, [r7, #14]	@ movhi
 1474 0084 0DE0     		b	.L127
 1475              	.L130:
 671:../Sources/drivers/mcg/mcg.c ****         {
 672:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_PLLST_MASK)) break;  // jump out early if PLLST clears before loop f
 1476              		.loc 1 672 0
 1477 0086 4FF48043 		mov	r3, #16384
 1478 008a C4F20603 		movt	r3, 16390
 1479 008e 9B79     		ldrb	r3, [r3, #6]
 1480 0090 DBB2     		uxtb	r3, r3
 1481 0092 03F02003 		and	r3, r3, #32
 1482 0096 002B     		cmp	r3, #0
 1483 0098 0AD0     		beq	.L132
 1484              	.L128:
 670:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1485              		.loc 1 670 0
 1486 009a FB89     		ldrh	r3, [r7, #14]	@ movhi
 1487 009c 03F10103 		add	r3, r3, #1
 1488 00a0 FB81     		strh	r3, [r7, #14]	@ movhi
 1489              	.L127:
 670:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1490              		.loc 1 670 0 is_stmt 0
 1491 00a2 B7F90E20 		ldrsh	r2, [r7, #14]
 1492 00a6 40F2CF73 		movw	r3, #1999
 1493 00aa 9A42     		cmp	r2, r3
 1494 00ac EBDD     		ble	.L130
 1495 00ae 00E0     		b	.L129
 1496              	.L132:
 1497              		.loc 1 672 0 is_stmt 1
 1498 00b0 00BF     		nop
 1499              	.L129:
 673:../Sources/drivers/mcg/mcg.c ****         }
 674:../Sources/drivers/mcg/mcg.c **** 
 675:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_PLLST_MASK) return 0x15;   // check bit is really clear and return with error 
 1500              		.loc 1 675 0
 1501 00b2 4FF48043 		mov	r3, #16384
 1502 00b6 C4F20603 		movt	r3, 16390
 1503 00ba 9B79     		ldrb	r3, [r3, #6]
 1504 00bc DBB2     		uxtb	r3, r3
 1505 00be 03F02003 		and	r3, r3, #32
 1506 00c2 002B     		cmp	r3, #0
 1507 00c4 02D0     		beq	.L131
 1508              		.loc 1 675 0 is_stmt 0
 1509 00c6 4FF01503 		mov	r3, #21
 1510 00ca 00E0     		b	.L126
 1511              	.L131:
 676:../Sources/drivers/mcg/mcg.c **** 
 677:../Sources/drivers/mcg/mcg.c ****     // Now in FBE mode
 678:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 1512              		.loc 1 678 0 is_stmt 1
 1513 00cc 7B68     		ldr	r3, [r7, #4]
 1514              	.L126:
 679:../Sources/drivers/mcg/mcg.c **** }                       // pbe_fbe
 1515              		.loc 1 679 0
 1516 00ce 1846     		mov	r0, r3
 1517 00d0 07F11407 		add	r7, r7, #20
 1518 00d4 BD46     		mov	sp, r7
 1519 00d6 80BC     		pop	{r7}
 1520 00d8 7047     		bx	lr
 1521              		.cfi_endproc
 1522              	.LFE4:
 1524 00da 00BF     		.section	.text.fbe_pbe,"ax",%progbits
 1525              		.align	2
 1526              		.global	fbe_pbe
 1527              		.thumb
 1528              		.thumb_func
 1530              	fbe_pbe:
 1531              	.LFB5:
 680:../Sources/drivers/mcg/mcg.c **** 
 681:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
 682:../Sources/drivers/mcg/mcg.c **** 
 683:../Sources/drivers/mcg/mcg.c **** /* Functon name : fbe_pbe
 684:../Sources/drivers/mcg/mcg.c ****  *
 685:../Sources/drivers/mcg/mcg.c ****  * Mode transition: FBE to PBE mode
 686:../Sources/drivers/mcg/mcg.c ****  *
 687:../Sources/drivers/mcg/mcg.c ****  * This function transitions the MCG from FBE mode to PBE mode.
 688:../Sources/drivers/mcg/mcg.c ****  * This function presently only supports OSC0 and PLL0. Support for OSC1 and PLL1 will be added soo
 689:../Sources/drivers/mcg/mcg.c ****  * The function requires the desired OSC and PLL be passed in to it for compatibility with the
 690:../Sources/drivers/mcg/mcg.c ****  * future support of OSC/PLL selection
 691:../Sources/drivers/mcg/mcg.c ****  *
 692:../Sources/drivers/mcg/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
 693:../Sources/drivers/mcg/mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 694:../Sources/drivers/mcg/mcg.c ****  *                           PLL reference clock frequency
 695:../Sources/drivers/mcg/mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 696:../Sources/drivers/mcg/mcg.c ****  *
 697:../Sources/drivers/mcg/mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
 698:../Sources/drivers/mcg/mcg.c ****  */
 699:../Sources/drivers/mcg/mcg.c **** 
 700:../Sources/drivers/mcg/mcg.c **** int fbe_pbe
 701:../Sources/drivers/mcg/mcg.c **** (
 702:../Sources/drivers/mcg/mcg.c ****     int         crystal_val,
 703:../Sources/drivers/mcg/mcg.c ****     signed char prdiv_val,
 704:../Sources/drivers/mcg/mcg.c ****     signed char vdiv_val
 705:../Sources/drivers/mcg/mcg.c **** )
 706:../Sources/drivers/mcg/mcg.c **** {
 1532              		.loc 1 706 0
 1533              		.cfi_startproc
 1534              		@ args = 0, pretend = 0, frame = 24
 1535              		@ frame_needed = 1, uses_anonymous_args = 0
 1536              		@ link register save eliminated.
 1537 0000 80B4     		push	{r7}
 1538              	.LCFI15:
 1539              		.cfi_def_cfa_offset 4
 1540              		.cfi_offset 7, -4
 1541 0002 87B0     		sub	sp, sp, #28
 1542              	.LCFI16:
 1543              		.cfi_def_cfa_offset 32
 1544 0004 00AF     		add	r7, sp, #0
 1545              	.LCFI17:
 1546              		.cfi_def_cfa_register 7
 1547 0006 7860     		str	r0, [r7, #4]
 1548 0008 1346     		mov	r3, r2
 1549 000a 0A46     		mov	r2, r1
 1550 000c FA70     		strb	r2, [r7, #3]
 1551 000e BB70     		strb	r3, [r7, #2]
 707:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 708:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 709:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 710:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 711:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 712:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 713:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
 714:../Sources/drivers/mcg/mcg.c ****     short           i;
 715:../Sources/drivers/mcg/mcg.c ****     int             pll_freq;
 716:../Sources/drivers/mcg/mcg.c **** 
 717:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 718:../Sources/drivers/mcg/mcg.c **** 
 719:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 720:../Sources/drivers/mcg/mcg.c **** 
 721:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 722:../Sources/drivers/mcg/mcg.c **** 
 723:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 724:../Sources/drivers/mcg/mcg.c **** 
 725:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 726:../Sources/drivers/mcg/mcg.c **** 
 727:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 728:../Sources/drivers/mcg/mcg.c **** 
 729:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
 730:../Sources/drivers/mcg/mcg.c **** 
 731:../Sources/drivers/mcg/mcg.c ****     if
 732:../Sources/drivers/mcg/mcg.c ****     (
 733:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1552              		.loc 1 733 0
 1553 0010 4FF48043 		mov	r3, #16384
 1554 0014 C4F20603 		movt	r3, 16390
 1555 0018 9B79     		ldrb	r3, [r3, #6]
 1556 001a DBB2     		uxtb	r3, r3
 1557 001c 03F00C03 		and	r3, r3, #12
 1558 0020 4FEA9303 		lsr	r3, r3, #2
 732:../Sources/drivers/mcg/mcg.c ****     (
 1559              		.loc 1 732 0
 1560 0024 022B     		cmp	r3, #2
 1561 0026 1DD1     		bne	.L134
 734:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1562              		.loc 1 734 0
 1563 0028 4FF48043 		mov	r3, #16384
 1564 002c C4F20603 		movt	r3, 16390
 1565 0030 9B79     		ldrb	r3, [r3, #6]
 1566 0032 DBB2     		uxtb	r3, r3
 1567 0034 03F01003 		and	r3, r3, #16
 1568 0038 002B     		cmp	r3, #0
 1569 003a 13D1     		bne	.L134
 735:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 1570              		.loc 1 735 0
 1571 003c 4FF48043 		mov	r3, #16384
 1572 0040 C4F20603 		movt	r3, 16390
 1573 0044 9B79     		ldrb	r3, [r3, #6]
 1574 0046 DBB2     		uxtb	r3, r3
 1575 0048 03F02003 		and	r3, r3, #32
 1576 004c 002B     		cmp	r3, #0
 1577 004e 09D1     		bne	.L134
 736:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 1578              		.loc 1 736 0
 1579 0050 4FF48043 		mov	r3, #16384
 1580 0054 C4F20603 		movt	r3, 16390
 1581 0058 5B78     		ldrb	r3, [r3, #1]
 1582 005a DBB2     		uxtb	r3, r3
 1583 005c 03F00203 		and	r3, r3, #2
 733:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1584              		.loc 1 733 0
 1585 0060 002B     		cmp	r3, #0
 1586 0062 02D0     		beq	.L135
 1587              	.L134:
 737:../Sources/drivers/mcg/mcg.c ****          )
 738:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
 739:../Sources/drivers/mcg/mcg.c ****         {
 740:../Sources/drivers/mcg/mcg.c ****             return 0x4; // return error code
 1588              		.loc 1 740 0
 1589 0064 4FF00403 		mov	r3, #4
 1590 0068 CFE0     		b	.L136
 1591              	.L135:
 741:../Sources/drivers/mcg/mcg.c ****         }
 742:../Sources/drivers/mcg/mcg.c **** 
 743:../Sources/drivers/mcg/mcg.c ****     // As the external frequency has already been checked when FBE mode was enterred it is not chec
 744:../Sources/drivers/mcg/mcg.c ****     // Check PLL divider settings are within spec.
 745:../Sources/drivers/mcg/mcg.c **** 
 746:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 1592              		.loc 1 746 0
 1593 006a 97F90330 		ldrsb	r3, [r7, #3]
 1594 006e 002B     		cmp	r3, #0
 1595 0070 03DD     		ble	.L137
 1596              		.loc 1 746 0 is_stmt 0
 1597 0072 97F90330 		ldrsb	r3, [r7, #3]
 1598 0076 192B     		cmp	r3, #25
 1599 0078 02DD     		ble	.L138
 1600              	.L137:
 747:../Sources/drivers/mcg/mcg.c ****         {
 748:../Sources/drivers/mcg/mcg.c ****             return 0x41;
 1601              		.loc 1 748 0 is_stmt 1
 1602 007a 4FF04103 		mov	r3, #65
 1603 007e C4E0     		b	.L136
 1604              	.L138:
 749:../Sources/drivers/mcg/mcg.c ****         }
 750:../Sources/drivers/mcg/mcg.c **** 
 751:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 1605              		.loc 1 751 0
 1606 0080 97F90230 		ldrsb	r3, [r7, #2]
 1607 0084 172B     		cmp	r3, #23
 1608 0086 03DD     		ble	.L139
 1609              		.loc 1 751 0 is_stmt 0
 1610 0088 97F90230 		ldrsb	r3, [r7, #2]
 1611 008c 322B     		cmp	r3, #50
 1612 008e 02DD     		ble	.L140
 1613              	.L139:
 752:../Sources/drivers/mcg/mcg.c ****         {
 753:../Sources/drivers/mcg/mcg.c ****             return 0x42;
 1614              		.loc 1 753 0 is_stmt 1
 1615 0090 4FF04203 		mov	r3, #66
 1616 0094 B9E0     		b	.L136
 1617              	.L140:
 754:../Sources/drivers/mcg/mcg.c ****         }
 755:../Sources/drivers/mcg/mcg.c **** 
 756:../Sources/drivers/mcg/mcg.c ****     // Check PLL reference clock frequency is within spec.
 757:../Sources/drivers/mcg/mcg.c **** 
 758:../Sources/drivers/mcg/mcg.c ****     if(((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000))
 1618              		.loc 1 758 0
 1619 0096 97F90330 		ldrsb	r3, [r7, #3]
 1620 009a 7A68     		ldr	r2, [r7, #4]
 1621 009c 92FBF3F2 		sdiv	r2, r2, r3
 1622 00a0 48F27F43 		movw	r3, #33919
 1623 00a4 C0F21E03 		movt	r3, 30
 1624 00a8 9A42     		cmp	r2, r3
 1625 00aa 0ADD     		ble	.L141
 1626              		.loc 1 758 0 is_stmt 0
 1627 00ac 97F90330 		ldrsb	r3, [r7, #3]
 1628 00b0 7A68     		ldr	r2, [r7, #4]
 1629 00b2 92FBF3F2 		sdiv	r2, r2, r3
 1630 00b6 4FF41063 		mov	r3, #2304
 1631 00ba C0F23D03 		movt	r3, 61
 1632 00be 9A42     		cmp	r2, r3
 1633 00c0 02DD     		ble	.L142
 1634              	.L141:
 759:../Sources/drivers/mcg/mcg.c ****         {
 760:../Sources/drivers/mcg/mcg.c ****             return 0x43;
 1635              		.loc 1 760 0 is_stmt 1
 1636 00c2 4FF04303 		mov	r3, #67
 1637 00c6 A0E0     		b	.L136
 1638              	.L142:
 761:../Sources/drivers/mcg/mcg.c ****         }
 762:../Sources/drivers/mcg/mcg.c **** 
 763:../Sources/drivers/mcg/mcg.c ****     // Check PLL output frequency is within spec.
 764:../Sources/drivers/mcg/mcg.c ****     pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 1639              		.loc 1 764 0
 1640 00c8 97F90330 		ldrsb	r3, [r7, #3]
 1641 00cc 7A68     		ldr	r2, [r7, #4]
 1642 00ce 92FBF3F3 		sdiv	r3, r2, r3
 1643 00d2 97F90220 		ldrsb	r2, [r7, #2]
 1644 00d6 02FB03F3 		mul	r3, r2, r3
 1645 00da 3B61     		str	r3, [r7, #16]
 765:../Sources/drivers/mcg/mcg.c **** 
 766:../Sources/drivers/mcg/mcg.c ****     if((pll_freq < 48000000) || (pll_freq > 100000000))
 1646              		.loc 1 766 0
 1647 00dc 3A69     		ldr	r2, [r7, #16]
 1648 00de 46F6FF33 		movw	r3, #27647
 1649 00e2 C0F2DC23 		movt	r3, 732
 1650 00e6 9A42     		cmp	r2, r3
 1651 00e8 06DD     		ble	.L143
 1652              		.loc 1 766 0 is_stmt 0
 1653 00ea 3A69     		ldr	r2, [r7, #16]
 1654 00ec 4FF46143 		mov	r3, #57600
 1655 00f0 C0F2F553 		movt	r3, 1525
 1656 00f4 9A42     		cmp	r2, r3
 1657 00f6 02DD     		ble	.L144
 1658              	.L143:
 767:../Sources/drivers/mcg/mcg.c ****         {
 768:../Sources/drivers/mcg/mcg.c ****             return 0x45;
 1659              		.loc 1 768 0 is_stmt 1
 1660 00f8 4FF04503 		mov	r3, #69
 1661 00fc 85E0     		b	.L136
 1662              	.L144:
 769:../Sources/drivers/mcg/mcg.c ****         }
 770:../Sources/drivers/mcg/mcg.c **** 
 771:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C5
 772:../Sources/drivers/mcg/mcg.c ****     // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user 
 773:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 1663              		.loc 1 773 0
 1664 00fe 4FF48043 		mov	r3, #16384
 1665 0102 C4F20603 		movt	r3, 16390
 1666 0106 1B79     		ldrb	r3, [r3, #4]
 1667 0108 FB73     		strb	r3, [r7, #15]
 774:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 1668              		.loc 1 774 0
 1669 010a FB7B     		ldrb	r3, [r7, #15]
 1670 010c 23F01F03 		bic	r3, r3, #31
 1671 0110 FB73     		strb	r3, [r7, #15]
 775:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 1672              		.loc 1 775 0
 1673 0112 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1674 0114 03F1FF33 		add	r3, r3, #-1
 1675 0118 DBB2     		uxtb	r3, r3
 1676 011a 03F01F03 		and	r3, r3, #31
 1677 011e DAB2     		uxtb	r2, r3
 1678 0120 FB7B     		ldrb	r3, [r7, #15]
 1679 0122 1343     		orrs	r3, r3, r2
 1680 0124 FB73     		strb	r3, [r7, #15]
 776:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 1681              		.loc 1 776 0
 1682 0126 4FF48043 		mov	r3, #16384
 1683 012a C4F20603 		movt	r3, 16390
 1684 012e FA7B     		ldrb	r2, [r7, #15]
 1685 0130 1A71     		strb	r2, [r3, #4]
 777:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C6
 778:../Sources/drivers/mcg/mcg.c ****     // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 779:../Sources/drivers/mcg/mcg.c ****     // The clock monitor is not enabled here as it has likely been enabled previously and so the va
 780:../Sources/drivers/mcg/mcg.c ****     // is not altered here.
 781:../Sources/drivers/mcg/mcg.c ****     // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 782:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 1686              		.loc 1 782 0
 1687 0132 4FF48043 		mov	r3, #16384
 1688 0136 C4F20603 		movt	r3, 16390
 1689 013a 5B79     		ldrb	r3, [r3, #5]
 1690 013c FB73     		strb	r3, [r7, #15]
 783:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 1691              		.loc 1 783 0
 1692 013e FB7B     		ldrb	r3, [r7, #15]
 1693 0140 23F01F03 		bic	r3, r3, #31
 1694 0144 FB73     		strb	r3, [r7, #15]
 784:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1695              		.loc 1 784 0
 1696 0146 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 1697 0148 A3F11803 		sub	r3, r3, #24
 1698 014c DBB2     		uxtb	r3, r3
 1699 014e 03F01F03 		and	r3, r3, #31
 1700 0152 DAB2     		uxtb	r2, r3
 1701 0154 FB7B     		ldrb	r3, [r7, #15]
 1702 0156 1343     		orrs	r3, r3, r2
 1703 0158 DBB2     		uxtb	r3, r3
 1704 015a 43F04003 		orr	r3, r3, #64
 1705 015e FB73     		strb	r3, [r7, #15]
 785:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 1706              		.loc 1 785 0
 1707 0160 4FF48043 		mov	r3, #16384
 1708 0164 C4F20603 		movt	r3, 16390
 1709 0168 FA7B     		ldrb	r2, [r7, #15]
 1710 016a 5A71     		strb	r2, [r3, #5]
 786:../Sources/drivers/mcg/mcg.c **** 
 787:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to set
 788:../Sources/drivers/mcg/mcg.c **** 
 789:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1711              		.loc 1 789 0
 1712 016c 4FF00003 		mov	r3, #0
 1713 0170 FB82     		strh	r3, [r7, #22]	@ movhi
 1714 0172 0DE0     		b	.L145
 1715              	.L148:
 790:../Sources/drivers/mcg/mcg.c ****         {
 791:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishe
 1716              		.loc 1 791 0
 1717 0174 4FF48043 		mov	r3, #16384
 1718 0178 C4F20603 		movt	r3, 16390
 1719 017c 9B79     		ldrb	r3, [r3, #6]
 1720 017e DBB2     		uxtb	r3, r3
 1721 0180 03F02003 		and	r3, r3, #32
 1722 0184 002B     		cmp	r3, #0
 1723 0186 0AD1     		bne	.L155
 1724              	.L146:
 789:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1725              		.loc 1 789 0
 1726 0188 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 1727 018a 03F10103 		add	r3, r3, #1
 1728 018e FB82     		strh	r3, [r7, #22]	@ movhi
 1729              	.L145:
 789:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1730              		.loc 1 789 0 is_stmt 0
 1731 0190 B7F91620 		ldrsh	r2, [r7, #22]
 1732 0194 40F2CF73 		movw	r3, #1999
 1733 0198 9A42     		cmp	r2, r3
 1734 019a EBDD     		ble	.L148
 1735 019c 00E0     		b	.L147
 1736              	.L155:
 1737              		.loc 1 791 0 is_stmt 1
 1738 019e 00BF     		nop
 1739              	.L147:
 792:../Sources/drivers/mcg/mcg.c ****         }
 793:../Sources/drivers/mcg/mcg.c **** 
 794:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 1740              		.loc 1 794 0
 1741 01a0 4FF48043 		mov	r3, #16384
 1742 01a4 C4F20603 		movt	r3, 16390
 1743 01a8 9B79     		ldrb	r3, [r3, #6]
 1744 01aa DBB2     		uxtb	r3, r3
 1745 01ac 03F02003 		and	r3, r3, #32
 1746 01b0 002B     		cmp	r3, #0
 1747 01b2 02D1     		bne	.L149
 1748              		.loc 1 794 0 is_stmt 0
 1749 01b4 4FF01603 		mov	r3, #22
 1750 01b8 27E0     		b	.L136
 1751              	.L149:
 795:../Sources/drivers/mcg/mcg.c **** 
 796:../Sources/drivers/mcg/mcg.c ****     // Wait for LOCK bit to set
 797:../Sources/drivers/mcg/mcg.c **** 
 798:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1752              		.loc 1 798 0 is_stmt 1
 1753 01ba 4FF00003 		mov	r3, #0
 1754 01be FB82     		strh	r3, [r7, #22]	@ movhi
 1755 01c0 0DE0     		b	.L150
 1756              	.L153:
 799:../Sources/drivers/mcg/mcg.c ****         {
 800:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop 
 1757              		.loc 1 800 0
 1758 01c2 4FF48043 		mov	r3, #16384
 1759 01c6 C4F20603 		movt	r3, 16390
 1760 01ca 9B79     		ldrb	r3, [r3, #6]
 1761 01cc DBB2     		uxtb	r3, r3
 1762 01ce 03F04003 		and	r3, r3, #64
 1763 01d2 002B     		cmp	r3, #0
 1764 01d4 0AD1     		bne	.L156
 1765              	.L151:
 798:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1766              		.loc 1 798 0
 1767 01d6 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 1768 01d8 03F10103 		add	r3, r3, #1
 1769 01dc FB82     		strh	r3, [r7, #22]	@ movhi
 1770              	.L150:
 798:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1771              		.loc 1 798 0 is_stmt 0
 1772 01de B7F91620 		ldrsh	r2, [r7, #22]
 1773 01e2 40F2CF73 		movw	r3, #1999
 1774 01e6 9A42     		cmp	r2, r3
 1775 01e8 EBDD     		ble	.L153
 1776 01ea 00E0     		b	.L152
 1777              	.L156:
 1778              		.loc 1 800 0 is_stmt 1
 1779 01ec 00BF     		nop
 1780              	.L152:
 801:../Sources/drivers/mcg/mcg.c ****         }
 802:../Sources/drivers/mcg/mcg.c **** 
 803:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 1781              		.loc 1 803 0
 1782 01ee 4FF48043 		mov	r3, #16384
 1783 01f2 C4F20603 		movt	r3, 16390
 1784 01f6 9B79     		ldrb	r3, [r3, #6]
 1785 01f8 DBB2     		uxtb	r3, r3
 1786 01fa 03F04003 		and	r3, r3, #64
 1787 01fe 002B     		cmp	r3, #0
 1788 0200 02D1     		bne	.L154
 1789              		.loc 1 803 0 is_stmt 0
 1790 0202 4FF04403 		mov	r3, #68
 1791 0206 00E0     		b	.L136
 1792              	.L154:
 804:../Sources/drivers/mcg/mcg.c **** 
 805:../Sources/drivers/mcg/mcg.c ****     // now in PBE
 806:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 1793              		.loc 1 806 0 is_stmt 1
 1794 0208 7B68     		ldr	r3, [r7, #4]
 1795              	.L136:
 807:../Sources/drivers/mcg/mcg.c **** }                       // fbe_pbe
 1796              		.loc 1 807 0
 1797 020a 1846     		mov	r0, r3
 1798 020c 07F11C07 		add	r7, r7, #28
 1799 0210 BD46     		mov	sp, r7
 1800 0212 80BC     		pop	{r7}
 1801 0214 7047     		bx	lr
 1802              		.cfi_endproc
 1803              	.LFE5:
 1805 0216 00BF     		.section	.text.pbe_blpe,"ax",%progbits
 1806              		.align	2
 1807              		.global	pbe_blpe
 1808              		.thumb
 1809              		.thumb_func
 1811              	pbe_blpe:
 1812              	.LFB6:
 808:../Sources/drivers/mcg/mcg.c **** 
 809:../Sources/drivers/mcg/mcg.c **** /* */
 810:../Sources/drivers/mcg/mcg.c **** 
 811:../Sources/drivers/mcg/mcg.c **** int pbe_blpe
 812:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
 813:../Sources/drivers/mcg/mcg.c **** {
 1813              		.loc 1 813 0
 1814              		.cfi_startproc
 1815              		@ args = 0, pretend = 0, frame = 8
 1816              		@ frame_needed = 1, uses_anonymous_args = 0
 1817              		@ link register save eliminated.
 1818 0000 80B4     		push	{r7}
 1819              	.LCFI18:
 1820              		.cfi_def_cfa_offset 4
 1821              		.cfi_offset 7, -4
 1822 0002 83B0     		sub	sp, sp, #12
 1823              	.LCFI19:
 1824              		.cfi_def_cfa_offset 16
 1825 0004 00AF     		add	r7, sp, #0
 1826              	.LCFI20:
 1827              		.cfi_def_cfa_register 7
 1828 0006 7860     		str	r0, [r7, #4]
 814:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PBE mode
 815:../Sources/drivers/mcg/mcg.c ****     if
 816:../Sources/drivers/mcg/mcg.c ****     (
 817:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1829              		.loc 1 817 0
 1830 0008 4FF48043 		mov	r3, #16384
 1831 000c C4F20603 		movt	r3, 16390
 1832 0010 9B79     		ldrb	r3, [r3, #6]
 1833 0012 DBB2     		uxtb	r3, r3
 1834 0014 03F00C03 		and	r3, r3, #12
 1835 0018 4FEA9303 		lsr	r3, r3, #2
 816:../Sources/drivers/mcg/mcg.c ****     (
 1836              		.loc 1 816 0
 1837 001c 022B     		cmp	r3, #2
 1838 001e 1DD1     		bne	.L158
 818:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1839              		.loc 1 818 0
 1840 0020 4FF48043 		mov	r3, #16384
 1841 0024 C4F20603 		movt	r3, 16390
 1842 0028 9B79     		ldrb	r3, [r3, #6]
 1843 002a DBB2     		uxtb	r3, r3
 1844 002c 03F01003 		and	r3, r3, #16
 1845 0030 002B     		cmp	r3, #0
 1846 0032 13D1     		bne	.L158
 819:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 1847              		.loc 1 819 0
 1848 0034 4FF48043 		mov	r3, #16384
 1849 0038 C4F20603 		movt	r3, 16390
 1850 003c 9B79     		ldrb	r3, [r3, #6]
 1851 003e DBB2     		uxtb	r3, r3
 1852 0040 03F02003 		and	r3, r3, #32
 1853 0044 002B     		cmp	r3, #0
 1854 0046 09D0     		beq	.L158
 820:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 1855              		.loc 1 820 0
 1856 0048 4FF48043 		mov	r3, #16384
 1857 004c C4F20603 		movt	r3, 16390
 1858 0050 5B78     		ldrb	r3, [r3, #1]
 1859 0052 DBB2     		uxtb	r3, r3
 1860 0054 03F00203 		and	r3, r3, #2
 817:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1861              		.loc 1 817 0
 1862 0058 002B     		cmp	r3, #0
 1863 005a 02D0     		beq	.L159
 1864              	.L158:
 821:../Sources/drivers/mcg/mcg.c ****          )
 822:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
 823:../Sources/drivers/mcg/mcg.c ****         {
 824:../Sources/drivers/mcg/mcg.c ****             return 0x7; // return error code
 1865              		.loc 1 824 0
 1866 005c 4FF00703 		mov	r3, #7
 1867 0060 0EE0     		b	.L160
 1868              	.L159:
 825:../Sources/drivers/mcg/mcg.c ****         }
 826:../Sources/drivers/mcg/mcg.c **** 
 827:../Sources/drivers/mcg/mcg.c ****     // To enter BLPE mode the LP bit must be set, disabling the PLL
 828:../Sources/drivers/mcg/mcg.c ****     MCG_C2 |= MCG_C2_LP_MASK;
 1869              		.loc 1 828 0
 1870 0062 4FF48043 		mov	r3, #16384
 1871 0066 C4F20603 		movt	r3, 16390
 1872 006a 4FF48042 		mov	r2, #16384
 1873 006e C4F20602 		movt	r2, 16390
 1874 0072 5278     		ldrb	r2, [r2, #1]
 1875 0074 D2B2     		uxtb	r2, r2
 1876 0076 42F00202 		orr	r2, r2, #2
 1877 007a D2B2     		uxtb	r2, r2
 1878 007c 5A70     		strb	r2, [r3, #1]
 829:../Sources/drivers/mcg/mcg.c ****     // Now in BLPE mode
 830:../Sources/drivers/mcg/mcg.c ****     return crystal_val;
 1879              		.loc 1 830 0
 1880 007e 7B68     		ldr	r3, [r7, #4]
 1881              	.L160:
 831:../Sources/drivers/mcg/mcg.c **** }                   // pbe_blpe
 1882              		.loc 1 831 0
 1883 0080 1846     		mov	r0, r3
 1884 0082 07F10C07 		add	r7, r7, #12
 1885 0086 BD46     		mov	sp, r7
 1886 0088 80BC     		pop	{r7}
 1887 008a 7047     		bx	lr
 1888              		.cfi_endproc
 1889              	.LFE6:
 1891              		.section	.text.blpe_pbe,"ax",%progbits
 1892              		.align	2
 1893              		.global	blpe_pbe
 1894              		.thumb
 1895              		.thumb_func
 1897              	blpe_pbe:
 1898              	.LFB7:
 832:../Sources/drivers/mcg/mcg.c **** 
 833:../Sources/drivers/mcg/mcg.c **** // ************************************************************************************************
 834:../Sources/drivers/mcg/mcg.c **** // Since PBE mode can be enterred via FBE -> BLPE modes, it cannot be assumed that the PLL has been
 835:../Sources/drivers/mcg/mcg.c **** // previously configured correctly. That is why this general purpose driver has the PLL settings as
 836:../Sources/drivers/mcg/mcg.c **** // passed parameters.
 837:../Sources/drivers/mcg/mcg.c **** 
 838:../Sources/drivers/mcg/mcg.c **** // ************************************************************************************************
 839:../Sources/drivers/mcg/mcg.c **** 
 840:../Sources/drivers/mcg/mcg.c **** int blpe_pbe
 841:../Sources/drivers/mcg/mcg.c **** (
 842:../Sources/drivers/mcg/mcg.c ****     int         crystal_val,
 843:../Sources/drivers/mcg/mcg.c ****     signed char prdiv_val,
 844:../Sources/drivers/mcg/mcg.c ****     signed char vdiv_val
 845:../Sources/drivers/mcg/mcg.c **** )
 846:../Sources/drivers/mcg/mcg.c **** {
 1899              		.loc 1 846 0
 1900              		.cfi_startproc
 1901              		@ args = 0, pretend = 0, frame = 16
 1902              		@ frame_needed = 1, uses_anonymous_args = 0
 1903              		@ link register save eliminated.
 1904 0000 80B4     		push	{r7}
 1905              	.LCFI21:
 1906              		.cfi_def_cfa_offset 4
 1907              		.cfi_offset 7, -4
 1908 0002 85B0     		sub	sp, sp, #20
 1909              	.LCFI22:
 1910              		.cfi_def_cfa_offset 24
 1911 0004 00AF     		add	r7, sp, #0
 1912              	.LCFI23:
 1913              		.cfi_def_cfa_register 7
 1914 0006 7860     		str	r0, [r7, #4]
 1915 0008 1346     		mov	r3, r2
 1916 000a 0A46     		mov	r2, r1
 1917 000c FA70     		strb	r2, [r7, #3]
 1918 000e BB70     		strb	r3, [r7, #2]
 847:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 848:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 849:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 850:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 851:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 852:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 853:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
 854:../Sources/drivers/mcg/mcg.c ****     short           i;
 855:../Sources/drivers/mcg/mcg.c **** 
 856:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 857:../Sources/drivers/mcg/mcg.c **** 
 858:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 859:../Sources/drivers/mcg/mcg.c **** 
 860:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 861:../Sources/drivers/mcg/mcg.c **** 
 862:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 863:../Sources/drivers/mcg/mcg.c **** 
 864:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 865:../Sources/drivers/mcg/mcg.c **** 
 866:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 867:../Sources/drivers/mcg/mcg.c **** 
 868:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in BLPE mode
 869:../Sources/drivers/mcg/mcg.c **** 
 870:../Sources/drivers/mcg/mcg.c ****     if
 871:../Sources/drivers/mcg/mcg.c ****     (
 872:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1919              		.loc 1 872 0
 1920 0010 4FF48043 		mov	r3, #16384
 1921 0014 C4F20603 		movt	r3, 16390
 1922 0018 9B79     		ldrb	r3, [r3, #6]
 1923 001a DBB2     		uxtb	r3, r3
 1924 001c 03F00C03 		and	r3, r3, #12
 1925 0020 4FEA9303 		lsr	r3, r3, #2
 871:../Sources/drivers/mcg/mcg.c ****     (
 1926              		.loc 1 871 0
 1927 0024 022B     		cmp	r3, #2
 1928 0026 13D1     		bne	.L162
 873:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1929              		.loc 1 873 0
 1930 0028 4FF48043 		mov	r3, #16384
 1931 002c C4F20603 		movt	r3, 16390
 1932 0030 9B79     		ldrb	r3, [r3, #6]
 1933 0032 DBB2     		uxtb	r3, r3
 1934 0034 03F01003 		and	r3, r3, #16
 1935 0038 002B     		cmp	r3, #0
 1936 003a 09D1     		bne	.L162
 874:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_C2 & MCG_C2_LP_MASK)
 1937              		.loc 1 874 0
 1938 003c 4FF48043 		mov	r3, #16384
 1939 0040 C4F20603 		movt	r3, 16390
 1940 0044 5B78     		ldrb	r3, [r3, #1]
 1941 0046 DBB2     		uxtb	r3, r3
 1942 0048 03F00203 		and	r3, r3, #2
 872:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1943              		.loc 1 872 0
 1944 004c 002B     		cmp	r3, #0
 1945 004e 02D1     		bne	.L163
 1946              	.L162:
 875:../Sources/drivers/mcg/mcg.c ****          )
 876:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is set
 877:../Sources/drivers/mcg/mcg.c ****         {
 878:../Sources/drivers/mcg/mcg.c ****             return 0x6; // return error code
 1947              		.loc 1 878 0
 1948 0050 4FF00603 		mov	r3, #6
 1949 0054 C2E0     		b	.L164
 1950              	.L163:
 879:../Sources/drivers/mcg/mcg.c ****         }
 880:../Sources/drivers/mcg/mcg.c **** 
 881:../Sources/drivers/mcg/mcg.c ****     // As the external frequency has already been checked when FBE mode was enterred it is not chec
 882:../Sources/drivers/mcg/mcg.c ****     // Check PLL divider settings are within spec.
 883:../Sources/drivers/mcg/mcg.c **** 
 884:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 1951              		.loc 1 884 0
 1952 0056 97F90330 		ldrsb	r3, [r7, #3]
 1953 005a 002B     		cmp	r3, #0
 1954 005c 03DD     		ble	.L165
 1955              		.loc 1 884 0 is_stmt 0
 1956 005e 97F90330 		ldrsb	r3, [r7, #3]
 1957 0062 192B     		cmp	r3, #25
 1958 0064 02DD     		ble	.L166
 1959              	.L165:
 885:../Sources/drivers/mcg/mcg.c ****         {
 886:../Sources/drivers/mcg/mcg.c ****             return 0x41;
 1960              		.loc 1 886 0 is_stmt 1
 1961 0066 4FF04103 		mov	r3, #65
 1962 006a B7E0     		b	.L164
 1963              	.L166:
 887:../Sources/drivers/mcg/mcg.c ****         }
 888:../Sources/drivers/mcg/mcg.c **** 
 889:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 1964              		.loc 1 889 0
 1965 006c 97F90230 		ldrsb	r3, [r7, #2]
 1966 0070 172B     		cmp	r3, #23
 1967 0072 03DD     		ble	.L167
 1968              		.loc 1 889 0 is_stmt 0
 1969 0074 97F90230 		ldrsb	r3, [r7, #2]
 1970 0078 322B     		cmp	r3, #50
 1971 007a 02DD     		ble	.L168
 1972              	.L167:
 890:../Sources/drivers/mcg/mcg.c ****         {
 891:../Sources/drivers/mcg/mcg.c ****             return 0x42;
 1973              		.loc 1 891 0 is_stmt 1
 1974 007c 4FF04203 		mov	r3, #66
 1975 0080 ACE0     		b	.L164
 1976              	.L168:
 892:../Sources/drivers/mcg/mcg.c ****         }
 893:../Sources/drivers/mcg/mcg.c **** 
 894:../Sources/drivers/mcg/mcg.c ****     // Check PLL reference clock frequency is within spec.
 895:../Sources/drivers/mcg/mcg.c **** 
 896:../Sources/drivers/mcg/mcg.c ****     if(((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000))
 1977              		.loc 1 896 0
 1978 0082 97F90330 		ldrsb	r3, [r7, #3]
 1979 0086 7A68     		ldr	r2, [r7, #4]
 1980 0088 92FBF3F2 		sdiv	r2, r2, r3
 1981 008c 48F27F43 		movw	r3, #33919
 1982 0090 C0F21E03 		movt	r3, 30
 1983 0094 9A42     		cmp	r2, r3
 1984 0096 0ADD     		ble	.L169
 1985              		.loc 1 896 0 is_stmt 0
 1986 0098 97F90330 		ldrsb	r3, [r7, #3]
 1987 009c 7A68     		ldr	r2, [r7, #4]
 1988 009e 92FBF3F2 		sdiv	r2, r2, r3
 1989 00a2 4FF41063 		mov	r3, #2304
 1990 00a6 C0F23D03 		movt	r3, 61
 1991 00aa 9A42     		cmp	r2, r3
 1992 00ac 02DD     		ble	.L170
 1993              	.L169:
 897:../Sources/drivers/mcg/mcg.c ****         {
 898:../Sources/drivers/mcg/mcg.c ****             return 0x43;
 1994              		.loc 1 898 0 is_stmt 1
 1995 00ae 4FF04303 		mov	r3, #67
 1996 00b2 93E0     		b	.L164
 1997              	.L170:
 899:../Sources/drivers/mcg/mcg.c ****         }
 900:../Sources/drivers/mcg/mcg.c **** 
 901:../Sources/drivers/mcg/mcg.c ****     // If PRDIV, VDIV and the PLL ref clock are in spec. then the PLL frequency is within spec.
 902:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C5
 903:../Sources/drivers/mcg/mcg.c ****     // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user 
 904:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 1998              		.loc 1 904 0
 1999 00b4 4FF48043 		mov	r3, #16384
 2000 00b8 C4F20603 		movt	r3, 16390
 2001 00bc 1B79     		ldrb	r3, [r3, #4]
 2002 00be 7B73     		strb	r3, [r7, #13]
 905:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 2003              		.loc 1 905 0
 2004 00c0 7B7B     		ldrb	r3, [r7, #13]
 2005 00c2 23F01F03 		bic	r3, r3, #31
 2006 00c6 7B73     		strb	r3, [r7, #13]
 906:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 2007              		.loc 1 906 0
 2008 00c8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2009 00ca 03F1FF33 		add	r3, r3, #-1
 2010 00ce DBB2     		uxtb	r3, r3
 2011 00d0 03F01F03 		and	r3, r3, #31
 2012 00d4 DAB2     		uxtb	r2, r3
 2013 00d6 7B7B     		ldrb	r3, [r7, #13]
 2014 00d8 1343     		orrs	r3, r3, r2
 2015 00da 7B73     		strb	r3, [r7, #13]
 907:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 2016              		.loc 1 907 0
 2017 00dc 4FF48043 		mov	r3, #16384
 2018 00e0 C4F20603 		movt	r3, 16390
 2019 00e4 7A7B     		ldrb	r2, [r7, #13]
 2020 00e6 1A71     		strb	r2, [r3, #4]
 908:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C6
 909:../Sources/drivers/mcg/mcg.c ****     // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 910:../Sources/drivers/mcg/mcg.c ****     // The clock monitor is not enabled here as it has likely been enabled previously and so the va
 911:../Sources/drivers/mcg/mcg.c ****     // is not altered here.
 912:../Sources/drivers/mcg/mcg.c ****     // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 913:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 2021              		.loc 1 913 0
 2022 00e8 4FF48043 		mov	r3, #16384
 2023 00ec C4F20603 		movt	r3, 16390
 2024 00f0 5B79     		ldrb	r3, [r3, #5]
 2025 00f2 7B73     		strb	r3, [r7, #13]
 914:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 2026              		.loc 1 914 0
 2027 00f4 7B7B     		ldrb	r3, [r7, #13]
 2028 00f6 23F01F03 		bic	r3, r3, #31
 2029 00fa 7B73     		strb	r3, [r7, #13]
 915:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 2030              		.loc 1 915 0
 2031 00fc BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 2032 00fe A3F11803 		sub	r3, r3, #24
 2033 0102 DBB2     		uxtb	r3, r3
 2034 0104 03F01F03 		and	r3, r3, #31
 2035 0108 DAB2     		uxtb	r2, r3
 2036 010a 7B7B     		ldrb	r3, [r7, #13]
 2037 010c 1343     		orrs	r3, r3, r2
 2038 010e DBB2     		uxtb	r3, r3
 2039 0110 43F04003 		orr	r3, r3, #64
 2040 0114 7B73     		strb	r3, [r7, #13]
 916:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 2041              		.loc 1 916 0
 2042 0116 4FF48043 		mov	r3, #16384
 2043 011a C4F20603 		movt	r3, 16390
 2044 011e 7A7B     		ldrb	r2, [r7, #13]
 2045 0120 5A71     		strb	r2, [r3, #5]
 917:../Sources/drivers/mcg/mcg.c ****     // Now that PLL is configured, LP is cleared to enable the PLL
 918:../Sources/drivers/mcg/mcg.c ****     MCG_C2 &= ~MCG_C2_LP_MASK;
 2046              		.loc 1 918 0
 2047 0122 4FF48043 		mov	r3, #16384
 2048 0126 C4F20603 		movt	r3, 16390
 2049 012a 4FF48042 		mov	r2, #16384
 2050 012e C4F20602 		movt	r2, 16390
 2051 0132 5278     		ldrb	r2, [r2, #1]
 2052 0134 D2B2     		uxtb	r2, r2
 2053 0136 22F00202 		bic	r2, r2, #2
 2054 013a D2B2     		uxtb	r2, r2
 2055 013c 5A70     		strb	r2, [r3, #1]
 919:../Sources/drivers/mcg/mcg.c **** 
 920:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to set
 921:../Sources/drivers/mcg/mcg.c **** 
 922:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2056              		.loc 1 922 0
 2057 013e 4FF00003 		mov	r3, #0
 2058 0142 FB81     		strh	r3, [r7, #14]	@ movhi
 2059 0144 0DE0     		b	.L171
 2060              	.L174:
 923:../Sources/drivers/mcg/mcg.c ****         {
 924:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishe
 2061              		.loc 1 924 0
 2062 0146 4FF48043 		mov	r3, #16384
 2063 014a C4F20603 		movt	r3, 16390
 2064 014e 9B79     		ldrb	r3, [r3, #6]
 2065 0150 DBB2     		uxtb	r3, r3
 2066 0152 03F02003 		and	r3, r3, #32
 2067 0156 002B     		cmp	r3, #0
 2068 0158 0AD1     		bne	.L181
 2069              	.L172:
 922:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2070              		.loc 1 922 0
 2071 015a FB89     		ldrh	r3, [r7, #14]	@ movhi
 2072 015c 03F10103 		add	r3, r3, #1
 2073 0160 FB81     		strh	r3, [r7, #14]	@ movhi
 2074              	.L171:
 922:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2075              		.loc 1 922 0 is_stmt 0
 2076 0162 B7F90E20 		ldrsh	r2, [r7, #14]
 2077 0166 40F2CF73 		movw	r3, #1999
 2078 016a 9A42     		cmp	r2, r3
 2079 016c EBDD     		ble	.L174
 2080 016e 00E0     		b	.L173
 2081              	.L181:
 2082              		.loc 1 924 0 is_stmt 1
 2083 0170 00BF     		nop
 2084              	.L173:
 925:../Sources/drivers/mcg/mcg.c ****         }
 926:../Sources/drivers/mcg/mcg.c **** 
 927:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 2085              		.loc 1 927 0
 2086 0172 4FF48043 		mov	r3, #16384
 2087 0176 C4F20603 		movt	r3, 16390
 2088 017a 9B79     		ldrb	r3, [r3, #6]
 2089 017c DBB2     		uxtb	r3, r3
 2090 017e 03F02003 		and	r3, r3, #32
 2091 0182 002B     		cmp	r3, #0
 2092 0184 02D1     		bne	.L175
 2093              		.loc 1 927 0 is_stmt 0
 2094 0186 4FF01603 		mov	r3, #22
 2095 018a 27E0     		b	.L164
 2096              	.L175:
 928:../Sources/drivers/mcg/mcg.c **** 
 929:../Sources/drivers/mcg/mcg.c ****     // Wait for LOCK bit to set
 930:../Sources/drivers/mcg/mcg.c **** 
 931:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2097              		.loc 1 931 0 is_stmt 1
 2098 018c 4FF00003 		mov	r3, #0
 2099 0190 FB81     		strh	r3, [r7, #14]	@ movhi
 2100 0192 0DE0     		b	.L176
 2101              	.L179:
 932:../Sources/drivers/mcg/mcg.c ****         {
 933:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop 
 2102              		.loc 1 933 0
 2103 0194 4FF48043 		mov	r3, #16384
 2104 0198 C4F20603 		movt	r3, 16390
 2105 019c 9B79     		ldrb	r3, [r3, #6]
 2106 019e DBB2     		uxtb	r3, r3
 2107 01a0 03F04003 		and	r3, r3, #64
 2108 01a4 002B     		cmp	r3, #0
 2109 01a6 0AD1     		bne	.L182
 2110              	.L177:
 931:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2111              		.loc 1 931 0
 2112 01a8 FB89     		ldrh	r3, [r7, #14]	@ movhi
 2113 01aa 03F10103 		add	r3, r3, #1
 2114 01ae FB81     		strh	r3, [r7, #14]	@ movhi
 2115              	.L176:
 931:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2116              		.loc 1 931 0 is_stmt 0
 2117 01b0 B7F90E20 		ldrsh	r2, [r7, #14]
 2118 01b4 40F2CF73 		movw	r3, #1999
 2119 01b8 9A42     		cmp	r2, r3
 2120 01ba EBDD     		ble	.L179
 2121 01bc 00E0     		b	.L178
 2122              	.L182:
 2123              		.loc 1 933 0 is_stmt 1
 2124 01be 00BF     		nop
 2125              	.L178:
 934:../Sources/drivers/mcg/mcg.c ****         }
 935:../Sources/drivers/mcg/mcg.c **** 
 936:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 2126              		.loc 1 936 0
 2127 01c0 4FF48043 		mov	r3, #16384
 2128 01c4 C4F20603 		movt	r3, 16390
 2129 01c8 9B79     		ldrb	r3, [r3, #6]
 2130 01ca DBB2     		uxtb	r3, r3
 2131 01cc 03F04003 		and	r3, r3, #64
 2132 01d0 002B     		cmp	r3, #0
 2133 01d2 02D1     		bne	.L180
 2134              		.loc 1 936 0 is_stmt 0
 2135 01d4 4FF04403 		mov	r3, #68
 2136 01d8 00E0     		b	.L164
 2137              	.L180:
 937:../Sources/drivers/mcg/mcg.c **** 
 938:../Sources/drivers/mcg/mcg.c ****     // now in PBE
 939:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 2138              		.loc 1 939 0 is_stmt 1
 2139 01da 7B68     		ldr	r3, [r7, #4]
 2140              	.L164:
 940:../Sources/drivers/mcg/mcg.c **** }                       // blpe_pbe
 2141              		.loc 1 940 0
 2142 01dc 1846     		mov	r0, r3
 2143 01de 07F11407 		add	r7, r7, #20
 2144 01e2 BD46     		mov	sp, r7
 2145 01e4 80BC     		pop	{r7}
 2146 01e6 7047     		bx	lr
 2147              		.cfi_endproc
 2148              	.LFE7:
 2150              		.section	.text.blpe_fbe,"ax",%progbits
 2151              		.align	2
 2152              		.global	blpe_fbe
 2153              		.thumb
 2154              		.thumb_func
 2156              	blpe_fbe:
 2157              	.LFB8:
 941:../Sources/drivers/mcg/mcg.c **** 
 942:../Sources/drivers/mcg/mcg.c **** /* */
 943:../Sources/drivers/mcg/mcg.c **** 
 944:../Sources/drivers/mcg/mcg.c **** int blpe_fbe
 945:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
 946:../Sources/drivers/mcg/mcg.c **** {
 2158              		.loc 1 946 0
 2159              		.cfi_startproc
 2160              		@ args = 0, pretend = 0, frame = 16
 2161              		@ frame_needed = 1, uses_anonymous_args = 0
 2162              		@ link register save eliminated.
 2163 0000 80B4     		push	{r7}
 2164              	.LCFI24:
 2165              		.cfi_def_cfa_offset 4
 2166              		.cfi_offset 7, -4
 2167 0002 85B0     		sub	sp, sp, #20
 2168              	.LCFI25:
 2169              		.cfi_def_cfa_offset 24
 2170 0004 00AF     		add	r7, sp, #0
 2171              	.LCFI26:
 2172              		.cfi_def_cfa_register 7
 2173 0006 7860     		str	r0, [r7, #4]
 947:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 948:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 949:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 950:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 951:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 952:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 953:../Sources/drivers/mcg/mcg.c ****     short   i;
 954:../Sources/drivers/mcg/mcg.c **** 
 955:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 956:../Sources/drivers/mcg/mcg.c **** 
 957:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 958:../Sources/drivers/mcg/mcg.c **** 
 959:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 960:../Sources/drivers/mcg/mcg.c **** 
 961:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 962:../Sources/drivers/mcg/mcg.c **** 
 963:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 964:../Sources/drivers/mcg/mcg.c **** 
 965:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 966:../Sources/drivers/mcg/mcg.c **** 
 967:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in BLPE mode
 968:../Sources/drivers/mcg/mcg.c **** 
 969:../Sources/drivers/mcg/mcg.c ****     if
 970:../Sources/drivers/mcg/mcg.c ****     (
 971:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 2174              		.loc 1 971 0
 2175 0008 4FF48043 		mov	r3, #16384
 2176 000c C4F20603 		movt	r3, 16390
 2177 0010 9B79     		ldrb	r3, [r3, #6]
 2178 0012 DBB2     		uxtb	r3, r3
 2179 0014 03F00C03 		and	r3, r3, #12
 2180 0018 4FEA9303 		lsr	r3, r3, #2
 970:../Sources/drivers/mcg/mcg.c ****     (
 2181              		.loc 1 970 0
 2182 001c 022B     		cmp	r3, #2
 2183 001e 13D1     		bne	.L184
 972:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 2184              		.loc 1 972 0
 2185 0020 4FF48043 		mov	r3, #16384
 2186 0024 C4F20603 		movt	r3, 16390
 2187 0028 9B79     		ldrb	r3, [r3, #6]
 2188 002a DBB2     		uxtb	r3, r3
 2189 002c 03F01003 		and	r3, r3, #16
 2190 0030 002B     		cmp	r3, #0
 2191 0032 09D1     		bne	.L184
 973:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_C2 & MCG_C2_LP_MASK)
 2192              		.loc 1 973 0
 2193 0034 4FF48043 		mov	r3, #16384
 2194 0038 C4F20603 		movt	r3, 16390
 2195 003c 5B78     		ldrb	r3, [r3, #1]
 2196 003e DBB2     		uxtb	r3, r3
 2197 0040 03F00203 		and	r3, r3, #2
 971:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 2198              		.loc 1 971 0
 2199 0044 002B     		cmp	r3, #0
 2200 0046 02D1     		bne	.L185
 2201              	.L184:
 974:../Sources/drivers/mcg/mcg.c ****          )
 975:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is set
 976:../Sources/drivers/mcg/mcg.c ****         {
 977:../Sources/drivers/mcg/mcg.c ****             return 0x6; // return error code
 2202              		.loc 1 977 0
 2203 0048 4FF00603 		mov	r3, #6
 2204 004c 43E0     		b	.L186
 2205              	.L185:
 978:../Sources/drivers/mcg/mcg.c ****         }
 979:../Sources/drivers/mcg/mcg.c **** 
 980:../Sources/drivers/mcg/mcg.c ****     // To move from BLPE to FBE the PLLS mux be set to select the FLL output and the LP bit must be
 981:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_PLLS_MASK;                // clear PLLS to select the FLL
 2206              		.loc 1 981 0
 2207 004e 4FF48043 		mov	r3, #16384
 2208 0052 C4F20603 		movt	r3, 16390
 2209 0056 4FF48042 		mov	r2, #16384
 2210 005a C4F20602 		movt	r2, 16390
 2211 005e 5279     		ldrb	r2, [r2, #5]
 2212 0060 D2B2     		uxtb	r2, r2
 2213 0062 22F04002 		bic	r2, r2, #64
 2214 0066 D2B2     		uxtb	r2, r2
 2215 0068 5A71     		strb	r2, [r3, #5]
 982:../Sources/drivers/mcg/mcg.c ****     MCG_C2 &= ~MCG_C2_LP_MASK;                  // clear LP bit
 2216              		.loc 1 982 0
 2217 006a 4FF48043 		mov	r3, #16384
 2218 006e C4F20603 		movt	r3, 16390
 2219 0072 4FF48042 		mov	r2, #16384
 2220 0076 C4F20602 		movt	r2, 16390
 2221 007a 5278     		ldrb	r2, [r2, #1]
 2222 007c D2B2     		uxtb	r2, r2
 2223 007e 22F00202 		bic	r2, r2, #2
 2224 0082 D2B2     		uxtb	r2, r2
 2225 0084 5A70     		strb	r2, [r3, #1]
 983:../Sources/drivers/mcg/mcg.c **** 
 984:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to clear
 985:../Sources/drivers/mcg/mcg.c **** 
 986:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2226              		.loc 1 986 0
 2227 0086 4FF00003 		mov	r3, #0
 2228 008a FB81     		strh	r3, [r7, #14]	@ movhi
 2229 008c 0DE0     		b	.L187
 2230              	.L190:
 987:../Sources/drivers/mcg/mcg.c ****         {
 988:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_PLLST_MASK)) break;  // jump out early if PLLST clears before loop f
 2231              		.loc 1 988 0
 2232 008e 4FF48043 		mov	r3, #16384
 2233 0092 C4F20603 		movt	r3, 16390
 2234 0096 9B79     		ldrb	r3, [r3, #6]
 2235 0098 DBB2     		uxtb	r3, r3
 2236 009a 03F02003 		and	r3, r3, #32
 2237 009e 002B     		cmp	r3, #0
 2238 00a0 0AD0     		beq	.L192
 2239              	.L188:
 986:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2240              		.loc 1 986 0
 2241 00a2 FB89     		ldrh	r3, [r7, #14]	@ movhi
 2242 00a4 03F10103 		add	r3, r3, #1
 2243 00a8 FB81     		strh	r3, [r7, #14]	@ movhi
 2244              	.L187:
 986:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2245              		.loc 1 986 0 is_stmt 0
 2246 00aa B7F90E20 		ldrsh	r2, [r7, #14]
 2247 00ae 40F2CF73 		movw	r3, #1999
 2248 00b2 9A42     		cmp	r2, r3
 2249 00b4 EBDD     		ble	.L190
 2250 00b6 00E0     		b	.L189
 2251              	.L192:
 2252              		.loc 1 988 0 is_stmt 1
 2253 00b8 00BF     		nop
 2254              	.L189:
 989:../Sources/drivers/mcg/mcg.c ****         }
 990:../Sources/drivers/mcg/mcg.c **** 
 991:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_PLLST_MASK) return 0x15;   // check bit is really clear and return with error 
 2255              		.loc 1 991 0
 2256 00ba 4FF48043 		mov	r3, #16384
 2257 00be C4F20603 		movt	r3, 16390
 2258 00c2 9B79     		ldrb	r3, [r3, #6]
 2259 00c4 DBB2     		uxtb	r3, r3
 2260 00c6 03F02003 		and	r3, r3, #32
 2261 00ca 002B     		cmp	r3, #0
 2262 00cc 02D0     		beq	.L191
 2263              		.loc 1 991 0 is_stmt 0
 2264 00ce 4FF01503 		mov	r3, #21
 2265 00d2 00E0     		b	.L186
 2266              	.L191:
 992:../Sources/drivers/mcg/mcg.c **** 
 993:../Sources/drivers/mcg/mcg.c ****     // now in FBE mode
 994:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 2267              		.loc 1 994 0 is_stmt 1
 2268 00d4 7B68     		ldr	r3, [r7, #4]
 2269              	.L186:
 995:../Sources/drivers/mcg/mcg.c **** }                       // blpe_fbe
 2270              		.loc 1 995 0
 2271 00d6 1846     		mov	r0, r3
 2272 00d8 07F11407 		add	r7, r7, #20
 2273 00dc BD46     		mov	sp, r7
 2274 00de 80BC     		pop	{r7}
 2275 00e0 7047     		bx	lr
 2276              		.cfi_endproc
 2277              	.LFE8:
 2279 00e2 00BF     		.section	.text.fbe_blpe,"ax",%progbits
 2280              		.align	2
 2281              		.global	fbe_blpe
 2282              		.thumb
 2283              		.thumb_func
 2285              	fbe_blpe:
 2286              	.LFB9:
 996:../Sources/drivers/mcg/mcg.c **** 
 997:../Sources/drivers/mcg/mcg.c **** /* */
 998:../Sources/drivers/mcg/mcg.c **** 
 999:../Sources/drivers/mcg/mcg.c **** int fbe_blpe
1000:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
1001:../Sources/drivers/mcg/mcg.c **** {
 2287              		.loc 1 1001 0
 2288              		.cfi_startproc
 2289              		@ args = 0, pretend = 0, frame = 8
 2290              		@ frame_needed = 1, uses_anonymous_args = 0
 2291              		@ link register save eliminated.
 2292 0000 80B4     		push	{r7}
 2293              	.LCFI27:
 2294              		.cfi_def_cfa_offset 4
 2295              		.cfi_offset 7, -4
 2296 0002 83B0     		sub	sp, sp, #12
 2297              	.LCFI28:
 2298              		.cfi_def_cfa_offset 16
 2299 0004 00AF     		add	r7, sp, #0
 2300              	.LCFI29:
 2301              		.cfi_def_cfa_register 7
 2302 0006 7860     		str	r0, [r7, #4]
1002:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
1003:../Sources/drivers/mcg/mcg.c ****     if
1004:../Sources/drivers/mcg/mcg.c ****     (
1005:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 2303              		.loc 1 1005 0
 2304 0008 4FF48043 		mov	r3, #16384
 2305 000c C4F20603 		movt	r3, 16390
 2306 0010 9B79     		ldrb	r3, [r3, #6]
 2307 0012 DBB2     		uxtb	r3, r3
 2308 0014 03F00C03 		and	r3, r3, #12
 2309 0018 4FEA9303 		lsr	r3, r3, #2
1004:../Sources/drivers/mcg/mcg.c ****     (
 2310              		.loc 1 1004 0
 2311 001c 022B     		cmp	r3, #2
 2312 001e 1DD1     		bne	.L194
1006:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 2313              		.loc 1 1006 0
 2314 0020 4FF48043 		mov	r3, #16384
 2315 0024 C4F20603 		movt	r3, 16390
 2316 0028 9B79     		ldrb	r3, [r3, #6]
 2317 002a DBB2     		uxtb	r3, r3
 2318 002c 03F01003 		and	r3, r3, #16
 2319 0030 002B     		cmp	r3, #0
 2320 0032 13D1     		bne	.L194
1007:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 2321              		.loc 1 1007 0
 2322 0034 4FF48043 		mov	r3, #16384
 2323 0038 C4F20603 		movt	r3, 16390
 2324 003c 9B79     		ldrb	r3, [r3, #6]
 2325 003e DBB2     		uxtb	r3, r3
 2326 0040 03F02003 		and	r3, r3, #32
 2327 0044 002B     		cmp	r3, #0
 2328 0046 09D1     		bne	.L194
1008:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 2329              		.loc 1 1008 0
 2330 0048 4FF48043 		mov	r3, #16384
 2331 004c C4F20603 		movt	r3, 16390
 2332 0050 5B78     		ldrb	r3, [r3, #1]
 2333 0052 DBB2     		uxtb	r3, r3
 2334 0054 03F00203 		and	r3, r3, #2
1005:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 2335              		.loc 1 1005 0
 2336 0058 002B     		cmp	r3, #0
 2337 005a 02D0     		beq	.L195
 2338              	.L194:
1009:../Sources/drivers/mcg/mcg.c ****          )
1010:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
1011:../Sources/drivers/mcg/mcg.c ****         {
1012:../Sources/drivers/mcg/mcg.c ****             return 0x4; // return error code
 2339              		.loc 1 1012 0
 2340 005c 4FF00403 		mov	r3, #4
 2341 0060 0EE0     		b	.L196
 2342              	.L195:
1013:../Sources/drivers/mcg/mcg.c ****         }
1014:../Sources/drivers/mcg/mcg.c **** 
1015:../Sources/drivers/mcg/mcg.c ****     // To move from FBE to BLPE the LP bit must be set
1016:../Sources/drivers/mcg/mcg.c ****     MCG_C2 |= MCG_C2_LP_MASK;   // set LP bit
 2343              		.loc 1 1016 0
 2344 0062 4FF48043 		mov	r3, #16384
 2345 0066 C4F20603 		movt	r3, 16390
 2346 006a 4FF48042 		mov	r2, #16384
 2347 006e C4F20602 		movt	r2, 16390
 2348 0072 5278     		ldrb	r2, [r2, #1]
 2349 0074 D2B2     		uxtb	r2, r2
 2350 0076 42F00202 		orr	r2, r2, #2
 2351 007a D2B2     		uxtb	r2, r2
 2352 007c 5A70     		strb	r2, [r3, #1]
1017:../Sources/drivers/mcg/mcg.c ****     // now in FBE mode
1018:../Sources/drivers/mcg/mcg.c ****     return crystal_val;         // MCGOUT frequency equals external clock frequency
 2353              		.loc 1 1018 0
 2354 007e 7B68     		ldr	r3, [r7, #4]
 2355              	.L196:
1019:../Sources/drivers/mcg/mcg.c **** }   // fbe_blpe
 2356              		.loc 1 1019 0
 2357 0080 1846     		mov	r0, r3
 2358 0082 07F10C07 		add	r7, r7, #12
 2359 0086 BD46     		mov	sp, r7
 2360 0088 80BC     		pop	{r7}
 2361 008a 7047     		bx	lr
 2362              		.cfi_endproc
 2363              	.LFE9:
 2365              		.section	.text.fbe_fei,"ax",%progbits
 2366              		.align	2
 2367              		.global	fbe_fei
 2368              		.thumb
 2369              		.thumb_func
 2371              	fbe_fei:
 2372              	.LFB10:
1020:../Sources/drivers/mcg/mcg.c **** 
1021:../Sources/drivers/mcg/mcg.c **** /* */
1022:../Sources/drivers/mcg/mcg.c **** 
1023:../Sources/drivers/mcg/mcg.c **** int fbe_fei
1024:../Sources/drivers/mcg/mcg.c **** (int slow_irc_freq)
1025:../Sources/drivers/mcg/mcg.c **** {
 2373              		.loc 1 1025 0
 2374              		.cfi_startproc
 2375              		@ args = 0, pretend = 0, frame = 24
 2376              		@ frame_needed = 1, uses_anonymous_args = 0
 2377 0000 80B5     		push	{r7, lr}
 2378              	.LCFI30:
 2379              		.cfi_def_cfa_offset 8
 2380              		.cfi_offset 7, -8
 2381              		.cfi_offset 14, -4
 2382 0002 86B0     		sub	sp, sp, #24
 2383              	.LCFI31:
 2384              		.cfi_def_cfa_offset 32
 2385 0004 00AF     		add	r7, sp, #0
 2386              	.LCFI32:
 2387              		.cfi_def_cfa_register 7
 2388 0006 7860     		str	r0, [r7, #4]
1026:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1027:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1028:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1029:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1030:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1031:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1032:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
1033:../Sources/drivers/mcg/mcg.c ****     short           i;
1034:../Sources/drivers/mcg/mcg.c ****     int             mcg_out;
1035:../Sources/drivers/mcg/mcg.c **** 
1036:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1037:../Sources/drivers/mcg/mcg.c **** 
1038:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1039:../Sources/drivers/mcg/mcg.c **** 
1040:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1041:../Sources/drivers/mcg/mcg.c **** 
1042:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1043:../Sources/drivers/mcg/mcg.c **** 
1044:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1045:../Sources/drivers/mcg/mcg.c **** 
1046:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1047:../Sources/drivers/mcg/mcg.c **** 
1048:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
1049:../Sources/drivers/mcg/mcg.c **** 
1050:../Sources/drivers/mcg/mcg.c ****     if
1051:../Sources/drivers/mcg/mcg.c ****     (
1052:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 2389              		.loc 1 1052 0
 2390 0008 4FF48043 		mov	r3, #16384
 2391 000c C4F20603 		movt	r3, 16390
 2392 0010 9B79     		ldrb	r3, [r3, #6]
 2393 0012 DBB2     		uxtb	r3, r3
 2394 0014 03F00C03 		and	r3, r3, #12
 2395 0018 4FEA9303 		lsr	r3, r3, #2
1051:../Sources/drivers/mcg/mcg.c ****     (
 2396              		.loc 1 1051 0
 2397 001c 022B     		cmp	r3, #2
 2398 001e 1DD1     		bne	.L198
1053:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 2399              		.loc 1 1053 0
 2400 0020 4FF48043 		mov	r3, #16384
 2401 0024 C4F20603 		movt	r3, 16390
 2402 0028 9B79     		ldrb	r3, [r3, #6]
 2403 002a DBB2     		uxtb	r3, r3
 2404 002c 03F01003 		and	r3, r3, #16
 2405 0030 002B     		cmp	r3, #0
 2406 0032 13D1     		bne	.L198
1054:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 2407              		.loc 1 1054 0
 2408 0034 4FF48043 		mov	r3, #16384
 2409 0038 C4F20603 		movt	r3, 16390
 2410 003c 9B79     		ldrb	r3, [r3, #6]
 2411 003e DBB2     		uxtb	r3, r3
 2412 0040 03F02003 		and	r3, r3, #32
 2413 0044 002B     		cmp	r3, #0
 2414 0046 09D1     		bne	.L198
1055:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 2415              		.loc 1 1055 0
 2416 0048 4FF48043 		mov	r3, #16384
 2417 004c C4F20603 		movt	r3, 16390
 2418 0050 5B78     		ldrb	r3, [r3, #1]
 2419 0052 DBB2     		uxtb	r3, r3
 2420 0054 03F00203 		and	r3, r3, #2
1052:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 2421              		.loc 1 1052 0
 2422 0058 002B     		cmp	r3, #0
 2423 005a 02D0     		beq	.L199
 2424              	.L198:
1056:../Sources/drivers/mcg/mcg.c ****          )
1057:../Sources/drivers/mcg/mcg.c ****     )                   // check MCG_C2[LP] bit is not set
1058:../Sources/drivers/mcg/mcg.c ****         {
1059:../Sources/drivers/mcg/mcg.c ****             return 0x4;     // return error code
 2425              		.loc 1 1059 0
 2426 005c 4FF00403 		mov	r3, #4
 2427 0060 8AE0     		b	.L200
 2428              	.L199:
1060:../Sources/drivers/mcg/mcg.c ****         }
1061:../Sources/drivers/mcg/mcg.c **** 
1062:../Sources/drivers/mcg/mcg.c ****     // Check IRC frequency is within spec.
1063:../Sources/drivers/mcg/mcg.c **** 
1064:../Sources/drivers/mcg/mcg.c ****     if((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 2429              		.loc 1 1064 0
 2430 0062 7A68     		ldr	r2, [r7, #4]
 2431 0064 47F61123 		movw	r3, #31249
 2432 0068 9A42     		cmp	r2, r3
 2433 006a 04DD     		ble	.L201
 2434              		.loc 1 1064 0 is_stmt 0
 2435 006c 7A68     		ldr	r2, [r7, #4]
 2436 006e 49F69703 		movw	r3, #39063
 2437 0072 9A42     		cmp	r2, r3
 2438 0074 02DD     		ble	.L202
 2439              	.L201:
1065:../Sources/drivers/mcg/mcg.c ****         {
1066:../Sources/drivers/mcg/mcg.c ****             return 0x31;
 2440              		.loc 1 1066 0 is_stmt 1
 2441 0076 4FF03103 		mov	r3, #49
 2442 007a 7DE0     		b	.L200
 2443              	.L202:
1067:../Sources/drivers/mcg/mcg.c ****         }
1068:../Sources/drivers/mcg/mcg.c **** 
1069:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
1070:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(slow_irc_freq);
 2444              		.loc 1 1070 0
 2445 007c 7868     		ldr	r0, [r7, #4]
 2446 007e FFF7FEFF 		bl	fll_freq
 2447 0082 3861     		str	r0, [r7, #16]
1071:../Sources/drivers/mcg/mcg.c **** 
1072:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 2448              		.loc 1 1072 0
 2449 0084 3B69     		ldr	r3, [r7, #16]
 2450 0086 3B2B     		cmp	r3, #59
 2451 0088 01DC     		bgt	.L203
1073:../Sources/drivers/mcg/mcg.c ****         {
1074:../Sources/drivers/mcg/mcg.c ****             return mcg_out; // If error code returned, return the code to calling function
 2452              		.loc 1 1074 0
 2453 008a 3B69     		ldr	r3, [r7, #16]
 2454 008c 74E0     		b	.L200
 2455              	.L203:
1075:../Sources/drivers/mcg/mcg.c ****         }
1076:../Sources/drivers/mcg/mcg.c **** 
1077:../Sources/drivers/mcg/mcg.c ****     // Need to make sure the clockmonitor is disabled before moving to an "internal" clock mode
1078:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;                    //This assumes OSC0 is used as the external clo
 2456              		.loc 1 1078 0
 2457 008e 4FF48043 		mov	r3, #16384
 2458 0092 C4F20603 		movt	r3, 16390
 2459 0096 4FF48042 		mov	r2, #16384
 2460 009a C4F20602 		movt	r2, 16390
 2461 009e 5279     		ldrb	r2, [r2, #5]
 2462 00a0 D2B2     		uxtb	r2, r2
 2463 00a2 22F02002 		bic	r2, r2, #32
 2464 00a6 D2B2     		uxtb	r2, r2
 2465 00a8 5A71     		strb	r2, [r3, #5]
1079:../Sources/drivers/mcg/mcg.c ****     // Move to FEI by setting CLKS to 0 and enabling the slow IRC as the FLL reference clock
1080:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 2466              		.loc 1 1080 0
 2467 00aa 4FF48043 		mov	r3, #16384
 2468 00ae C4F20603 		movt	r3, 16390
 2469 00b2 1B78     		ldrb	r3, [r3, #0]
 2470 00b4 FB73     		strb	r3, [r7, #15]
1081:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                  // clear CLKS to select FLL output
 2471              		.loc 1 1081 0
 2472 00b6 FB7B     		ldrb	r3, [r7, #15]
 2473 00b8 03F03F03 		and	r3, r3, #63
 2474 00bc FB73     		strb	r3, [r7, #15]
1082:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_IREFS_MASK;                  // select internal reference clock
 2475              		.loc 1 1082 0
 2476 00be FB7B     		ldrb	r3, [r7, #15]
 2477 00c0 43F00403 		orr	r3, r3, #4
 2478 00c4 FB73     		strb	r3, [r7, #15]
1083:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;                              // update MCG_C1
 2479              		.loc 1 1083 0
 2480 00c6 4FF48043 		mov	r3, #16384
 2481 00ca C4F20603 		movt	r3, 16390
 2482 00ce FA7B     		ldrb	r2, [r7, #15]
 2483 00d0 1A70     		strb	r2, [r3, #0]
1084:../Sources/drivers/mcg/mcg.c **** 
1085:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to set
1086:../Sources/drivers/mcg/mcg.c **** 
1087:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2484              		.loc 1 1087 0
 2485 00d2 4FF00003 		mov	r3, #0
 2486 00d6 FB82     		strh	r3, [r7, #22]	@ movhi
 2487 00d8 0DE0     		b	.L204
 2488              	.L207:
1088:../Sources/drivers/mcg/mcg.c ****         {
1089:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loo
 2489              		.loc 1 1089 0
 2490 00da 4FF48043 		mov	r3, #16384
 2491 00de C4F20603 		movt	r3, 16390
 2492 00e2 9B79     		ldrb	r3, [r3, #6]
 2493 00e4 DBB2     		uxtb	r3, r3
 2494 00e6 03F01003 		and	r3, r3, #16
 2495 00ea 002B     		cmp	r3, #0
 2496 00ec 0AD1     		bne	.L214
 2497              	.L205:
1087:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2498              		.loc 1 1087 0
 2499 00ee FB8A     		ldrh	r3, [r7, #22]	@ movhi
 2500 00f0 03F10103 		add	r3, r3, #1
 2501 00f4 FB82     		strh	r3, [r7, #22]	@ movhi
 2502              	.L204:
1087:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2503              		.loc 1 1087 0 is_stmt 0
 2504 00f6 B7F91620 		ldrsh	r2, [r7, #22]
 2505 00fa 40F2CF73 		movw	r3, #1999
 2506 00fe 9A42     		cmp	r2, r3
 2507 0100 EBDD     		ble	.L207
 2508 0102 00E0     		b	.L206
 2509              	.L214:
 2510              		.loc 1 1089 0 is_stmt 1
 2511 0104 00BF     		nop
 2512              	.L206:
1090:../Sources/drivers/mcg/mcg.c ****         }
1091:../Sources/drivers/mcg/mcg.c **** 
1092:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 2513              		.loc 1 1092 0
 2514 0106 4FF48043 		mov	r3, #16384
 2515 010a C4F20603 		movt	r3, 16390
 2516 010e 9B79     		ldrb	r3, [r3, #6]
 2517 0110 DBB2     		uxtb	r3, r3
 2518 0112 03F01003 		and	r3, r3, #16
 2519 0116 002B     		cmp	r3, #0
 2520 0118 02D1     		bne	.L208
 2521              		.loc 1 1092 0 is_stmt 0
 2522 011a 4FF01203 		mov	r3, #18
 2523 011e 2BE0     		b	.L200
 2524              	.L208:
1093:../Sources/drivers/mcg/mcg.c **** 
1094:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
1095:../Sources/drivers/mcg/mcg.c **** 
1096:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2525              		.loc 1 1096 0 is_stmt 1
 2526 0120 4FF00003 		mov	r3, #0
 2527 0124 FB82     		strh	r3, [r7, #22]	@ movhi
 2528 0126 0FE0     		b	.L209
 2529              	.L212:
1097:../Sources/drivers/mcg/mcg.c ****         {
1098:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out ear
 2530              		.loc 1 1098 0
 2531 0128 4FF48043 		mov	r3, #16384
 2532 012c C4F20603 		movt	r3, 16390
 2533 0130 9B79     		ldrb	r3, [r3, #6]
 2534 0132 DBB2     		uxtb	r3, r3
 2535 0134 03F00C03 		and	r3, r3, #12
 2536 0138 4FEA9303 		lsr	r3, r3, #2
 2537 013c 002B     		cmp	r3, #0
 2538 013e 0AD0     		beq	.L215
 2539              	.L210:
1096:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2540              		.loc 1 1096 0
 2541 0140 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 2542 0142 03F10103 		add	r3, r3, #1
 2543 0146 FB82     		strh	r3, [r7, #22]	@ movhi
 2544              	.L209:
1096:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2545              		.loc 1 1096 0 is_stmt 0
 2546 0148 B7F91620 		ldrsh	r2, [r7, #22]
 2547 014c 40F2CF73 		movw	r3, #1999
 2548 0150 9A42     		cmp	r2, r3
 2549 0152 E9DD     		ble	.L212
 2550 0154 00E0     		b	.L211
 2551              	.L215:
 2552              		.loc 1 1098 0 is_stmt 1
 2553 0156 00BF     		nop
 2554              	.L211:
1099:../Sources/drivers/mcg/mcg.c ****         }
1100:../Sources/drivers/mcg/mcg.c **** 
1101:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check EXT CLK is
 2555              		.loc 1 1101 0
 2556 0158 4FF48043 		mov	r3, #16384
 2557 015c C4F20603 		movt	r3, 16390
 2558 0160 9B79     		ldrb	r3, [r3, #6]
 2559 0162 DBB2     		uxtb	r3, r3
 2560 0164 03F00C03 		and	r3, r3, #12
 2561 0168 4FEA9303 		lsr	r3, r3, #2
 2562 016c 002B     		cmp	r3, #0
 2563 016e 02D0     		beq	.L213
 2564              		.loc 1 1101 0 is_stmt 0
 2565 0170 4FF01803 		mov	r3, #24
 2566 0174 00E0     		b	.L200
 2567              	.L213:
1102:../Sources/drivers/mcg/mcg.c **** 
1103:../Sources/drivers/mcg/mcg.c ****     // Now in FEI mode
1104:../Sources/drivers/mcg/mcg.c ****     return mcg_out;
 2568              		.loc 1 1104 0 is_stmt 1
 2569 0176 3B69     		ldr	r3, [r7, #16]
 2570              	.L200:
1105:../Sources/drivers/mcg/mcg.c **** }   // fbe_fei
 2571              		.loc 1 1105 0
 2572 0178 1846     		mov	r0, r3
 2573 017a 07F11807 		add	r7, r7, #24
 2574 017e BD46     		mov	sp, r7
 2575 0180 80BD     		pop	{r7, pc}
 2576              		.cfi_endproc
 2577              	.LFE10:
 2579 0182 00BF     		.section	.text.fei_fbe,"ax",%progbits
 2580              		.align	2
 2581              		.global	fei_fbe
 2582              		.thumb
 2583              		.thumb_func
 2585              	fei_fbe:
 2586              	.LFB11:
1106:../Sources/drivers/mcg/mcg.c **** 
1107:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
1108:../Sources/drivers/mcg/mcg.c **** 
1109:../Sources/drivers/mcg/mcg.c **** /* Functon name : fei_fbe
1110:../Sources/drivers/mcg/mcg.c ****  *
1111:../Sources/drivers/mcg/mcg.c ****  * Mode transition: FEI to FBE mode
1112:../Sources/drivers/mcg/mcg.c ****  *
1113:../Sources/drivers/mcg/mcg.c ****  * This function transitions the MCG from FEI mode to FBE mode. This is
1114:../Sources/drivers/mcg/mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to
1115:../Sources/drivers/mcg/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1116:../Sources/drivers/mcg/mcg.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
1117:../Sources/drivers/mcg/mcg.c ****  *
1118:../Sources/drivers/mcg/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
1119:../Sources/drivers/mcg/mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
1120:../Sources/drivers/mcg/mcg.c ****  *                           for the crystal oscillator. This has no meaning if an
1121:../Sources/drivers/mcg/mcg.c ****  *                           external clock is used.
1122:../Sources/drivers/mcg/mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
1123:../Sources/drivers/mcg/mcg.c ****  *
1124:../Sources/drivers/mcg/mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
1125:../Sources/drivers/mcg/mcg.c ****  */
1126:../Sources/drivers/mcg/mcg.c **** 
1127:../Sources/drivers/mcg/mcg.c **** int fei_fbe
1128:../Sources/drivers/mcg/mcg.c **** (
1129:../Sources/drivers/mcg/mcg.c ****     int             crystal_val,
1130:../Sources/drivers/mcg/mcg.c ****     unsigned char   hgo_val,
1131:../Sources/drivers/mcg/mcg.c ****     unsigned char   erefs_val
1132:../Sources/drivers/mcg/mcg.c **** )
1133:../Sources/drivers/mcg/mcg.c **** {
 2587              		.loc 1 1133 0
 2588              		.cfi_startproc
 2589              		@ args = 0, pretend = 0, frame = 16
 2590              		@ frame_needed = 1, uses_anonymous_args = 0
 2591              		@ link register save eliminated.
 2592 0000 80B4     		push	{r7}
 2593              	.LCFI33:
 2594              		.cfi_def_cfa_offset 4
 2595              		.cfi_offset 7, -4
 2596 0002 85B0     		sub	sp, sp, #20
 2597              	.LCFI34:
 2598              		.cfi_def_cfa_offset 24
 2599 0004 00AF     		add	r7, sp, #0
 2600              	.LCFI35:
 2601              		.cfi_def_cfa_register 7
 2602 0006 7860     		str	r0, [r7, #4]
 2603 0008 1346     		mov	r3, r2
 2604 000a 0A46     		mov	r2, r1
 2605 000c FA70     		strb	r2, [r7, #3]
 2606 000e BB70     		strb	r3, [r7, #2]
1134:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1135:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1136:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1137:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1138:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1139:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1140:../Sources/drivers/mcg/mcg.c ****     unsigned char   frdiv_val;
1141:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
1142:../Sources/drivers/mcg/mcg.c ****     short           i;
1143:../Sources/drivers/mcg/mcg.c **** 
1144:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1145:../Sources/drivers/mcg/mcg.c **** 
1146:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1147:../Sources/drivers/mcg/mcg.c **** 
1148:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1149:../Sources/drivers/mcg/mcg.c **** 
1150:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1151:../Sources/drivers/mcg/mcg.c **** 
1152:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1153:../Sources/drivers/mcg/mcg.c **** 
1154:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1155:../Sources/drivers/mcg/mcg.c **** 
1156:../Sources/drivers/mcg/mcg.c ****     // check if in FEI mode
1157:../Sources/drivers/mcg/mcg.c **** 
1158:../Sources/drivers/mcg/mcg.c ****     if
1159:../Sources/drivers/mcg/mcg.c ****     (
1160:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 2607              		.loc 1 1160 0
 2608 0010 4FF48043 		mov	r3, #16384
 2609 0014 C4F20603 		movt	r3, 16390
 2610 0018 9B79     		ldrb	r3, [r3, #6]
 2611 001a DBB2     		uxtb	r3, r3
 2612 001c 03F00C03 		and	r3, r3, #12
 2613 0020 4FEA9303 		lsr	r3, r3, #2
1159:../Sources/drivers/mcg/mcg.c ****     (
 2614              		.loc 1 1159 0
 2615 0024 002B     		cmp	r3, #0
 2616 0026 13D1     		bne	.L217
1161:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
 2617              		.loc 1 1161 0
 2618 0028 4FF48043 		mov	r3, #16384
 2619 002c C4F20603 		movt	r3, 16390
 2620 0030 9B79     		ldrb	r3, [r3, #6]
 2621 0032 DBB2     		uxtb	r3, r3
 2622 0034 03F01003 		and	r3, r3, #16
 2623 0038 002B     		cmp	r3, #0
 2624 003a 09D0     		beq	.L217
1162:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))
 2625              		.loc 1 1162 0
 2626 003c 4FF48043 		mov	r3, #16384
 2627 0040 C4F20603 		movt	r3, 16390
 2628 0044 9B79     		ldrb	r3, [r3, #6]
 2629 0046 DBB2     		uxtb	r3, r3
 2630 0048 03F02003 		and	r3, r3, #32
1160:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 2631              		.loc 1 1160 0
 2632 004c 002B     		cmp	r3, #0
 2633 004e 02D0     		beq	.L218
 2634              	.L217:
1163:../Sources/drivers/mcg/mcg.c ****          )
1164:../Sources/drivers/mcg/mcg.c ****     )                       // check PLLS mux has selected FLL
1165:../Sources/drivers/mcg/mcg.c ****         {
1166:../Sources/drivers/mcg/mcg.c ****             return 0x1;         // return error code
 2635              		.loc 1 1166 0
 2636 0050 4FF00103 		mov	r3, #1
 2637 0054 5AE1     		b	.L219
 2638              	.L218:
1167:../Sources/drivers/mcg/mcg.c ****         }
1168:../Sources/drivers/mcg/mcg.c **** 
1169:../Sources/drivers/mcg/mcg.c ****     // check external frequency is less than the maximum frequency
1170:../Sources/drivers/mcg/mcg.c **** 
1171:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
 2639              		.loc 1 1171 0
 2640 0056 7A68     		ldr	r2, [r7, #4]
 2641 0058 4FF28003 		movw	r3, #61568
 2642 005c C0F2FA23 		movt	r3, 762
 2643 0060 9A42     		cmp	r2, r3
 2644 0062 02DD     		ble	.L220
1172:../Sources/drivers/mcg/mcg.c ****         {
1173:../Sources/drivers/mcg/mcg.c ****             return 0x21;
 2645              		.loc 1 1173 0
 2646 0064 4FF02103 		mov	r3, #33
 2647 0068 50E1     		b	.L219
 2648              	.L220:
1174:../Sources/drivers/mcg/mcg.c ****         }
1175:../Sources/drivers/mcg/mcg.c **** 
1176:../Sources/drivers/mcg/mcg.c ****     // check crystal frequency is within spec. if crystal osc is being used
1177:../Sources/drivers/mcg/mcg.c **** 
1178:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 2649              		.loc 1 1178 0
 2650 006a BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 2651 006c 002B     		cmp	r3, #0
 2652 006e 1AD0     		beq	.L221
1179:../Sources/drivers/mcg/mcg.c ****         {
1180:../Sources/drivers/mcg/mcg.c ****             if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crys
 2653              		.loc 1 1180 0
 2654 0070 7A68     		ldr	r2, [r7, #4]
 2655 0072 47F22F53 		movw	r3, #29999
 2656 0076 9A42     		cmp	r2, r3
 2657 0078 12DD     		ble	.L222
 2658              		.loc 1 1180 0 is_stmt 0
 2659 007a 7A68     		ldr	r2, [r7, #4]
 2660 007c 49F64043 		movw	r3, #40000
 2661 0080 9A42     		cmp	r2, r3
 2662 0082 06DD     		ble	.L223
 2663 0084 7A68     		ldr	r2, [r7, #4]
 2664 0086 4CF2BF63 		movw	r3, #50879
 2665 008a C0F22D03 		movt	r3, 45
 2666 008e 9A42     		cmp	r2, r3
 2667 0090 06DD     		ble	.L222
 2668              	.L223:
 2669              		.loc 1 1180 0
 2670 0092 7A68     		ldr	r2, [r7, #4]
 2671 0094 4FF49043 		mov	r3, #18432
 2672 0098 C0F2E813 		movt	r3, 488
 2673 009c 9A42     		cmp	r2, r3
 2674 009e 02DD     		ble	.L221
 2675              	.L222:
1181:../Sources/drivers/mcg/mcg.c ****                 {
1182:../Sources/drivers/mcg/mcg.c ****                     return 0x22;    // return error if one of the available crystal options is not 
 2676              		.loc 1 1182 0 is_stmt 1
 2677 00a0 4FF02203 		mov	r3, #34
 2678 00a4 32E1     		b	.L219
 2679              	.L221:
1183:../Sources/drivers/mcg/mcg.c ****                 }
1184:../Sources/drivers/mcg/mcg.c ****         }
1185:../Sources/drivers/mcg/mcg.c **** 
1186:../Sources/drivers/mcg/mcg.c ****     // make sure HGO will never be greater than 1. Could return an error instead if desired.
1187:../Sources/drivers/mcg/mcg.c **** 
1188:../Sources/drivers/mcg/mcg.c ****     if(hgo_val > 0)
 2680              		.loc 1 1188 0
 2681 00a6 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2682 00a8 002B     		cmp	r3, #0
 2683 00aa 02D0     		beq	.L224
1189:../Sources/drivers/mcg/mcg.c ****         {
1190:../Sources/drivers/mcg/mcg.c ****             hgo_val = 1;        // force hgo_val to 1 if > 0
 2684              		.loc 1 1190 0
 2685 00ac 4FF00103 		mov	r3, #1
 2686 00b0 FB70     		strb	r3, [r7, #3]
 2687              	.L224:
1191:../Sources/drivers/mcg/mcg.c ****         }
1192:../Sources/drivers/mcg/mcg.c **** 
1193:../Sources/drivers/mcg/mcg.c ****     // configure the MCG_C2 register
1194:../Sources/drivers/mcg/mcg.c ****     // the RANGE value is determined by the external frequency. Since the RANGE parameter affects t
1195:../Sources/drivers/mcg/mcg.c ****     // it still needs to be set correctly even if the oscillator is not being used
1196:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 2688              		.loc 1 1196 0
 2689 00b2 4FF48043 		mov	r3, #16384
 2690 00b6 C4F20603 		movt	r3, 16390
 2691 00ba 5B78     		ldrb	r3, [r3, #1]
 2692 00bc BB73     		strb	r3, [r7, #14]
1197:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 2693              		.loc 1 1197 0
 2694 00be BB7B     		ldrb	r3, [r7, #14]
 2695 00c0 23F03C03 		bic	r3, r3, #60
 2696 00c4 BB73     		strb	r3, [r7, #14]
1198:../Sources/drivers/mcg/mcg.c **** 
1199:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 2697              		.loc 1 1199 0
 2698 00c6 7A68     		ldr	r2, [r7, #4]
 2699 00c8 49F64043 		movw	r3, #40000
 2700 00cc 9A42     		cmp	r2, r3
 2701 00ce 0DDC     		bgt	.L225
1200:../Sources/drivers/mcg/mcg.c ****         {
1201:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 2702              		.loc 1 1201 0
 2703 00d0 FB78     		ldrb	r3, [r7, #3]
 2704 00d2 4FEAC303 		lsl	r3, r3, #3
 2705 00d6 DAB2     		uxtb	r2, r3
 2706 00d8 BB78     		ldrb	r3, [r7, #2]
 2707 00da 4FEA8303 		lsl	r3, r3, #2
 2708 00de DBB2     		uxtb	r3, r3
 2709 00e0 1343     		orrs	r3, r3, r2
 2710 00e2 DAB2     		uxtb	r2, r3
 2711 00e4 BB7B     		ldrb	r3, [r7, #14]
 2712 00e6 1343     		orrs	r3, r3, r2
 2713 00e8 BB73     		strb	r3, [r7, #14]
 2714 00ea 27E0     		b	.L226
 2715              	.L225:
1202:../Sources/drivers/mcg/mcg.c ****         }
1203:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
 2716              		.loc 1 1203 0
 2717 00ec 7A68     		ldr	r2, [r7, #4]
 2718 00ee 4FF49053 		mov	r3, #4608
 2719 00f2 C0F27A03 		movt	r3, 122
 2720 00f6 9A42     		cmp	r2, r3
 2721 00f8 10DC     		bgt	.L227
1204:../Sources/drivers/mcg/mcg.c ****         {
1205:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 2722              		.loc 1 1205 0
 2723 00fa FB78     		ldrb	r3, [r7, #3]
 2724 00fc 4FEAC303 		lsl	r3, r3, #3
 2725 0100 DAB2     		uxtb	r2, r3
 2726 0102 BB78     		ldrb	r3, [r7, #2]
 2727 0104 4FEA8303 		lsl	r3, r3, #2
 2728 0108 DBB2     		uxtb	r3, r3
 2729 010a 1343     		orrs	r3, r3, r2
 2730 010c DAB2     		uxtb	r2, r3
 2731 010e BB7B     		ldrb	r3, [r7, #14]
 2732 0110 1343     		orrs	r3, r3, r2
 2733 0112 DBB2     		uxtb	r3, r3
 2734 0114 43F01003 		orr	r3, r3, #16
 2735 0118 BB73     		strb	r3, [r7, #14]
 2736 011a 0FE0     		b	.L226
 2737              	.L227:
1206:../Sources/drivers/mcg/mcg.c ****         }
1207:../Sources/drivers/mcg/mcg.c ****     else
1208:../Sources/drivers/mcg/mcg.c ****         {
1209:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 2738              		.loc 1 1209 0
 2739 011c FB78     		ldrb	r3, [r7, #3]
 2740 011e 4FEAC303 		lsl	r3, r3, #3
 2741 0122 DAB2     		uxtb	r2, r3
 2742 0124 BB78     		ldrb	r3, [r7, #2]
 2743 0126 4FEA8303 		lsl	r3, r3, #2
 2744 012a DBB2     		uxtb	r3, r3
 2745 012c 1343     		orrs	r3, r3, r2
 2746 012e DAB2     		uxtb	r2, r3
 2747 0130 BB7B     		ldrb	r3, [r7, #14]
 2748 0132 1343     		orrs	r3, r3, r2
 2749 0134 DBB2     		uxtb	r3, r3
 2750 0136 43F02003 		orr	r3, r3, #32
 2751 013a BB73     		strb	r3, [r7, #14]
 2752              	.L226:
1210:../Sources/drivers/mcg/mcg.c ****         }
1211:../Sources/drivers/mcg/mcg.c **** 
1212:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 2753              		.loc 1 1212 0
 2754 013c 4FF48043 		mov	r3, #16384
 2755 0140 C4F20603 		movt	r3, 16390
 2756 0144 BA7B     		ldrb	r2, [r7, #14]
 2757 0146 5A70     		strb	r2, [r3, #1]
1213:../Sources/drivers/mcg/mcg.c **** 
1214:../Sources/drivers/mcg/mcg.c ****     // determine FRDIV based on reference clock frequency
1215:../Sources/drivers/mcg/mcg.c ****     // since the external frequency has already been checked only the maximum frequency for each FR
1216:../Sources/drivers/mcg/mcg.c **** 
1217:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 2758              		.loc 1 1217 0
 2759 0148 7A68     		ldr	r2, [r7, #4]
 2760 014a 41F2D023 		movw	r3, #4816
 2761 014e C0F21303 		movt	r3, 19
 2762 0152 9A42     		cmp	r2, r3
 2763 0154 03DC     		bgt	.L228
1218:../Sources/drivers/mcg/mcg.c ****         {
1219:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 0;
 2764              		.loc 1 1219 0
 2765 0156 4FF00003 		mov	r3, #0
 2766 015a FB73     		strb	r3, [r7, #15]
 2767 015c 2EE0     		b	.L229
 2768              	.L228:
1220:../Sources/drivers/mcg/mcg.c ****         }
1221:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 2769              		.loc 1 1221 0
 2770 015e 7A68     		ldr	r2, [r7, #4]
 2771 0160 42F2A053 		movw	r3, #9632
 2772 0164 C0F22603 		movt	r3, 38
 2773 0168 9A42     		cmp	r2, r3
 2774 016a 03DC     		bgt	.L230
1222:../Sources/drivers/mcg/mcg.c ****         {
1223:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 1;
 2775              		.loc 1 1223 0
 2776 016c 4FF00103 		mov	r3, #1
 2777 0170 FB73     		strb	r3, [r7, #15]
 2778 0172 23E0     		b	.L229
 2779              	.L230:
1224:../Sources/drivers/mcg/mcg.c ****         }
1225:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 2780              		.loc 1 1225 0
 2781 0174 7A68     		ldr	r2, [r7, #4]
 2782 0176 44F64033 		movw	r3, #19264
 2783 017a C0F24C03 		movt	r3, 76
 2784 017e 9A42     		cmp	r2, r3
 2785 0180 03DC     		bgt	.L231
1226:../Sources/drivers/mcg/mcg.c ****         {
1227:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 2;
 2786              		.loc 1 1227 0
 2787 0182 4FF00203 		mov	r3, #2
 2788 0186 FB73     		strb	r3, [r7, #15]
 2789 0188 18E0     		b	.L229
 2790              	.L231:
1228:../Sources/drivers/mcg/mcg.c ****         }
1229:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 2791              		.loc 1 1229 0
 2792 018a 7A68     		ldr	r2, [r7, #4]
 2793 018c 49F28063 		movw	r3, #38528
 2794 0190 C0F29803 		movt	r3, 152
 2795 0194 9A42     		cmp	r2, r3
 2796 0196 03DC     		bgt	.L232
1230:../Sources/drivers/mcg/mcg.c ****         {
1231:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 3;
 2797              		.loc 1 1231 0
 2798 0198 4FF00303 		mov	r3, #3
 2799 019c FB73     		strb	r3, [r7, #15]
 2800 019e 0DE0     		b	.L229
 2801              	.L232:
1232:../Sources/drivers/mcg/mcg.c ****         }
1233:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 2802              		.loc 1 1233 0
 2803 01a0 7A68     		ldr	r2, [r7, #4]
 2804 01a2 4FF43453 		mov	r3, #11520
 2805 01a6 C0F23113 		movt	r3, 305
 2806 01aa 9A42     		cmp	r2, r3
 2807 01ac 03DC     		bgt	.L233
1234:../Sources/drivers/mcg/mcg.c ****         {
1235:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 4;
 2808              		.loc 1 1235 0
 2809 01ae 4FF00403 		mov	r3, #4
 2810 01b2 FB73     		strb	r3, [r7, #15]
 2811 01b4 02E0     		b	.L229
 2812              	.L233:
1236:../Sources/drivers/mcg/mcg.c ****         }
1237:../Sources/drivers/mcg/mcg.c ****     else
1238:../Sources/drivers/mcg/mcg.c ****         {
1239:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 5;
 2813              		.loc 1 1239 0
 2814 01b6 4FF00503 		mov	r3, #5
 2815 01ba FB73     		strb	r3, [r7, #15]
 2816              	.L229:
1240:../Sources/drivers/mcg/mcg.c ****         }
1241:../Sources/drivers/mcg/mcg.c **** 
1242:../Sources/drivers/mcg/mcg.c ****     // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1243:../Sources/drivers/mcg/mcg.c ****     // If IRCLK is required it must be enabled outside of this driver, existing state will be maint
1244:../Sources/drivers/mcg/mcg.c ****     // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1245:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 2817              		.loc 1 1245 0
 2818 01bc 4FF48043 		mov	r3, #16384
 2819 01c0 C4F20603 		movt	r3, 16390
 2820 01c4 1B78     		ldrb	r3, [r3, #0]
 2821 01c6 BB73     		strb	r3, [r7, #14]
1246:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
 2822              		.loc 1 1246 0
 2823 01c8 BB7B     		ldrb	r3, [r7, #14]
 2824 01ca 03F00303 		and	r3, r3, #3
 2825 01ce BB73     		strb	r3, [r7, #14]
1247:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 2826              		.loc 1 1247 0
 2827 01d0 FB7B     		ldrb	r3, [r7, #15]
 2828 01d2 4FEAC303 		lsl	r3, r3, #3
 2829 01d6 DBB2     		uxtb	r3, r3
 2830 01d8 03F03803 		and	r3, r3, #56
 2831 01dc DAB2     		uxtb	r2, r3
 2832 01de BB7B     		ldrb	r3, [r7, #14]
 2833 01e0 1343     		orrs	r3, r3, r2
 2834 01e2 DBB2     		uxtb	r3, r3
 2835 01e4 63F07F03 		orn	r3, r3, #127
 2836 01e8 BB73     		strb	r3, [r7, #14]
1248:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 2837              		.loc 1 1248 0
 2838 01ea 4FF48043 		mov	r3, #16384
 2839 01ee C4F20603 		movt	r3, 16390
 2840 01f2 BA7B     		ldrb	r2, [r7, #14]
 2841 01f4 1A70     		strb	r2, [r3, #0]
1249:../Sources/drivers/mcg/mcg.c **** 
1250:../Sources/drivers/mcg/mcg.c ****     // if the external oscillator is used need to wait for OSCINIT to set
1251:../Sources/drivers/mcg/mcg.c **** 
1252:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 2842              		.loc 1 1252 0
 2843 01f6 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 2844 01f8 002B     		cmp	r3, #0
 2845 01fa 26D0     		beq	.L234
1253:../Sources/drivers/mcg/mcg.c ****         {
1254:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 10000; i++)
 2846              		.loc 1 1254 0
 2847 01fc 4FF00003 		mov	r3, #0
 2848 0200 BB81     		strh	r3, [r7, #12]	@ movhi
 2849 0202 0DE0     		b	.L235
 2850              	.L238:
1255:../Sources/drivers/mcg/mcg.c ****                 {
1256:../Sources/drivers/mcg/mcg.c ****                     if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out ear
 2851              		.loc 1 1256 0
 2852 0204 4FF48043 		mov	r3, #16384
 2853 0208 C4F20603 		movt	r3, 16390
 2854 020c 9B79     		ldrb	r3, [r3, #6]
 2855 020e DBB2     		uxtb	r3, r3
 2856 0210 03F00203 		and	r3, r3, #2
 2857 0214 002B     		cmp	r3, #0
 2858 0216 0AD1     		bne	.L249
 2859              	.L236:
1254:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 10000; i++)
 2860              		.loc 1 1254 0
 2861 0218 BB89     		ldrh	r3, [r7, #12]	@ movhi
 2862 021a 03F10103 		add	r3, r3, #1
 2863 021e BB81     		strh	r3, [r7, #12]	@ movhi
 2864              	.L235:
1254:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 10000; i++)
 2865              		.loc 1 1254 0 is_stmt 0
 2866 0220 B7F90C20 		ldrsh	r2, [r7, #12]
 2867 0224 42F20F73 		movw	r3, #9999
 2868 0228 9A42     		cmp	r2, r3
 2869 022a EBDD     		ble	.L238
 2870 022c 00E0     		b	.L237
 2871              	.L249:
 2872              		.loc 1 1256 0 is_stmt 1
 2873 022e 00BF     		nop
 2874              	.L237:
1257:../Sources/drivers/mcg/mcg.c ****                 }
1258:../Sources/drivers/mcg/mcg.c **** 
1259:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is rea
 2875              		.loc 1 1259 0
 2876 0230 4FF48043 		mov	r3, #16384
 2877 0234 C4F20603 		movt	r3, 16390
 2878 0238 9B79     		ldrb	r3, [r3, #6]
 2879 023a DBB2     		uxtb	r3, r3
 2880 023c 03F00203 		and	r3, r3, #2
 2881 0240 002B     		cmp	r3, #0
 2882 0242 02D1     		bne	.L234
 2883              		.loc 1 1259 0 is_stmt 0
 2884 0244 4FF02303 		mov	r3, #35
 2885 0248 60E0     		b	.L219
 2886              	.L234:
1260:../Sources/drivers/mcg/mcg.c ****         }
1261:../Sources/drivers/mcg/mcg.c **** 
1262:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
1263:../Sources/drivers/mcg/mcg.c **** 
1264:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2887              		.loc 1 1264 0 is_stmt 1
 2888 024a 4FF00003 		mov	r3, #0
 2889 024e BB81     		strh	r3, [r7, #12]	@ movhi
 2890 0250 0DE0     		b	.L239
 2891              	.L242:
1265:../Sources/drivers/mcg/mcg.c ****         {
1266:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early i
 2892              		.loc 1 1266 0
 2893 0252 4FF48043 		mov	r3, #16384
 2894 0256 C4F20603 		movt	r3, 16390
 2895 025a 9B79     		ldrb	r3, [r3, #6]
 2896 025c DBB2     		uxtb	r3, r3
 2897 025e 03F01003 		and	r3, r3, #16
 2898 0262 002B     		cmp	r3, #0
 2899 0264 0AD0     		beq	.L250
 2900              	.L240:
1264:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2901              		.loc 1 1264 0
 2902 0266 BB89     		ldrh	r3, [r7, #12]	@ movhi
 2903 0268 03F10103 		add	r3, r3, #1
 2904 026c BB81     		strh	r3, [r7, #12]	@ movhi
 2905              	.L239:
1264:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2906              		.loc 1 1264 0 is_stmt 0
 2907 026e B7F90C20 		ldrsh	r2, [r7, #12]
 2908 0272 40F2CF73 		movw	r3, #1999
 2909 0276 9A42     		cmp	r2, r3
 2910 0278 EBDD     		ble	.L242
 2911 027a 00E0     		b	.L241
 2912              	.L250:
 2913              		.loc 1 1266 0 is_stmt 1
 2914 027c 00BF     		nop
 2915              	.L241:
1267:../Sources/drivers/mcg/mcg.c ****         }
1268:../Sources/drivers/mcg/mcg.c **** 
1269:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 2916              		.loc 1 1269 0
 2917 027e 4FF48043 		mov	r3, #16384
 2918 0282 C4F20603 		movt	r3, 16390
 2919 0286 9B79     		ldrb	r3, [r3, #6]
 2920 0288 DBB2     		uxtb	r3, r3
 2921 028a 03F01003 		and	r3, r3, #16
 2922 028e 002B     		cmp	r3, #0
 2923 0290 02D0     		beq	.L243
 2924              		.loc 1 1269 0 is_stmt 0
 2925 0292 4FF01103 		mov	r3, #17
 2926 0296 39E0     		b	.L219
 2927              	.L243:
1270:../Sources/drivers/mcg/mcg.c **** 
1271:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
1272:../Sources/drivers/mcg/mcg.c **** 
1273:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2928              		.loc 1 1273 0 is_stmt 1
 2929 0298 4FF00003 		mov	r3, #0
 2930 029c BB81     		strh	r3, [r7, #12]	@ movhi
 2931 029e 0FE0     		b	.L244
 2932              	.L247:
1274:../Sources/drivers/mcg/mcg.c ****         {
1275:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early i
 2933              		.loc 1 1275 0
 2934 02a0 4FF48043 		mov	r3, #16384
 2935 02a4 C4F20603 		movt	r3, 16390
 2936 02a8 9B79     		ldrb	r3, [r3, #6]
 2937 02aa DBB2     		uxtb	r3, r3
 2938 02ac 03F00C03 		and	r3, r3, #12
 2939 02b0 4FEA9303 		lsr	r3, r3, #2
 2940 02b4 022B     		cmp	r3, #2
 2941 02b6 0AD0     		beq	.L251
 2942              	.L245:
1273:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2943              		.loc 1 1273 0
 2944 02b8 BB89     		ldrh	r3, [r7, #12]	@ movhi
 2945 02ba 03F10103 		add	r3, r3, #1
 2946 02be BB81     		strh	r3, [r7, #12]	@ movhi
 2947              	.L244:
1273:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2948              		.loc 1 1273 0 is_stmt 0
 2949 02c0 B7F90C20 		ldrsh	r2, [r7, #12]
 2950 02c4 40F2CF73 		movw	r3, #1999
 2951 02c8 9A42     		cmp	r2, r3
 2952 02ca E9DD     		ble	.L247
 2953 02cc 00E0     		b	.L246
 2954              	.L251:
 2955              		.loc 1 1275 0 is_stmt 1
 2956 02ce 00BF     		nop
 2957              	.L246:
1276:../Sources/drivers/mcg/mcg.c ****         }
1277:../Sources/drivers/mcg/mcg.c **** 
1278:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 2958              		.loc 1 1278 0
 2959 02d0 4FF48043 		mov	r3, #16384
 2960 02d4 C4F20603 		movt	r3, 16390
 2961 02d8 9B79     		ldrb	r3, [r3, #6]
 2962 02da DBB2     		uxtb	r3, r3
 2963 02dc 03F00C03 		and	r3, r3, #12
 2964 02e0 4FEA9303 		lsr	r3, r3, #2
 2965 02e4 022B     		cmp	r3, #2
 2966 02e6 02D0     		beq	.L248
 2967              		.loc 1 1278 0 is_stmt 0
 2968 02e8 4FF01A03 		mov	r3, #26
 2969 02ec 0EE0     		b	.L219
 2970              	.L248:
1279:../Sources/drivers/mcg/mcg.c **** 
1280:../Sources/drivers/mcg/mcg.c ****     // Now in FBE
1281:../Sources/drivers/mcg/mcg.c ****     // It is recommended that the clock monitor is enabled when using an external clock as the cloc
1282:../Sources/drivers/mcg/mcg.c ****     // It is enabled here but can be removed if this is not required.
1283:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 2971              		.loc 1 1283 0 is_stmt 1
 2972 02ee 4FF48043 		mov	r3, #16384
 2973 02f2 C4F20603 		movt	r3, 16390
 2974 02f6 4FF48042 		mov	r2, #16384
 2975 02fa C4F20602 		movt	r2, 16390
 2976 02fe 5279     		ldrb	r2, [r2, #5]
 2977 0300 D2B2     		uxtb	r2, r2
 2978 0302 42F02002 		orr	r2, r2, #32
 2979 0306 D2B2     		uxtb	r2, r2
 2980 0308 5A71     		strb	r2, [r3, #5]
1284:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 2981              		.loc 1 1284 0
 2982 030a 7B68     		ldr	r3, [r7, #4]
 2983              	.L219:
1285:../Sources/drivers/mcg/mcg.c **** }                       // fei_fbe
 2984              		.loc 1 1285 0
 2985 030c 1846     		mov	r0, r3
 2986 030e 07F11407 		add	r7, r7, #20
 2987 0312 BD46     		mov	sp, r7
 2988 0314 80BC     		pop	{r7}
 2989 0316 7047     		bx	lr
 2990              		.cfi_endproc
 2991              	.LFE11:
 2993              		.section	.text.fbe_fee,"ax",%progbits
 2994              		.align	2
 2995              		.global	fbe_fee
 2996              		.thumb
 2997              		.thumb_func
 2999              	fbe_fee:
 3000              	.LFB12:
1286:../Sources/drivers/mcg/mcg.c **** 
1287:../Sources/drivers/mcg/mcg.c **** /* */
1288:../Sources/drivers/mcg/mcg.c **** 
1289:../Sources/drivers/mcg/mcg.c **** int fbe_fee
1290:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
1291:../Sources/drivers/mcg/mcg.c **** {
 3001              		.loc 1 1291 0
 3002              		.cfi_startproc
 3003              		@ args = 0, pretend = 0, frame = 16
 3004              		@ frame_needed = 1, uses_anonymous_args = 0
 3005 0000 80B5     		push	{r7, lr}
 3006              	.LCFI36:
 3007              		.cfi_def_cfa_offset 8
 3008              		.cfi_offset 7, -8
 3009              		.cfi_offset 14, -4
 3010 0002 84B0     		sub	sp, sp, #16
 3011              	.LCFI37:
 3012              		.cfi_def_cfa_offset 24
 3013 0004 00AF     		add	r7, sp, #0
 3014              	.LCFI38:
 3015              		.cfi_def_cfa_register 7
 3016 0006 7860     		str	r0, [r7, #4]
1292:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1293:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1294:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1295:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1296:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1297:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1298:../Sources/drivers/mcg/mcg.c ****     short   i, fll_ref_freq;
1299:../Sources/drivers/mcg/mcg.c ****     int     mcg_out;
1300:../Sources/drivers/mcg/mcg.c **** 
1301:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1302:../Sources/drivers/mcg/mcg.c **** 
1303:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1304:../Sources/drivers/mcg/mcg.c **** 
1305:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1306:../Sources/drivers/mcg/mcg.c **** 
1307:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1308:../Sources/drivers/mcg/mcg.c **** 
1309:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1310:../Sources/drivers/mcg/mcg.c **** 
1311:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1312:../Sources/drivers/mcg/mcg.c **** 
1313:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
1314:../Sources/drivers/mcg/mcg.c **** 
1315:../Sources/drivers/mcg/mcg.c ****     if
1316:../Sources/drivers/mcg/mcg.c ****     (
1317:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 3017              		.loc 1 1317 0
 3018 0008 4FF48043 		mov	r3, #16384
 3019 000c C4F20603 		movt	r3, 16390
 3020 0010 9B79     		ldrb	r3, [r3, #6]
 3021 0012 DBB2     		uxtb	r3, r3
 3022 0014 03F00C03 		and	r3, r3, #12
 3023 0018 4FEA9303 		lsr	r3, r3, #2
1316:../Sources/drivers/mcg/mcg.c ****     (
 3024              		.loc 1 1316 0
 3025 001c 022B     		cmp	r3, #2
 3026 001e 1DD1     		bne	.L253
1318:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 3027              		.loc 1 1318 0
 3028 0020 4FF48043 		mov	r3, #16384
 3029 0024 C4F20603 		movt	r3, 16390
 3030 0028 9B79     		ldrb	r3, [r3, #6]
 3031 002a DBB2     		uxtb	r3, r3
 3032 002c 03F01003 		and	r3, r3, #16
 3033 0030 002B     		cmp	r3, #0
 3034 0032 13D1     		bne	.L253
1319:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 3035              		.loc 1 1319 0
 3036 0034 4FF48043 		mov	r3, #16384
 3037 0038 C4F20603 		movt	r3, 16390
 3038 003c 9B79     		ldrb	r3, [r3, #6]
 3039 003e DBB2     		uxtb	r3, r3
 3040 0040 03F02003 		and	r3, r3, #32
 3041 0044 002B     		cmp	r3, #0
 3042 0046 09D1     		bne	.L253
1320:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 3043              		.loc 1 1320 0
 3044 0048 4FF48043 		mov	r3, #16384
 3045 004c C4F20603 		movt	r3, 16390
 3046 0050 5B78     		ldrb	r3, [r3, #1]
 3047 0052 DBB2     		uxtb	r3, r3
 3048 0054 03F00203 		and	r3, r3, #2
1317:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 3049              		.loc 1 1317 0
 3050 0058 002B     		cmp	r3, #0
 3051 005a 02D0     		beq	.L254
 3052              	.L253:
1321:../Sources/drivers/mcg/mcg.c ****          )
1322:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
1323:../Sources/drivers/mcg/mcg.c ****         {
1324:../Sources/drivers/mcg/mcg.c ****             return 0x4; // return error code
 3053              		.loc 1 1324 0
 3054 005c 4FF00403 		mov	r3, #4
 3055 0060 75E0     		b	.L255
 3056              	.L254:
1325:../Sources/drivers/mcg/mcg.c ****         }
1326:../Sources/drivers/mcg/mcg.c **** 
1327:../Sources/drivers/mcg/mcg.c ****     // The FLL ref clk divide value depends on FRDIV and the RANGE value
1328:../Sources/drivers/mcg/mcg.c **** 
1329:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 3057              		.loc 1 1329 0
 3058 0062 4FF48043 		mov	r3, #16384
 3059 0066 C4F20603 		movt	r3, 16390
 3060 006a 5B78     		ldrb	r3, [r3, #1]
 3061 006c DBB2     		uxtb	r3, r3
 3062 006e 03F03003 		and	r3, r3, #48
 3063 0072 4FEA1313 		lsr	r3, r3, #4
 3064 0076 002B     		cmp	r3, #0
 3065 0078 12D0     		beq	.L256
1330:../Sources/drivers/mcg/mcg.c ****         {
1331:../Sources/drivers/mcg/mcg.c ****             fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIF
 3066              		.loc 1 1331 0
 3067 007a 4FF48043 		mov	r3, #16384
 3068 007e C4F20603 		movt	r3, 16390
 3069 0082 1B78     		ldrb	r3, [r3, #0]
 3070 0084 DBB2     		uxtb	r3, r3
 3071 0086 03F03803 		and	r3, r3, #56
 3072 008a 4FEAD303 		lsr	r3, r3, #3
 3073 008e 4FF02002 		mov	r2, #32
 3074 0092 02FA03F3 		lsl	r3, r2, r3
 3075 0096 7A68     		ldr	r2, [r7, #4]
 3076 0098 92FBF3F3 		sdiv	r3, r2, r3
 3077 009c BB81     		strh	r3, [r7, #12]	@ movhi
 3078 009e 11E0     		b	.L257
 3079              	.L256:
1332:../Sources/drivers/mcg/mcg.c ****         }
1333:../Sources/drivers/mcg/mcg.c ****     else
1334:../Sources/drivers/mcg/mcg.c ****         {
1335:../Sources/drivers/mcg/mcg.c ****             fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_
 3080              		.loc 1 1335 0
 3081 00a0 4FF48043 		mov	r3, #16384
 3082 00a4 C4F20603 		movt	r3, 16390
 3083 00a8 5B78     		ldrb	r3, [r3, #1]
 3084 00aa DBB2     		uxtb	r3, r3
 3085 00ac 03F03003 		and	r3, r3, #48
 3086 00b0 4FEA1313 		lsr	r3, r3, #4
 3087 00b4 4FF00102 		mov	r2, #1
 3088 00b8 02FA03F3 		lsl	r3, r2, r3
 3089 00bc 7A68     		ldr	r2, [r7, #4]
 3090 00be 92FBF3F3 		sdiv	r3, r2, r3
 3091 00c2 BB81     		strh	r3, [r7, #12]	@ movhi
 3092              	.L257:
1336:../Sources/drivers/mcg/mcg.c ****         }
1337:../Sources/drivers/mcg/mcg.c **** 
1338:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
1339:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
 3093              		.loc 1 1339 0
 3094 00c4 B7F90C30 		ldrsh	r3, [r7, #12]
 3095 00c8 1846     		mov	r0, r3
 3096 00ca FFF7FEFF 		bl	fll_freq
 3097 00ce B860     		str	r0, [r7, #8]
1340:../Sources/drivers/mcg/mcg.c **** 
1341:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 3098              		.loc 1 1341 0
 3099 00d0 BB68     		ldr	r3, [r7, #8]
 3100 00d2 3B2B     		cmp	r3, #59
 3101 00d4 01DC     		bgt	.L258
1342:../Sources/drivers/mcg/mcg.c ****         {
1343:../Sources/drivers/mcg/mcg.c ****             return mcg_out;                 // If error code returned, return the code to calling f
 3102              		.loc 1 1343 0
 3103 00d6 BB68     		ldr	r3, [r7, #8]
 3104 00d8 39E0     		b	.L255
 3105              	.L258:
1344:../Sources/drivers/mcg/mcg.c ****         }
1345:../Sources/drivers/mcg/mcg.c **** 
1346:../Sources/drivers/mcg/mcg.c ****     // Clear CLKS field to switch CLKS mux to select FLL output
1347:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;        // clear CLKS to select FLL output
 3106              		.loc 1 1347 0
 3107 00da 4FF48043 		mov	r3, #16384
 3108 00de C4F20603 		movt	r3, 16390
 3109 00e2 4FF48042 		mov	r2, #16384
 3110 00e6 C4F20602 		movt	r2, 16390
 3111 00ea 1278     		ldrb	r2, [r2, #0]
 3112 00ec D2B2     		uxtb	r2, r2
 3113 00ee 02F03F02 		and	r2, r2, #63
 3114 00f2 D2B2     		uxtb	r2, r2
 3115 00f4 1A70     		strb	r2, [r3, #0]
1348:../Sources/drivers/mcg/mcg.c **** 
1349:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is FLL
1350:../Sources/drivers/mcg/mcg.c **** 
1351:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3116              		.loc 1 1351 0
 3117 00f6 4FF00003 		mov	r3, #0
 3118 00fa FB81     		strh	r3, [r7, #14]	@ movhi
 3119 00fc 0FE0     		b	.L259
 3120              	.L262:
1352:../Sources/drivers/mcg/mcg.c ****         {
1353:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out ear
 3121              		.loc 1 1353 0
 3122 00fe 4FF48043 		mov	r3, #16384
 3123 0102 C4F20603 		movt	r3, 16390
 3124 0106 9B79     		ldrb	r3, [r3, #6]
 3125 0108 DBB2     		uxtb	r3, r3
 3126 010a 03F00C03 		and	r3, r3, #12
 3127 010e 4FEA9303 		lsr	r3, r3, #2
 3128 0112 002B     		cmp	r3, #0
 3129 0114 0AD0     		beq	.L264
 3130              	.L260:
1351:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3131              		.loc 1 1351 0
 3132 0116 FB89     		ldrh	r3, [r7, #14]	@ movhi
 3133 0118 03F10103 		add	r3, r3, #1
 3134 011c FB81     		strh	r3, [r7, #14]	@ movhi
 3135              	.L259:
1351:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3136              		.loc 1 1351 0 is_stmt 0
 3137 011e B7F90E20 		ldrsh	r2, [r7, #14]
 3138 0122 40F2CF73 		movw	r3, #1999
 3139 0126 9A42     		cmp	r2, r3
 3140 0128 E9DD     		ble	.L262
 3141 012a 00E0     		b	.L261
 3142              	.L264:
 3143              		.loc 1 1353 0 is_stmt 1
 3144 012c 00BF     		nop
 3145              	.L261:
1354:../Sources/drivers/mcg/mcg.c ****         }
1355:../Sources/drivers/mcg/mcg.c **** 
1356:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check FLL is rea
 3146              		.loc 1 1356 0
 3147 012e 4FF48043 		mov	r3, #16384
 3148 0132 C4F20603 		movt	r3, 16390
 3149 0136 9B79     		ldrb	r3, [r3, #6]
 3150 0138 DBB2     		uxtb	r3, r3
 3151 013a 03F00C03 		and	r3, r3, #12
 3152 013e 4FEA9303 		lsr	r3, r3, #2
 3153 0142 002B     		cmp	r3, #0
 3154 0144 02D0     		beq	.L263
 3155              		.loc 1 1356 0 is_stmt 0
 3156 0146 4FF01803 		mov	r3, #24
 3157 014a 00E0     		b	.L255
 3158              	.L263:
1357:../Sources/drivers/mcg/mcg.c **** 
1358:../Sources/drivers/mcg/mcg.c ****     // Now in FEE mode
1359:../Sources/drivers/mcg/mcg.c ****     return mcg_out;
 3159              		.loc 1 1359 0 is_stmt 1
 3160 014c BB68     		ldr	r3, [r7, #8]
 3161              	.L255:
1360:../Sources/drivers/mcg/mcg.c **** }   // fbe_fee
 3162              		.loc 1 1360 0
 3163 014e 1846     		mov	r0, r3
 3164 0150 07F11007 		add	r7, r7, #16
 3165 0154 BD46     		mov	sp, r7
 3166 0156 80BD     		pop	{r7, pc}
 3167              		.cfi_endproc
 3168              	.LFE12:
 3170              		.section	.text.fee_fbe,"ax",%progbits
 3171              		.align	2
 3172              		.global	fee_fbe
 3173              		.thumb
 3174              		.thumb_func
 3176              	fee_fbe:
 3177              	.LFB13:
1361:../Sources/drivers/mcg/mcg.c **** 
1362:../Sources/drivers/mcg/mcg.c **** /* */
1363:../Sources/drivers/mcg/mcg.c **** 
1364:../Sources/drivers/mcg/mcg.c **** int fee_fbe
1365:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
1366:../Sources/drivers/mcg/mcg.c **** {
 3178              		.loc 1 1366 0
 3179              		.cfi_startproc
 3180              		@ args = 0, pretend = 0, frame = 16
 3181              		@ frame_needed = 1, uses_anonymous_args = 0
 3182              		@ link register save eliminated.
 3183 0000 80B4     		push	{r7}
 3184              	.LCFI39:
 3185              		.cfi_def_cfa_offset 4
 3186              		.cfi_offset 7, -4
 3187 0002 85B0     		sub	sp, sp, #20
 3188              	.LCFI40:
 3189              		.cfi_def_cfa_offset 24
 3190 0004 00AF     		add	r7, sp, #0
 3191              	.LCFI41:
 3192              		.cfi_def_cfa_register 7
 3193 0006 7860     		str	r0, [r7, #4]
1367:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1368:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1369:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1370:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1371:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1372:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1373:../Sources/drivers/mcg/mcg.c ****     short   i;
1374:../Sources/drivers/mcg/mcg.c **** 
1375:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1376:../Sources/drivers/mcg/mcg.c **** 
1377:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1378:../Sources/drivers/mcg/mcg.c **** 
1379:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1380:../Sources/drivers/mcg/mcg.c **** 
1381:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1382:../Sources/drivers/mcg/mcg.c **** 
1383:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1384:../Sources/drivers/mcg/mcg.c **** 
1385:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1386:../Sources/drivers/mcg/mcg.c **** 
1387:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FEE mode
1388:../Sources/drivers/mcg/mcg.c **** 
1389:../Sources/drivers/mcg/mcg.c ****     if
1390:../Sources/drivers/mcg/mcg.c ****     (
1391:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 3194              		.loc 1 1391 0
 3195 0008 4FF48043 		mov	r3, #16384
 3196 000c C4F20603 		movt	r3, 16390
 3197 0010 9B79     		ldrb	r3, [r3, #6]
 3198 0012 DBB2     		uxtb	r3, r3
 3199 0014 03F00C03 		and	r3, r3, #12
 3200 0018 4FEA9303 		lsr	r3, r3, #2
1390:../Sources/drivers/mcg/mcg.c ****     (
 3201              		.loc 1 1390 0
 3202 001c 002B     		cmp	r3, #0
 3203 001e 13D1     		bne	.L266
1392:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 3204              		.loc 1 1392 0
 3205 0020 4FF48043 		mov	r3, #16384
 3206 0024 C4F20603 		movt	r3, 16390
 3207 0028 9B79     		ldrb	r3, [r3, #6]
 3208 002a DBB2     		uxtb	r3, r3
 3209 002c 03F01003 		and	r3, r3, #16
 3210 0030 002B     		cmp	r3, #0
 3211 0032 09D1     		bne	.L266
1393:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))
 3212              		.loc 1 1393 0
 3213 0034 4FF48043 		mov	r3, #16384
 3214 0038 C4F20603 		movt	r3, 16390
 3215 003c 9B79     		ldrb	r3, [r3, #6]
 3216 003e DBB2     		uxtb	r3, r3
 3217 0040 03F02003 		and	r3, r3, #32
1391:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 3218              		.loc 1 1391 0
 3219 0044 002B     		cmp	r3, #0
 3220 0046 02D0     		beq	.L267
 3221              	.L266:
1394:../Sources/drivers/mcg/mcg.c ****          )
1395:../Sources/drivers/mcg/mcg.c ****     )               // check PLLS mux has selected FLL
1396:../Sources/drivers/mcg/mcg.c ****         {
1397:../Sources/drivers/mcg/mcg.c ****             return 0x2; // return error code
 3222              		.loc 1 1397 0
 3223 0048 4FF00203 		mov	r3, #2
 3224 004c 39E0     		b	.L268
 3225              	.L267:
1398:../Sources/drivers/mcg/mcg.c ****         }
1399:../Sources/drivers/mcg/mcg.c **** 
1400:../Sources/drivers/mcg/mcg.c ****     // Set CLKS field to 2 to switch CLKS mux to select ext ref clock
1401:../Sources/drivers/mcg/mcg.c ****     // MCG is current in FEE mode so CLKS field = 0 so can just OR in new value
1402:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(2);   // set CLKS to select ext ref clock
 3226              		.loc 1 1402 0
 3227 004e 4FF48043 		mov	r3, #16384
 3228 0052 C4F20603 		movt	r3, 16390
 3229 0056 4FF48042 		mov	r2, #16384
 3230 005a C4F20602 		movt	r2, 16390
 3231 005e 1278     		ldrb	r2, [r2, #0]
 3232 0060 D2B2     		uxtb	r2, r2
 3233 0062 62F07F02 		orn	r2, r2, #127
 3234 0066 D2B2     		uxtb	r2, r2
 3235 0068 1A70     		strb	r2, [r3, #0]
1403:../Sources/drivers/mcg/mcg.c **** 
1404:../Sources/drivers/mcg/mcg.c ****     /// Wait for clock status bits to show clock source is ext ref clk
1405:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3236              		.loc 1 1405 0
 3237 006a 4FF00003 		mov	r3, #0
 3238 006e FB81     		strh	r3, [r7, #14]	@ movhi
 3239 0070 0FE0     		b	.L269
 3240              	.L272:
1406:../Sources/drivers/mcg/mcg.c ****         {
1407:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out ear
 3241              		.loc 1 1407 0
 3242 0072 4FF48043 		mov	r3, #16384
 3243 0076 C4F20603 		movt	r3, 16390
 3244 007a 9B79     		ldrb	r3, [r3, #6]
 3245 007c DBB2     		uxtb	r3, r3
 3246 007e 03F00C03 		and	r3, r3, #12
 3247 0082 4FEA9303 		lsr	r3, r3, #2
 3248 0086 022B     		cmp	r3, #2
 3249 0088 0AD0     		beq	.L274
 3250              	.L270:
1405:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3251              		.loc 1 1405 0
 3252 008a FB89     		ldrh	r3, [r7, #14]	@ movhi
 3253 008c 03F10103 		add	r3, r3, #1
 3254 0090 FB81     		strh	r3, [r7, #14]	@ movhi
 3255              	.L269:
1405:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3256              		.loc 1 1405 0 is_stmt 0
 3257 0092 B7F90E20 		ldrsh	r2, [r7, #14]
 3258 0096 40F2CF73 		movw	r3, #1999
 3259 009a 9A42     		cmp	r2, r3
 3260 009c E9DD     		ble	.L272
 3261 009e 00E0     		b	.L271
 3262              	.L274:
 3263              		.loc 1 1407 0 is_stmt 1
 3264 00a0 00BF     		nop
 3265              	.L271:
1408:../Sources/drivers/mcg/mcg.c ****         }
1409:../Sources/drivers/mcg/mcg.c **** 
1410:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 3266              		.loc 1 1410 0
 3267 00a2 4FF48043 		mov	r3, #16384
 3268 00a6 C4F20603 		movt	r3, 16390
 3269 00aa 9B79     		ldrb	r3, [r3, #6]
 3270 00ac DBB2     		uxtb	r3, r3
 3271 00ae 03F00C03 		and	r3, r3, #12
 3272 00b2 4FEA9303 		lsr	r3, r3, #2
 3273 00b6 022B     		cmp	r3, #2
 3274 00b8 02D0     		beq	.L273
 3275              		.loc 1 1410 0 is_stmt 0
 3276 00ba 4FF01A03 		mov	r3, #26
 3277 00be 00E0     		b	.L268
 3278              	.L273:
1411:../Sources/drivers/mcg/mcg.c **** 
1412:../Sources/drivers/mcg/mcg.c ****     // Now in FBE mode
1413:../Sources/drivers/mcg/mcg.c ****     return crystal_val;
 3279              		.loc 1 1413 0 is_stmt 1
 3280 00c0 7B68     		ldr	r3, [r7, #4]
 3281              	.L268:
1414:../Sources/drivers/mcg/mcg.c **** }   // fee_fbe
 3282              		.loc 1 1414 0
 3283 00c2 1846     		mov	r0, r3
 3284 00c4 07F11407 		add	r7, r7, #20
 3285 00c8 BD46     		mov	sp, r7
 3286 00ca 80BC     		pop	{r7}
 3287 00cc 7047     		bx	lr
 3288              		.cfi_endproc
 3289              	.LFE13:
 3291 00ce 00BF     		.section	.text.fbe_fbi,"ax",%progbits
 3292              		.align	2
 3293              		.global	fbe_fbi
 3294              		.thumb
 3295              		.thumb_func
 3297              	fbe_fbi:
 3298              	.LFB14:
1415:../Sources/drivers/mcg/mcg.c **** 
1416:../Sources/drivers/mcg/mcg.c **** /* */
1417:../Sources/drivers/mcg/mcg.c **** 
1418:../Sources/drivers/mcg/mcg.c **** int fbe_fbi
1419:../Sources/drivers/mcg/mcg.c **** (
1420:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
1421:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select
1422:../Sources/drivers/mcg/mcg.c **** )
1423:../Sources/drivers/mcg/mcg.c **** {
 3299              		.loc 1 1423 0
 3300              		.cfi_startproc
 3301              		@ args = 0, pretend = 0, frame = 16
 3302              		@ frame_needed = 1, uses_anonymous_args = 0
 3303              		@ link register save eliminated.
 3304 0000 80B4     		push	{r7}
 3305              	.LCFI42:
 3306              		.cfi_def_cfa_offset 4
 3307              		.cfi_offset 7, -4
 3308 0002 85B0     		sub	sp, sp, #20
 3309              	.LCFI43:
 3310              		.cfi_def_cfa_offset 24
 3311 0004 00AF     		add	r7, sp, #0
 3312              	.LCFI44:
 3313              		.cfi_def_cfa_register 7
 3314 0006 7860     		str	r0, [r7, #4]
 3315 0008 0B46     		mov	r3, r1
 3316 000a FB70     		strb	r3, [r7, #3]
1424:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1425:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1426:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1427:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1428:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1429:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1430:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
1431:../Sources/drivers/mcg/mcg.c ****     unsigned char   fcrdiv_val;
1432:../Sources/drivers/mcg/mcg.c ****     short           i;
1433:../Sources/drivers/mcg/mcg.c **** 
1434:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1435:../Sources/drivers/mcg/mcg.c **** 
1436:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1437:../Sources/drivers/mcg/mcg.c **** 
1438:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1439:../Sources/drivers/mcg/mcg.c **** 
1440:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1441:../Sources/drivers/mcg/mcg.c **** 
1442:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1443:../Sources/drivers/mcg/mcg.c **** 
1444:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1445:../Sources/drivers/mcg/mcg.c **** 
1446:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
1447:../Sources/drivers/mcg/mcg.c **** 
1448:../Sources/drivers/mcg/mcg.c ****     if
1449:../Sources/drivers/mcg/mcg.c ****     (
1450:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 3317              		.loc 1 1450 0
 3318 000c 4FF48043 		mov	r3, #16384
 3319 0010 C4F20603 		movt	r3, 16390
 3320 0014 9B79     		ldrb	r3, [r3, #6]
 3321 0016 DBB2     		uxtb	r3, r3
 3322 0018 03F00C03 		and	r3, r3, #12
 3323 001c 4FEA9303 		lsr	r3, r3, #2
1449:../Sources/drivers/mcg/mcg.c ****     (
 3324              		.loc 1 1449 0
 3325 0020 022B     		cmp	r3, #2
 3326 0022 1DD1     		bne	.L276
1451:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 3327              		.loc 1 1451 0
 3328 0024 4FF48043 		mov	r3, #16384
 3329 0028 C4F20603 		movt	r3, 16390
 3330 002c 9B79     		ldrb	r3, [r3, #6]
 3331 002e DBB2     		uxtb	r3, r3
 3332 0030 03F01003 		and	r3, r3, #16
 3333 0034 002B     		cmp	r3, #0
 3334 0036 13D1     		bne	.L276
1452:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 3335              		.loc 1 1452 0
 3336 0038 4FF48043 		mov	r3, #16384
 3337 003c C4F20603 		movt	r3, 16390
 3338 0040 9B79     		ldrb	r3, [r3, #6]
 3339 0042 DBB2     		uxtb	r3, r3
 3340 0044 03F02003 		and	r3, r3, #32
 3341 0048 002B     		cmp	r3, #0
 3342 004a 09D1     		bne	.L276
1453:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 3343              		.loc 1 1453 0
 3344 004c 4FF48043 		mov	r3, #16384
 3345 0050 C4F20603 		movt	r3, 16390
 3346 0054 5B78     		ldrb	r3, [r3, #1]
 3347 0056 DBB2     		uxtb	r3, r3
 3348 0058 03F00203 		and	r3, r3, #2
1450:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 3349              		.loc 1 1450 0
 3350 005c 002B     		cmp	r3, #0
 3351 005e 02D0     		beq	.L277
 3352              	.L276:
1454:../Sources/drivers/mcg/mcg.c ****          )
1455:../Sources/drivers/mcg/mcg.c ****     )                       // check MCG_C2[LP] bit is not set
1456:../Sources/drivers/mcg/mcg.c ****         {
1457:../Sources/drivers/mcg/mcg.c ****             return 0x4;         // return error code
 3353              		.loc 1 1457 0
 3354 0060 4FF00403 		mov	r3, #4
 3355 0064 1DE1     		b	.L278
 3356              	.L277:
1458:../Sources/drivers/mcg/mcg.c ****         }
1459:../Sources/drivers/mcg/mcg.c **** 
1460:../Sources/drivers/mcg/mcg.c ****     // Check that the irc frequency matches the selected IRC
1461:../Sources/drivers/mcg/mcg.c **** 
1462:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
 3357              		.loc 1 1462 0
 3358 0066 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 3359 0068 002B     		cmp	r3, #0
 3360 006a 0CD1     		bne	.L279
1463:../Sources/drivers/mcg/mcg.c ****         {
1464:../Sources/drivers/mcg/mcg.c ****             if((irc_freq < 31250) || (irc_freq > 39063))
 3361              		.loc 1 1464 0
 3362 006c 7A68     		ldr	r2, [r7, #4]
 3363 006e 47F61123 		movw	r3, #31249
 3364 0072 9A42     		cmp	r2, r3
 3365 0074 04DD     		ble	.L280
 3366              		.loc 1 1464 0 is_stmt 0
 3367 0076 7A68     		ldr	r2, [r7, #4]
 3368 0078 49F69703 		movw	r3, #39063
 3369 007c 9A42     		cmp	r2, r3
 3370 007e 13DD     		ble	.L281
 3371              	.L280:
1465:../Sources/drivers/mcg/mcg.c ****                 {
1466:../Sources/drivers/mcg/mcg.c ****                     return 0x31;
 3372              		.loc 1 1466 0 is_stmt 1
 3373 0080 4FF03103 		mov	r3, #49
 3374 0084 0DE1     		b	.L278
 3375              	.L279:
1467:../Sources/drivers/mcg/mcg.c ****                 }
1468:../Sources/drivers/mcg/mcg.c ****         }
1469:../Sources/drivers/mcg/mcg.c ****     else
1470:../Sources/drivers/mcg/mcg.c ****         {
1471:../Sources/drivers/mcg/mcg.c ****             if((irc_freq < 3000000) || (irc_freq > 5000000))
 3376              		.loc 1 1471 0
 3377 0086 7A68     		ldr	r2, [r7, #4]
 3378 0088 4CF2BF63 		movw	r3, #50879
 3379 008c C0F22D03 		movt	r3, 45
 3380 0090 9A42     		cmp	r2, r3
 3381 0092 06DD     		ble	.L282
 3382              		.loc 1 1471 0 is_stmt 0
 3383 0094 7A68     		ldr	r2, [r7, #4]
 3384 0096 44F64033 		movw	r3, #19264
 3385 009a C0F24C03 		movt	r3, 76
 3386 009e 9A42     		cmp	r2, r3
 3387 00a0 02DD     		ble	.L281
 3388              	.L282:
1472:../Sources/drivers/mcg/mcg.c ****                 {
1473:../Sources/drivers/mcg/mcg.c ****                     return 0x32;    // Fast IRC freq
 3389              		.loc 1 1473 0 is_stmt 1
 3390 00a2 4FF03203 		mov	r3, #50
 3391 00a6 FCE0     		b	.L278
 3392              	.L281:
1474:../Sources/drivers/mcg/mcg.c ****                 }
1475:../Sources/drivers/mcg/mcg.c ****         }
1476:../Sources/drivers/mcg/mcg.c **** 
1477:../Sources/drivers/mcg/mcg.c ****     // Select the required IRC
1478:../Sources/drivers/mcg/mcg.c **** 
1479:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 3393              		.loc 1 1479 0
 3394 00a8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 3395 00aa 002B     		cmp	r3, #0
 3396 00ac 0ED0     		beq	.L283
1480:../Sources/drivers/mcg/mcg.c ****         {
1481:../Sources/drivers/mcg/mcg.c ****             MCG_C2 |= MCG_C2_IRCS_MASK;                     // select fast IRC by setting IRCS
 3397              		.loc 1 1481 0
 3398 00ae 4FF48043 		mov	r3, #16384
 3399 00b2 C4F20603 		movt	r3, 16390
 3400 00b6 4FF48042 		mov	r2, #16384
 3401 00ba C4F20602 		movt	r2, 16390
 3402 00be 5278     		ldrb	r2, [r2, #1]
 3403 00c0 D2B2     		uxtb	r2, r2
 3404 00c2 42F00102 		orr	r2, r2, #1
 3405 00c6 D2B2     		uxtb	r2, r2
 3406 00c8 5A70     		strb	r2, [r3, #1]
 3407 00ca 0DE0     		b	.L284
 3408              	.L283:
1482:../Sources/drivers/mcg/mcg.c ****         }
1483:../Sources/drivers/mcg/mcg.c ****     else
1484:../Sources/drivers/mcg/mcg.c ****         {
1485:../Sources/drivers/mcg/mcg.c ****             MCG_C2 &= ~MCG_C2_IRCS_MASK;                    // select slow IRC by clearing IRCS
 3409              		.loc 1 1485 0
 3410 00cc 4FF48043 		mov	r3, #16384
 3411 00d0 C4F20603 		movt	r3, 16390
 3412 00d4 4FF48042 		mov	r2, #16384
 3413 00d8 C4F20602 		movt	r2, 16390
 3414 00dc 5278     		ldrb	r2, [r2, #1]
 3415 00de D2B2     		uxtb	r2, r2
 3416 00e0 22F00102 		bic	r2, r2, #1
 3417 00e4 D2B2     		uxtb	r2, r2
 3418 00e6 5A70     		strb	r2, [r3, #1]
 3419              	.L284:
1486:../Sources/drivers/mcg/mcg.c ****         }
1487:../Sources/drivers/mcg/mcg.c **** 
1488:../Sources/drivers/mcg/mcg.c ****     // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
1489:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 3420              		.loc 1 1489 0
 3421 00e8 4FF48043 		mov	r3, #16384
 3422 00ec C4F20603 		movt	r3, 16390
 3423 00f0 4FF48042 		mov	r2, #16384
 3424 00f4 C4F20602 		movt	r2, 16390
 3425 00f8 5279     		ldrb	r2, [r2, #5]
 3426 00fa D2B2     		uxtb	r2, r2
 3427 00fc 22F02002 		bic	r2, r2, #32
 3428 0100 D2B2     		uxtb	r2, r2
 3429 0102 5A71     		strb	r2, [r3, #5]
1490:../Sources/drivers/mcg/mcg.c ****     // Select the IRC as the CLKS mux selection
1491:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 3430              		.loc 1 1491 0
 3431 0104 4FF48043 		mov	r3, #16384
 3432 0108 C4F20603 		movt	r3, 16390
 3433 010c 1B78     		ldrb	r3, [r3, #0]
 3434 010e 7B73     		strb	r3, [r7, #13]
1492:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                      // clear CLKS bits
 3435              		.loc 1 1492 0
 3436 0110 7B7B     		ldrb	r3, [r7, #13]
 3437 0112 03F03F03 		and	r3, r3, #63
 3438 0116 7B73     		strb	r3, [r7, #13]
1493:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK);   // select IRC as MCGOUT and enable IREFS
 3439              		.loc 1 1493 0
 3440 0118 7B7B     		ldrb	r3, [r7, #13]
 3441 011a 43F04403 		orr	r3, r3, #68
 3442 011e 7B73     		strb	r3, [r7, #13]
1494:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;  // update MCG_C1
 3443              		.loc 1 1494 0
 3444 0120 4FF48043 		mov	r3, #16384
 3445 0124 C4F20603 		movt	r3, 16390
 3446 0128 7A7B     		ldrb	r2, [r7, #13]
 3447 012a 1A70     		strb	r2, [r3, #0]
1495:../Sources/drivers/mcg/mcg.c **** 
1496:../Sources/drivers/mcg/mcg.c ****     // wait until internal reference switches to requested irc.
1497:../Sources/drivers/mcg/mcg.c **** 
1498:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
 3448              		.loc 1 1498 0
 3449 012c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 3450 012e 002B     		cmp	r3, #0
 3451 0130 26D1     		bne	.L285
1499:../Sources/drivers/mcg/mcg.c ****         {
1500:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 3452              		.loc 1 1500 0
 3453 0132 4FF00003 		mov	r3, #0
 3454 0136 FB81     		strh	r3, [r7, #14]	@ movhi
 3455 0138 0DE0     		b	.L286
 3456              	.L289:
1501:../Sources/drivers/mcg/mcg.c ****                 {
1502:../Sources/drivers/mcg/mcg.c ****                     if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears b
 3457              		.loc 1 1502 0
 3458 013a 4FF48043 		mov	r3, #16384
 3459 013e C4F20603 		movt	r3, 16390
 3460 0142 9B79     		ldrb	r3, [r3, #6]
 3461 0144 DBB2     		uxtb	r3, r3
 3462 0146 03F00103 		and	r3, r3, #1
 3463 014a 002B     		cmp	r3, #0
 3464 014c 0AD0     		beq	.L306
 3465              	.L287:
1500:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 3466              		.loc 1 1500 0
 3467 014e FB89     		ldrh	r3, [r7, #14]	@ movhi
 3468 0150 03F10103 		add	r3, r3, #1
 3469 0154 FB81     		strh	r3, [r7, #14]	@ movhi
 3470              	.L286:
1500:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 3471              		.loc 1 1500 0 is_stmt 0
 3472 0156 B7F90E20 		ldrsh	r2, [r7, #14]
 3473 015a 40F2CF73 		movw	r3, #1999
 3474 015e 9A42     		cmp	r2, r3
 3475 0160 EBDD     		ble	.L289
 3476 0162 00E0     		b	.L288
 3477              	.L306:
 3478              		.loc 1 1502 0 is_stmt 1
 3479 0164 00BF     		nop
 3480              	.L288:
1503:../Sources/drivers/mcg/mcg.c ****                 }
1504:../Sources/drivers/mcg/mcg.c **** 
1505:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) return 0x13;       // check bit is really clear and return
 3481              		.loc 1 1505 0
 3482 0166 4FF48043 		mov	r3, #16384
 3483 016a C4F20603 		movt	r3, 16390
 3484 016e 9B79     		ldrb	r3, [r3, #6]
 3485 0170 DBB2     		uxtb	r3, r3
 3486 0172 03F00103 		and	r3, r3, #1
 3487 0176 002B     		cmp	r3, #0
 3488 0178 29D0     		beq	.L290
 3489              		.loc 1 1505 0 is_stmt 0
 3490 017a 4FF01303 		mov	r3, #19
 3491 017e 90E0     		b	.L278
 3492              	.L285:
1506:../Sources/drivers/mcg/mcg.c ****         }
1507:../Sources/drivers/mcg/mcg.c ****     else
1508:../Sources/drivers/mcg/mcg.c ****         {
1509:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 3493              		.loc 1 1509 0 is_stmt 1
 3494 0180 4FF00003 		mov	r3, #0
 3495 0184 FB81     		strh	r3, [r7, #14]	@ movhi
 3496 0186 0DE0     		b	.L291
 3497              	.L294:
1510:../Sources/drivers/mcg/mcg.c ****                 {
1511:../Sources/drivers/mcg/mcg.c ****                     if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets bef
 3498              		.loc 1 1511 0
 3499 0188 4FF48043 		mov	r3, #16384
 3500 018c C4F20603 		movt	r3, 16390
 3501 0190 9B79     		ldrb	r3, [r3, #6]
 3502 0192 DBB2     		uxtb	r3, r3
 3503 0194 03F00103 		and	r3, r3, #1
 3504 0198 002B     		cmp	r3, #0
 3505 019a 0AD1     		bne	.L307
 3506              	.L292:
1509:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 3507              		.loc 1 1509 0
 3508 019c FB89     		ldrh	r3, [r7, #14]	@ movhi
 3509 019e 03F10103 		add	r3, r3, #1
 3510 01a2 FB81     		strh	r3, [r7, #14]	@ movhi
 3511              	.L291:
1509:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 3512              		.loc 1 1509 0 is_stmt 0
 3513 01a4 B7F90E20 		ldrsh	r2, [r7, #14]
 3514 01a8 40F2CF73 		movw	r3, #1999
 3515 01ac 9A42     		cmp	r2, r3
 3516 01ae EBDD     		ble	.L294
 3517 01b0 00E0     		b	.L293
 3518              	.L307:
 3519              		.loc 1 1511 0 is_stmt 1
 3520 01b2 00BF     		nop
 3521              	.L293:
1512:../Sources/drivers/mcg/mcg.c ****                 }
1513:../Sources/drivers/mcg/mcg.c **** 
1514:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) return 0x14;    // check bit is really set and return w
 3522              		.loc 1 1514 0
 3523 01b4 4FF48043 		mov	r3, #16384
 3524 01b8 C4F20603 		movt	r3, 16390
 3525 01bc 9B79     		ldrb	r3, [r3, #6]
 3526 01be DBB2     		uxtb	r3, r3
 3527 01c0 03F00103 		and	r3, r3, #1
 3528 01c4 002B     		cmp	r3, #0
 3529 01c6 02D1     		bne	.L290
 3530              		.loc 1 1514 0 is_stmt 0
 3531 01c8 4FF01403 		mov	r3, #20
 3532 01cc 69E0     		b	.L278
 3533              	.L290:
1515:../Sources/drivers/mcg/mcg.c ****         }
1516:../Sources/drivers/mcg/mcg.c **** 
1517:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
1518:../Sources/drivers/mcg/mcg.c **** 
1519:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3534              		.loc 1 1519 0 is_stmt 1
 3535 01ce 4FF00003 		mov	r3, #0
 3536 01d2 FB81     		strh	r3, [r7, #14]	@ movhi
 3537 01d4 0FE0     		b	.L295
 3538              	.L298:
1520:../Sources/drivers/mcg/mcg.c ****         {
1521:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;     // jump out ear
 3539              		.loc 1 1521 0
 3540 01d6 4FF48043 		mov	r3, #16384
 3541 01da C4F20603 		movt	r3, 16390
 3542 01de 9B79     		ldrb	r3, [r3, #6]
 3543 01e0 DBB2     		uxtb	r3, r3
 3544 01e2 03F00C03 		and	r3, r3, #12
 3545 01e6 4FEA9303 		lsr	r3, r3, #2
 3546 01ea 012B     		cmp	r3, #1
 3547 01ec 0AD0     		beq	.L308
 3548              	.L296:
1519:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3549              		.loc 1 1519 0
 3550 01ee FB89     		ldrh	r3, [r7, #14]	@ movhi
 3551 01f0 03F10103 		add	r3, r3, #1
 3552 01f4 FB81     		strh	r3, [r7, #14]	@ movhi
 3553              	.L295:
1519:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3554              		.loc 1 1519 0 is_stmt 0
 3555 01f6 B7F90E20 		ldrsh	r2, [r7, #14]
 3556 01fa 40F2CF73 		movw	r3, #1999
 3557 01fe 9A42     		cmp	r2, r3
 3558 0200 E9DD     		ble	.L298
 3559 0202 00E0     		b	.L297
 3560              	.L308:
 3561              		.loc 1 1521 0 is_stmt 1
 3562 0204 00BF     		nop
 3563              	.L297:
1522:../Sources/drivers/mcg/mcg.c ****         }
1523:../Sources/drivers/mcg/mcg.c **** 
1524:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19;   // check IRC is rea
 3564              		.loc 1 1524 0
 3565 0206 4FF48043 		mov	r3, #16384
 3566 020a C4F20603 		movt	r3, 16390
 3567 020e 9B79     		ldrb	r3, [r3, #6]
 3568 0210 DBB2     		uxtb	r3, r3
 3569 0212 03F00C03 		and	r3, r3, #12
 3570 0216 4FEA9303 		lsr	r3, r3, #2
 3571 021a 012B     		cmp	r3, #1
 3572 021c 02D0     		beq	.L299
 3573              		.loc 1 1524 0 is_stmt 0
 3574 021e 4FF01903 		mov	r3, #25
 3575 0222 3EE0     		b	.L278
 3576              	.L299:
1525:../Sources/drivers/mcg/mcg.c **** 
1526:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to set
1527:../Sources/drivers/mcg/mcg.c **** 
1528:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3577              		.loc 1 1528 0 is_stmt 1
 3578 0224 4FF00003 		mov	r3, #0
 3579 0228 FB81     		strh	r3, [r7, #14]	@ movhi
 3580 022a 0DE0     		b	.L300
 3581              	.L303:
1529:../Sources/drivers/mcg/mcg.c ****         {
1530:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loo
 3582              		.loc 1 1530 0
 3583 022c 4FF48043 		mov	r3, #16384
 3584 0230 C4F20603 		movt	r3, 16390
 3585 0234 9B79     		ldrb	r3, [r3, #6]
 3586 0236 DBB2     		uxtb	r3, r3
 3587 0238 03F01003 		and	r3, r3, #16
 3588 023c 002B     		cmp	r3, #0
 3589 023e 0AD1     		bne	.L309
 3590              	.L301:
1528:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3591              		.loc 1 1528 0
 3592 0240 FB89     		ldrh	r3, [r7, #14]	@ movhi
 3593 0242 03F10103 		add	r3, r3, #1
 3594 0246 FB81     		strh	r3, [r7, #14]	@ movhi
 3595              	.L300:
1528:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3596              		.loc 1 1528 0 is_stmt 0
 3597 0248 B7F90E20 		ldrsh	r2, [r7, #14]
 3598 024c 40F2CF73 		movw	r3, #1999
 3599 0250 9A42     		cmp	r2, r3
 3600 0252 EBDD     		ble	.L303
 3601 0254 00E0     		b	.L302
 3602              	.L309:
 3603              		.loc 1 1530 0 is_stmt 1
 3604 0256 00BF     		nop
 3605              	.L302:
1531:../Sources/drivers/mcg/mcg.c ****         }
1532:../Sources/drivers/mcg/mcg.c **** 
1533:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 3606              		.loc 1 1533 0
 3607 0258 4FF48043 		mov	r3, #16384
 3608 025c C4F20603 		movt	r3, 16390
 3609 0260 9B79     		ldrb	r3, [r3, #6]
 3610 0262 DBB2     		uxtb	r3, r3
 3611 0264 03F01003 		and	r3, r3, #16
 3612 0268 002B     		cmp	r3, #0
 3613 026a 02D1     		bne	.L304
 3614              		.loc 1 1533 0 is_stmt 0
 3615 026c 4FF01203 		mov	r3, #18
 3616 0270 17E0     		b	.L278
 3617              	.L304:
1534:../Sources/drivers/mcg/mcg.c **** 
1535:../Sources/drivers/mcg/mcg.c ****     // Now in FBI mode
1536:../Sources/drivers/mcg/mcg.c **** 
1537:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 3618              		.loc 1 1537 0 is_stmt 1
 3619 0272 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 3620 0274 002B     		cmp	r3, #0
 3621 0276 13D0     		beq	.L305
1538:../Sources/drivers/mcg/mcg.c ****         {
1539:../Sources/drivers/mcg/mcg.c ****             fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculat
 3622              		.loc 1 1539 0
 3623 0278 4FF48043 		mov	r3, #16384
 3624 027c C4F20603 		movt	r3, 16390
 3625 0280 1B7A     		ldrb	r3, [r3, #8]
 3626 0282 DBB2     		uxtb	r3, r3
 3627 0284 03F00E03 		and	r3, r3, #14
 3628 0288 4FEA5303 		lsr	r3, r3, #1
 3629 028c 4FF00102 		mov	r2, #1
 3630 0290 02FA03F3 		lsl	r3, r2, r3
 3631 0294 3B73     		strb	r3, [r7, #12]
1540:../Sources/drivers/mcg/mcg.c ****             return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided b
 3632              		.loc 1 1540 0
 3633 0296 3B7B     		ldrb	r3, [r7, #12]	@ zero_extendqisi2
 3634 0298 7A68     		ldr	r2, [r7, #4]
 3635 029a 92FBF3F3 		sdiv	r3, r2, r3
 3636 029e 00E0     		b	.L278
 3637              	.L305:
1541:../Sources/drivers/mcg/mcg.c ****         }
1542:../Sources/drivers/mcg/mcg.c ****     else
1543:../Sources/drivers/mcg/mcg.c ****         {
1544:../Sources/drivers/mcg/mcg.c ****             return irc_freq;                // MCGOUT frequency equals slow IRC frequency
 3638              		.loc 1 1544 0
 3639 02a0 7B68     		ldr	r3, [r7, #4]
 3640              	.L278:
1545:../Sources/drivers/mcg/mcg.c ****         }
1546:../Sources/drivers/mcg/mcg.c **** }   //fbe_fbi
 3641              		.loc 1 1546 0
 3642 02a2 1846     		mov	r0, r3
 3643 02a4 07F11407 		add	r7, r7, #20
 3644 02a8 BD46     		mov	sp, r7
 3645 02aa 80BC     		pop	{r7}
 3646 02ac 7047     		bx	lr
 3647              		.cfi_endproc
 3648              	.LFE14:
 3650 02ae 00BF     		.section	.text.fbi_fbe,"ax",%progbits
 3651              		.align	2
 3652              		.global	fbi_fbe
 3653              		.thumb
 3654              		.thumb_func
 3656              	fbi_fbe:
 3657              	.LFB15:
1547:../Sources/drivers/mcg/mcg.c **** 
1548:../Sources/drivers/mcg/mcg.c **** /* */
1549:../Sources/drivers/mcg/mcg.c **** 
1550:../Sources/drivers/mcg/mcg.c **** int fbi_fbe
1551:../Sources/drivers/mcg/mcg.c **** (
1552:../Sources/drivers/mcg/mcg.c ****     int             crystal_val,
1553:../Sources/drivers/mcg/mcg.c ****     unsigned char   hgo_val,
1554:../Sources/drivers/mcg/mcg.c ****     unsigned char   erefs_val
1555:../Sources/drivers/mcg/mcg.c **** )
1556:../Sources/drivers/mcg/mcg.c **** {
 3658              		.loc 1 1556 0
 3659              		.cfi_startproc
 3660              		@ args = 0, pretend = 0, frame = 16
 3661              		@ frame_needed = 1, uses_anonymous_args = 0
 3662              		@ link register save eliminated.
 3663 0000 80B4     		push	{r7}
 3664              	.LCFI45:
 3665              		.cfi_def_cfa_offset 4
 3666              		.cfi_offset 7, -4
 3667 0002 85B0     		sub	sp, sp, #20
 3668              	.LCFI46:
 3669              		.cfi_def_cfa_offset 24
 3670 0004 00AF     		add	r7, sp, #0
 3671              	.LCFI47:
 3672              		.cfi_def_cfa_register 7
 3673 0006 7860     		str	r0, [r7, #4]
 3674 0008 1346     		mov	r3, r2
 3675 000a 0A46     		mov	r2, r1
 3676 000c FA70     		strb	r2, [r7, #3]
 3677 000e BB70     		strb	r3, [r7, #2]
1557:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1558:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1559:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1560:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1561:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1562:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1563:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
1564:../Sources/drivers/mcg/mcg.c ****     unsigned char   frdiv_val;
1565:../Sources/drivers/mcg/mcg.c ****     short           i;
1566:../Sources/drivers/mcg/mcg.c **** 
1567:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1568:../Sources/drivers/mcg/mcg.c **** 
1569:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1570:../Sources/drivers/mcg/mcg.c **** 
1571:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1572:../Sources/drivers/mcg/mcg.c **** 
1573:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1574:../Sources/drivers/mcg/mcg.c **** 
1575:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1576:../Sources/drivers/mcg/mcg.c **** 
1577:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1578:../Sources/drivers/mcg/mcg.c **** 
1579:../Sources/drivers/mcg/mcg.c ****     // check if in FBI mode
1580:../Sources/drivers/mcg/mcg.c **** 
1581:../Sources/drivers/mcg/mcg.c ****     if
1582:../Sources/drivers/mcg/mcg.c ****     (
1583:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 3678              		.loc 1 1583 0
 3679 0010 4FF48043 		mov	r3, #16384
 3680 0014 C4F20603 		movt	r3, 16390
 3681 0018 9B79     		ldrb	r3, [r3, #6]
 3682 001a DBB2     		uxtb	r3, r3
 3683 001c 03F00C03 		and	r3, r3, #12
 3684 0020 4FEA9303 		lsr	r3, r3, #2
1582:../Sources/drivers/mcg/mcg.c ****     (
 3685              		.loc 1 1582 0
 3686 0024 012B     		cmp	r3, #1
 3687 0026 1DD1     		bne	.L311
1584:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 3688              		.loc 1 1584 0
 3689 0028 4FF48043 		mov	r3, #16384
 3690 002c C4F20603 		movt	r3, 16390
 3691 0030 9B79     		ldrb	r3, [r3, #6]
 3692 0032 DBB2     		uxtb	r3, r3
 3693 0034 03F01003 		and	r3, r3, #16
 3694 0038 002B     		cmp	r3, #0
 3695 003a 13D0     		beq	.L311
1585:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 3696              		.loc 1 1585 0
 3697 003c 4FF48043 		mov	r3, #16384
 3698 0040 C4F20603 		movt	r3, 16390
 3699 0044 9B79     		ldrb	r3, [r3, #6]
 3700 0046 DBB2     		uxtb	r3, r3
 3701 0048 03F02003 		and	r3, r3, #32
 3702 004c 002B     		cmp	r3, #0
 3703 004e 09D1     		bne	.L311
1586:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 3704              		.loc 1 1586 0
 3705 0050 4FF48043 		mov	r3, #16384
 3706 0054 C4F20603 		movt	r3, 16390
 3707 0058 5B78     		ldrb	r3, [r3, #1]
 3708 005a DBB2     		uxtb	r3, r3
 3709 005c 03F00203 		and	r3, r3, #2
1583:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 3710              		.loc 1 1583 0
 3711 0060 002B     		cmp	r3, #0
 3712 0062 02D0     		beq	.L312
 3713              	.L311:
1587:../Sources/drivers/mcg/mcg.c ****          )
1588:../Sources/drivers/mcg/mcg.c ****     )                       // check LP bit is clear
1589:../Sources/drivers/mcg/mcg.c ****         {
1590:../Sources/drivers/mcg/mcg.c ****             return 0x3;         // MCG not in correct mode return fail code
 3714              		.loc 1 1590 0
 3715 0064 4FF00303 		mov	r3, #3
 3716 0068 5AE1     		b	.L313
 3717              	.L312:
1591:../Sources/drivers/mcg/mcg.c ****         }
1592:../Sources/drivers/mcg/mcg.c **** 
1593:../Sources/drivers/mcg/mcg.c ****     // check external frequency is less than the maximum frequency
1594:../Sources/drivers/mcg/mcg.c **** 
1595:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
 3718              		.loc 1 1595 0
 3719 006a 7A68     		ldr	r2, [r7, #4]
 3720 006c 4FF28003 		movw	r3, #61568
 3721 0070 C0F2FA23 		movt	r3, 762
 3722 0074 9A42     		cmp	r2, r3
 3723 0076 02DD     		ble	.L314
1596:../Sources/drivers/mcg/mcg.c ****         {
1597:../Sources/drivers/mcg/mcg.c ****             return 0x21;
 3724              		.loc 1 1597 0
 3725 0078 4FF02103 		mov	r3, #33
 3726 007c 50E1     		b	.L313
 3727              	.L314:
1598:../Sources/drivers/mcg/mcg.c ****         }
1599:../Sources/drivers/mcg/mcg.c **** 
1600:../Sources/drivers/mcg/mcg.c ****     // check crystal frequency is within spec. if crystal osc is being used
1601:../Sources/drivers/mcg/mcg.c **** 
1602:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 3728              		.loc 1 1602 0
 3729 007e BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 3730 0080 002B     		cmp	r3, #0
 3731 0082 1AD0     		beq	.L315
1603:../Sources/drivers/mcg/mcg.c ****         {
1604:../Sources/drivers/mcg/mcg.c ****             if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crys
 3732              		.loc 1 1604 0
 3733 0084 7A68     		ldr	r2, [r7, #4]
 3734 0086 47F22F53 		movw	r3, #29999
 3735 008a 9A42     		cmp	r2, r3
 3736 008c 12DD     		ble	.L316
 3737              		.loc 1 1604 0 is_stmt 0
 3738 008e 7A68     		ldr	r2, [r7, #4]
 3739 0090 49F64043 		movw	r3, #40000
 3740 0094 9A42     		cmp	r2, r3
 3741 0096 06DD     		ble	.L317
 3742 0098 7A68     		ldr	r2, [r7, #4]
 3743 009a 4CF2BF63 		movw	r3, #50879
 3744 009e C0F22D03 		movt	r3, 45
 3745 00a2 9A42     		cmp	r2, r3
 3746 00a4 06DD     		ble	.L316
 3747              	.L317:
 3748              		.loc 1 1604 0
 3749 00a6 7A68     		ldr	r2, [r7, #4]
 3750 00a8 4FF49043 		mov	r3, #18432
 3751 00ac C0F2E813 		movt	r3, 488
 3752 00b0 9A42     		cmp	r2, r3
 3753 00b2 02DD     		ble	.L315
 3754              	.L316:
1605:../Sources/drivers/mcg/mcg.c ****                 {
1606:../Sources/drivers/mcg/mcg.c ****                     return 0x22;    // return error if one of the available crystal options is not 
 3755              		.loc 1 1606 0 is_stmt 1
 3756 00b4 4FF02203 		mov	r3, #34
 3757 00b8 32E1     		b	.L313
 3758              	.L315:
1607:../Sources/drivers/mcg/mcg.c ****                 }
1608:../Sources/drivers/mcg/mcg.c ****         }
1609:../Sources/drivers/mcg/mcg.c **** 
1610:../Sources/drivers/mcg/mcg.c ****     // make sure HGO will never be greater than 1. Could return an error instead if desired.
1611:../Sources/drivers/mcg/mcg.c **** 
1612:../Sources/drivers/mcg/mcg.c ****     if(hgo_val > 0)
 3759              		.loc 1 1612 0
 3760 00ba FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 3761 00bc 002B     		cmp	r3, #0
 3762 00be 02D0     		beq	.L318
1613:../Sources/drivers/mcg/mcg.c ****         {
1614:../Sources/drivers/mcg/mcg.c ****             hgo_val = 1;        // force hgo_val to 1 if > 0
 3763              		.loc 1 1614 0
 3764 00c0 4FF00103 		mov	r3, #1
 3765 00c4 FB70     		strb	r3, [r7, #3]
 3766              	.L318:
1615:../Sources/drivers/mcg/mcg.c ****         }
1616:../Sources/drivers/mcg/mcg.c **** 
1617:../Sources/drivers/mcg/mcg.c ****     // configure the MCG_C2 register
1618:../Sources/drivers/mcg/mcg.c ****     // the RANGE value is determined by the external frequency. Since the RANGE parameter affects t
1619:../Sources/drivers/mcg/mcg.c ****     // it still needs to be set correctly even if the oscillator is not being used
1620:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 3767              		.loc 1 1620 0
 3768 00c6 4FF48043 		mov	r3, #16384
 3769 00ca C4F20603 		movt	r3, 16390
 3770 00ce 5B78     		ldrb	r3, [r3, #1]
 3771 00d0 FB73     		strb	r3, [r7, #15]
1621:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 3772              		.loc 1 1621 0
 3773 00d2 FB7B     		ldrb	r3, [r7, #15]
 3774 00d4 23F03C03 		bic	r3, r3, #60
 3775 00d8 FB73     		strb	r3, [r7, #15]
1622:../Sources/drivers/mcg/mcg.c **** 
1623:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 3776              		.loc 1 1623 0
 3777 00da 7A68     		ldr	r2, [r7, #4]
 3778 00dc 49F64043 		movw	r3, #40000
 3779 00e0 9A42     		cmp	r2, r3
 3780 00e2 0DDC     		bgt	.L319
1624:../Sources/drivers/mcg/mcg.c ****         {
1625:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 3781              		.loc 1 1625 0
 3782 00e4 FB78     		ldrb	r3, [r7, #3]
 3783 00e6 4FEAC303 		lsl	r3, r3, #3
 3784 00ea DAB2     		uxtb	r2, r3
 3785 00ec BB78     		ldrb	r3, [r7, #2]
 3786 00ee 4FEA8303 		lsl	r3, r3, #2
 3787 00f2 DBB2     		uxtb	r3, r3
 3788 00f4 1343     		orrs	r3, r3, r2
 3789 00f6 DAB2     		uxtb	r2, r3
 3790 00f8 FB7B     		ldrb	r3, [r7, #15]
 3791 00fa 1343     		orrs	r3, r3, r2
 3792 00fc FB73     		strb	r3, [r7, #15]
 3793 00fe 27E0     		b	.L320
 3794              	.L319:
1626:../Sources/drivers/mcg/mcg.c ****         }
1627:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
 3795              		.loc 1 1627 0
 3796 0100 7A68     		ldr	r2, [r7, #4]
 3797 0102 4FF49053 		mov	r3, #4608
 3798 0106 C0F27A03 		movt	r3, 122
 3799 010a 9A42     		cmp	r2, r3
 3800 010c 10DC     		bgt	.L321
1628:../Sources/drivers/mcg/mcg.c ****         {
1629:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 3801              		.loc 1 1629 0
 3802 010e FB78     		ldrb	r3, [r7, #3]
 3803 0110 4FEAC303 		lsl	r3, r3, #3
 3804 0114 DAB2     		uxtb	r2, r3
 3805 0116 BB78     		ldrb	r3, [r7, #2]
 3806 0118 4FEA8303 		lsl	r3, r3, #2
 3807 011c DBB2     		uxtb	r3, r3
 3808 011e 1343     		orrs	r3, r3, r2
 3809 0120 DAB2     		uxtb	r2, r3
 3810 0122 FB7B     		ldrb	r3, [r7, #15]
 3811 0124 1343     		orrs	r3, r3, r2
 3812 0126 DBB2     		uxtb	r3, r3
 3813 0128 43F01003 		orr	r3, r3, #16
 3814 012c FB73     		strb	r3, [r7, #15]
 3815 012e 0FE0     		b	.L320
 3816              	.L321:
1630:../Sources/drivers/mcg/mcg.c ****         }
1631:../Sources/drivers/mcg/mcg.c ****     else
1632:../Sources/drivers/mcg/mcg.c ****         {
1633:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 3817              		.loc 1 1633 0
 3818 0130 FB78     		ldrb	r3, [r7, #3]
 3819 0132 4FEAC303 		lsl	r3, r3, #3
 3820 0136 DAB2     		uxtb	r2, r3
 3821 0138 BB78     		ldrb	r3, [r7, #2]
 3822 013a 4FEA8303 		lsl	r3, r3, #2
 3823 013e DBB2     		uxtb	r3, r3
 3824 0140 1343     		orrs	r3, r3, r2
 3825 0142 DAB2     		uxtb	r2, r3
 3826 0144 FB7B     		ldrb	r3, [r7, #15]
 3827 0146 1343     		orrs	r3, r3, r2
 3828 0148 DBB2     		uxtb	r3, r3
 3829 014a 43F02003 		orr	r3, r3, #32
 3830 014e FB73     		strb	r3, [r7, #15]
 3831              	.L320:
1634:../Sources/drivers/mcg/mcg.c ****         }
1635:../Sources/drivers/mcg/mcg.c **** 
1636:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 3832              		.loc 1 1636 0
 3833 0150 4FF48043 		mov	r3, #16384
 3834 0154 C4F20603 		movt	r3, 16390
 3835 0158 FA7B     		ldrb	r2, [r7, #15]
 3836 015a 5A70     		strb	r2, [r3, #1]
1637:../Sources/drivers/mcg/mcg.c **** 
1638:../Sources/drivers/mcg/mcg.c ****     // determine FRDIV based on reference clock frequency
1639:../Sources/drivers/mcg/mcg.c ****     // since the external frequency has already been checked only the maximum frequency for each FR
1640:../Sources/drivers/mcg/mcg.c **** 
1641:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 3837              		.loc 1 1641 0
 3838 015c 7A68     		ldr	r2, [r7, #4]
 3839 015e 41F2D023 		movw	r3, #4816
 3840 0162 C0F21303 		movt	r3, 19
 3841 0166 9A42     		cmp	r2, r3
 3842 0168 03DC     		bgt	.L322
1642:../Sources/drivers/mcg/mcg.c ****         {
1643:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 0;
 3843              		.loc 1 1643 0
 3844 016a 4FF00003 		mov	r3, #0
 3845 016e BB73     		strb	r3, [r7, #14]
 3846 0170 2EE0     		b	.L323
 3847              	.L322:
1644:../Sources/drivers/mcg/mcg.c ****         }
1645:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 3848              		.loc 1 1645 0
 3849 0172 7A68     		ldr	r2, [r7, #4]
 3850 0174 42F2A053 		movw	r3, #9632
 3851 0178 C0F22603 		movt	r3, 38
 3852 017c 9A42     		cmp	r2, r3
 3853 017e 03DC     		bgt	.L324
1646:../Sources/drivers/mcg/mcg.c ****         {
1647:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 1;
 3854              		.loc 1 1647 0
 3855 0180 4FF00103 		mov	r3, #1
 3856 0184 BB73     		strb	r3, [r7, #14]
 3857 0186 23E0     		b	.L323
 3858              	.L324:
1648:../Sources/drivers/mcg/mcg.c ****         }
1649:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 3859              		.loc 1 1649 0
 3860 0188 7A68     		ldr	r2, [r7, #4]
 3861 018a 44F64033 		movw	r3, #19264
 3862 018e C0F24C03 		movt	r3, 76
 3863 0192 9A42     		cmp	r2, r3
 3864 0194 03DC     		bgt	.L325
1650:../Sources/drivers/mcg/mcg.c ****         {
1651:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 2;
 3865              		.loc 1 1651 0
 3866 0196 4FF00203 		mov	r3, #2
 3867 019a BB73     		strb	r3, [r7, #14]
 3868 019c 18E0     		b	.L323
 3869              	.L325:
1652:../Sources/drivers/mcg/mcg.c ****         }
1653:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 3870              		.loc 1 1653 0
 3871 019e 7A68     		ldr	r2, [r7, #4]
 3872 01a0 49F28063 		movw	r3, #38528
 3873 01a4 C0F29803 		movt	r3, 152
 3874 01a8 9A42     		cmp	r2, r3
 3875 01aa 03DC     		bgt	.L326
1654:../Sources/drivers/mcg/mcg.c ****         {
1655:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 3;
 3876              		.loc 1 1655 0
 3877 01ac 4FF00303 		mov	r3, #3
 3878 01b0 BB73     		strb	r3, [r7, #14]
 3879 01b2 0DE0     		b	.L323
 3880              	.L326:
1656:../Sources/drivers/mcg/mcg.c ****         }
1657:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 3881              		.loc 1 1657 0
 3882 01b4 7A68     		ldr	r2, [r7, #4]
 3883 01b6 4FF43453 		mov	r3, #11520
 3884 01ba C0F23113 		movt	r3, 305
 3885 01be 9A42     		cmp	r2, r3
 3886 01c0 03DC     		bgt	.L327
1658:../Sources/drivers/mcg/mcg.c ****         {
1659:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 4;
 3887              		.loc 1 1659 0
 3888 01c2 4FF00403 		mov	r3, #4
 3889 01c6 BB73     		strb	r3, [r7, #14]
 3890 01c8 02E0     		b	.L323
 3891              	.L327:
1660:../Sources/drivers/mcg/mcg.c ****         }
1661:../Sources/drivers/mcg/mcg.c ****     else
1662:../Sources/drivers/mcg/mcg.c ****         {
1663:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 5;
 3892              		.loc 1 1663 0
 3893 01ca 4FF00503 		mov	r3, #5
 3894 01ce BB73     		strb	r3, [r7, #14]
 3895              	.L323:
1664:../Sources/drivers/mcg/mcg.c ****         }
1665:../Sources/drivers/mcg/mcg.c **** 
1666:../Sources/drivers/mcg/mcg.c ****     // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1667:../Sources/drivers/mcg/mcg.c ****     // If IRCLK is required it must be enabled outside of this driver, existing state will be maint
1668:../Sources/drivers/mcg/mcg.c ****     // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1669:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 3896              		.loc 1 1669 0
 3897 01d0 4FF48043 		mov	r3, #16384
 3898 01d4 C4F20603 		movt	r3, 16390
 3899 01d8 1B78     		ldrb	r3, [r3, #0]
 3900 01da FB73     		strb	r3, [r7, #15]
1670:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
 3901              		.loc 1 1670 0
 3902 01dc FB7B     		ldrb	r3, [r7, #15]
 3903 01de 03F00303 		and	r3, r3, #3
 3904 01e2 FB73     		strb	r3, [r7, #15]
1671:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 3905              		.loc 1 1671 0
 3906 01e4 BB7B     		ldrb	r3, [r7, #14]
 3907 01e6 4FEAC303 		lsl	r3, r3, #3
 3908 01ea DBB2     		uxtb	r3, r3
 3909 01ec 03F03803 		and	r3, r3, #56
 3910 01f0 DAB2     		uxtb	r2, r3
 3911 01f2 FB7B     		ldrb	r3, [r7, #15]
 3912 01f4 1343     		orrs	r3, r3, r2
 3913 01f6 DBB2     		uxtb	r3, r3
 3914 01f8 63F07F03 		orn	r3, r3, #127
 3915 01fc FB73     		strb	r3, [r7, #15]
1672:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 3916              		.loc 1 1672 0
 3917 01fe 4FF48043 		mov	r3, #16384
 3918 0202 C4F20603 		movt	r3, 16390
 3919 0206 FA7B     		ldrb	r2, [r7, #15]
 3920 0208 1A70     		strb	r2, [r3, #0]
1673:../Sources/drivers/mcg/mcg.c **** 
1674:../Sources/drivers/mcg/mcg.c ****     // if the external oscillator is used need to wait for OSCINIT to set
1675:../Sources/drivers/mcg/mcg.c **** 
1676:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 3921              		.loc 1 1676 0
 3922 020a BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 3923 020c 002B     		cmp	r3, #0
 3924 020e 26D0     		beq	.L328
1677:../Sources/drivers/mcg/mcg.c ****         {
1678:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 10000; i++)
 3925              		.loc 1 1678 0
 3926 0210 4FF00003 		mov	r3, #0
 3927 0214 BB81     		strh	r3, [r7, #12]	@ movhi
 3928 0216 0DE0     		b	.L329
 3929              	.L332:
1679:../Sources/drivers/mcg/mcg.c ****                 {
1680:../Sources/drivers/mcg/mcg.c ****                     if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out ear
 3930              		.loc 1 1680 0
 3931 0218 4FF48043 		mov	r3, #16384
 3932 021c C4F20603 		movt	r3, 16390
 3933 0220 9B79     		ldrb	r3, [r3, #6]
 3934 0222 DBB2     		uxtb	r3, r3
 3935 0224 03F00203 		and	r3, r3, #2
 3936 0228 002B     		cmp	r3, #0
 3937 022a 0AD1     		bne	.L343
 3938              	.L330:
1678:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 10000; i++)
 3939              		.loc 1 1678 0
 3940 022c BB89     		ldrh	r3, [r7, #12]	@ movhi
 3941 022e 03F10103 		add	r3, r3, #1
 3942 0232 BB81     		strh	r3, [r7, #12]	@ movhi
 3943              	.L329:
1678:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 10000; i++)
 3944              		.loc 1 1678 0 is_stmt 0
 3945 0234 B7F90C20 		ldrsh	r2, [r7, #12]
 3946 0238 42F20F73 		movw	r3, #9999
 3947 023c 9A42     		cmp	r2, r3
 3948 023e EBDD     		ble	.L332
 3949 0240 00E0     		b	.L331
 3950              	.L343:
 3951              		.loc 1 1680 0 is_stmt 1
 3952 0242 00BF     		nop
 3953              	.L331:
1681:../Sources/drivers/mcg/mcg.c ****                 }
1682:../Sources/drivers/mcg/mcg.c **** 
1683:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is rea
 3954              		.loc 1 1683 0
 3955 0244 4FF48043 		mov	r3, #16384
 3956 0248 C4F20603 		movt	r3, 16390
 3957 024c 9B79     		ldrb	r3, [r3, #6]
 3958 024e DBB2     		uxtb	r3, r3
 3959 0250 03F00203 		and	r3, r3, #2
 3960 0254 002B     		cmp	r3, #0
 3961 0256 02D1     		bne	.L328
 3962              		.loc 1 1683 0 is_stmt 0
 3963 0258 4FF02303 		mov	r3, #35
 3964 025c 60E0     		b	.L313
 3965              	.L328:
1684:../Sources/drivers/mcg/mcg.c ****         }
1685:../Sources/drivers/mcg/mcg.c **** 
1686:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
1687:../Sources/drivers/mcg/mcg.c **** 
1688:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3966              		.loc 1 1688 0 is_stmt 1
 3967 025e 4FF00003 		mov	r3, #0
 3968 0262 BB81     		strh	r3, [r7, #12]	@ movhi
 3969 0264 0DE0     		b	.L333
 3970              	.L336:
1689:../Sources/drivers/mcg/mcg.c ****         {
1690:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early i
 3971              		.loc 1 1690 0
 3972 0266 4FF48043 		mov	r3, #16384
 3973 026a C4F20603 		movt	r3, 16390
 3974 026e 9B79     		ldrb	r3, [r3, #6]
 3975 0270 DBB2     		uxtb	r3, r3
 3976 0272 03F01003 		and	r3, r3, #16
 3977 0276 002B     		cmp	r3, #0
 3978 0278 0AD0     		beq	.L344
 3979              	.L334:
1688:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3980              		.loc 1 1688 0
 3981 027a BB89     		ldrh	r3, [r7, #12]	@ movhi
 3982 027c 03F10103 		add	r3, r3, #1
 3983 0280 BB81     		strh	r3, [r7, #12]	@ movhi
 3984              	.L333:
1688:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3985              		.loc 1 1688 0 is_stmt 0
 3986 0282 B7F90C20 		ldrsh	r2, [r7, #12]
 3987 0286 40F2CF73 		movw	r3, #1999
 3988 028a 9A42     		cmp	r2, r3
 3989 028c EBDD     		ble	.L336
 3990 028e 00E0     		b	.L335
 3991              	.L344:
 3992              		.loc 1 1690 0 is_stmt 1
 3993 0290 00BF     		nop
 3994              	.L335:
1691:../Sources/drivers/mcg/mcg.c ****         }
1692:../Sources/drivers/mcg/mcg.c **** 
1693:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 3995              		.loc 1 1693 0
 3996 0292 4FF48043 		mov	r3, #16384
 3997 0296 C4F20603 		movt	r3, 16390
 3998 029a 9B79     		ldrb	r3, [r3, #6]
 3999 029c DBB2     		uxtb	r3, r3
 4000 029e 03F01003 		and	r3, r3, #16
 4001 02a2 002B     		cmp	r3, #0
 4002 02a4 02D0     		beq	.L337
 4003              		.loc 1 1693 0 is_stmt 0
 4004 02a6 4FF01103 		mov	r3, #17
 4005 02aa 39E0     		b	.L313
 4006              	.L337:
1694:../Sources/drivers/mcg/mcg.c **** 
1695:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
1696:../Sources/drivers/mcg/mcg.c **** 
1697:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4007              		.loc 1 1697 0 is_stmt 1
 4008 02ac 4FF00003 		mov	r3, #0
 4009 02b0 BB81     		strh	r3, [r7, #12]	@ movhi
 4010 02b2 0FE0     		b	.L338
 4011              	.L341:
1698:../Sources/drivers/mcg/mcg.c ****         {
1699:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early i
 4012              		.loc 1 1699 0
 4013 02b4 4FF48043 		mov	r3, #16384
 4014 02b8 C4F20603 		movt	r3, 16390
 4015 02bc 9B79     		ldrb	r3, [r3, #6]
 4016 02be DBB2     		uxtb	r3, r3
 4017 02c0 03F00C03 		and	r3, r3, #12
 4018 02c4 4FEA9303 		lsr	r3, r3, #2
 4019 02c8 022B     		cmp	r3, #2
 4020 02ca 0AD0     		beq	.L345
 4021              	.L339:
1697:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4022              		.loc 1 1697 0
 4023 02cc BB89     		ldrh	r3, [r7, #12]	@ movhi
 4024 02ce 03F10103 		add	r3, r3, #1
 4025 02d2 BB81     		strh	r3, [r7, #12]	@ movhi
 4026              	.L338:
1697:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4027              		.loc 1 1697 0 is_stmt 0
 4028 02d4 B7F90C20 		ldrsh	r2, [r7, #12]
 4029 02d8 40F2CF73 		movw	r3, #1999
 4030 02dc 9A42     		cmp	r2, r3
 4031 02de E9DD     		ble	.L341
 4032 02e0 00E0     		b	.L340
 4033              	.L345:
 4034              		.loc 1 1699 0 is_stmt 1
 4035 02e2 00BF     		nop
 4036              	.L340:
1700:../Sources/drivers/mcg/mcg.c ****         }
1701:../Sources/drivers/mcg/mcg.c **** 
1702:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 4037              		.loc 1 1702 0
 4038 02e4 4FF48043 		mov	r3, #16384
 4039 02e8 C4F20603 		movt	r3, 16390
 4040 02ec 9B79     		ldrb	r3, [r3, #6]
 4041 02ee DBB2     		uxtb	r3, r3
 4042 02f0 03F00C03 		and	r3, r3, #12
 4043 02f4 4FEA9303 		lsr	r3, r3, #2
 4044 02f8 022B     		cmp	r3, #2
 4045 02fa 02D0     		beq	.L342
 4046              		.loc 1 1702 0 is_stmt 0
 4047 02fc 4FF01A03 		mov	r3, #26
 4048 0300 0EE0     		b	.L313
 4049              	.L342:
1703:../Sources/drivers/mcg/mcg.c **** 
1704:../Sources/drivers/mcg/mcg.c ****     // Now in FBE
1705:../Sources/drivers/mcg/mcg.c ****     // It is recommended that the clock monitor is enabled when using an external clock as the cloc
1706:../Sources/drivers/mcg/mcg.c ****     // It is enabled here but can be removed if this is not required.
1707:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 4050              		.loc 1 1707 0 is_stmt 1
 4051 0302 4FF48043 		mov	r3, #16384
 4052 0306 C4F20603 		movt	r3, 16390
 4053 030a 4FF48042 		mov	r2, #16384
 4054 030e C4F20602 		movt	r2, 16390
 4055 0312 5279     		ldrb	r2, [r2, #5]
 4056 0314 D2B2     		uxtb	r2, r2
 4057 0316 42F02002 		orr	r2, r2, #32
 4058 031a D2B2     		uxtb	r2, r2
 4059 031c 5A71     		strb	r2, [r3, #5]
1708:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 4060              		.loc 1 1708 0
 4061 031e 7B68     		ldr	r3, [r7, #4]
 4062              	.L313:
1709:../Sources/drivers/mcg/mcg.c **** }                       // fbi_fbe
 4063              		.loc 1 1709 0
 4064 0320 1846     		mov	r0, r3
 4065 0322 07F11407 		add	r7, r7, #20
 4066 0326 BD46     		mov	sp, r7
 4067 0328 80BC     		pop	{r7}
 4068 032a 7047     		bx	lr
 4069              		.cfi_endproc
 4070              	.LFE15:
 4072              		.section	.text.fbi_blpi,"ax",%progbits
 4073              		.align	2
 4074              		.global	fbi_blpi
 4075              		.thumb
 4076              		.thumb_func
 4078              	fbi_blpi:
 4079              	.LFB16:
1710:../Sources/drivers/mcg/mcg.c **** 
1711:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
1712:../Sources/drivers/mcg/mcg.c **** 
1713:../Sources/drivers/mcg/mcg.c **** /* Functon name : fbi_blpi
1714:../Sources/drivers/mcg/mcg.c ****  *
1715:../Sources/drivers/mcg/mcg.c ****  * Mode transition: FBI to BLPI mode
1716:../Sources/drivers/mcg/mcg.c ****  *
1717:../Sources/drivers/mcg/mcg.c ****  * This function transitions the MCG from FBI mode to BLPI mode. This is
1718:../Sources/drivers/mcg/mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to
1719:../Sources/drivers/mcg/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1720:../Sources/drivers/mcg/mcg.c ****  * in FBI mode.
1721:../Sources/drivers/mcg/mcg.c ****  *
1722:../Sources/drivers/mcg/mcg.c ****  * Parameters: irc_freq - internal reference clock frequency
1723:../Sources/drivers/mcg/mcg.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1724:../Sources/drivers/mcg/mcg.c ****  *
1725:../Sources/drivers/mcg/mcg.c ****  * Return value : MCGOUT frequency or error code 0x13
1726:../Sources/drivers/mcg/mcg.c ****  */
1727:../Sources/drivers/mcg/mcg.c **** 
1728:../Sources/drivers/mcg/mcg.c **** int fbi_blpi
1729:../Sources/drivers/mcg/mcg.c **** (
1730:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
1731:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select
1732:../Sources/drivers/mcg/mcg.c **** )
1733:../Sources/drivers/mcg/mcg.c **** {
 4080              		.loc 1 1733 0
 4081              		.cfi_startproc
 4082              		@ args = 0, pretend = 0, frame = 16
 4083              		@ frame_needed = 1, uses_anonymous_args = 0
 4084              		@ link register save eliminated.
 4085 0000 80B4     		push	{r7}
 4086              	.LCFI48:
 4087              		.cfi_def_cfa_offset 4
 4088              		.cfi_offset 7, -4
 4089 0002 85B0     		sub	sp, sp, #20
 4090              	.LCFI49:
 4091              		.cfi_def_cfa_offset 24
 4092 0004 00AF     		add	r7, sp, #0
 4093              	.LCFI50:
 4094              		.cfi_def_cfa_register 7
 4095 0006 7860     		str	r0, [r7, #4]
 4096 0008 0B46     		mov	r3, r1
 4097 000a FB70     		strb	r3, [r7, #3]
1734:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1735:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1736:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1737:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1738:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1739:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1740:../Sources/drivers/mcg/mcg.c ****     unsigned char   fcrdiv_val;
1741:../Sources/drivers/mcg/mcg.c **** 
1742:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1743:../Sources/drivers/mcg/mcg.c **** 
1744:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1745:../Sources/drivers/mcg/mcg.c **** 
1746:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1747:../Sources/drivers/mcg/mcg.c **** 
1748:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1749:../Sources/drivers/mcg/mcg.c **** 
1750:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1751:../Sources/drivers/mcg/mcg.c **** 
1752:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1753:../Sources/drivers/mcg/mcg.c **** 
1754:../Sources/drivers/mcg/mcg.c ****     // check if in FBI mode
1755:../Sources/drivers/mcg/mcg.c **** 
1756:../Sources/drivers/mcg/mcg.c ****     if
1757:../Sources/drivers/mcg/mcg.c ****     (
1758:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4098              		.loc 1 1758 0
 4099 000c 4FF48043 		mov	r3, #16384
 4100 0010 C4F20603 		movt	r3, 16390
 4101 0014 9B79     		ldrb	r3, [r3, #6]
 4102 0016 DBB2     		uxtb	r3, r3
 4103 0018 03F00C03 		and	r3, r3, #12
 4104 001c 4FEA9303 		lsr	r3, r3, #2
1757:../Sources/drivers/mcg/mcg.c ****     (
 4105              		.loc 1 1757 0
 4106 0020 012B     		cmp	r3, #1
 4107 0022 1DD1     		bne	.L347
1759:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 4108              		.loc 1 1759 0
 4109 0024 4FF48043 		mov	r3, #16384
 4110 0028 C4F20603 		movt	r3, 16390
 4111 002c 9B79     		ldrb	r3, [r3, #6]
 4112 002e DBB2     		uxtb	r3, r3
 4113 0030 03F01003 		and	r3, r3, #16
 4114 0034 002B     		cmp	r3, #0
 4115 0036 13D0     		beq	.L347
1760:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 4116              		.loc 1 1760 0
 4117 0038 4FF48043 		mov	r3, #16384
 4118 003c C4F20603 		movt	r3, 16390
 4119 0040 9B79     		ldrb	r3, [r3, #6]
 4120 0042 DBB2     		uxtb	r3, r3
 4121 0044 03F02003 		and	r3, r3, #32
 4122 0048 002B     		cmp	r3, #0
 4123 004a 09D1     		bne	.L347
1761:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 4124              		.loc 1 1761 0
 4125 004c 4FF48043 		mov	r3, #16384
 4126 0050 C4F20603 		movt	r3, 16390
 4127 0054 5B78     		ldrb	r3, [r3, #1]
 4128 0056 DBB2     		uxtb	r3, r3
 4129 0058 03F00203 		and	r3, r3, #2
1758:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4130              		.loc 1 1758 0
 4131 005c 002B     		cmp	r3, #0
 4132 005e 02D0     		beq	.L348
 4133              	.L347:
1762:../Sources/drivers/mcg/mcg.c ****          )
1763:../Sources/drivers/mcg/mcg.c ****     )               // check LP bit is clear
1764:../Sources/drivers/mcg/mcg.c ****         {
1765:../Sources/drivers/mcg/mcg.c ****             return 0x3; // MCG not in correct mode return fail code
 4134              		.loc 1 1765 0
 4135 0060 4FF00303 		mov	r3, #3
 4136 0064 25E0     		b	.L349
 4137              	.L348:
1766:../Sources/drivers/mcg/mcg.c ****         }
1767:../Sources/drivers/mcg/mcg.c **** 
1768:../Sources/drivers/mcg/mcg.c ****     // Set LP bit to disable the FLL and enter BLPI
1769:../Sources/drivers/mcg/mcg.c ****     MCG_C2 |= MCG_C2_LP_MASK;
 4138              		.loc 1 1769 0
 4139 0066 4FF48043 		mov	r3, #16384
 4140 006a C4F20603 		movt	r3, 16390
 4141 006e 4FF48042 		mov	r2, #16384
 4142 0072 C4F20602 		movt	r2, 16390
 4143 0076 5278     		ldrb	r2, [r2, #1]
 4144 0078 D2B2     		uxtb	r2, r2
 4145 007a 42F00202 		orr	r2, r2, #2
 4146 007e D2B2     		uxtb	r2, r2
 4147 0080 5A70     		strb	r2, [r3, #1]
1770:../Sources/drivers/mcg/mcg.c **** 
1771:../Sources/drivers/mcg/mcg.c ****     // Now in BLPI
1772:../Sources/drivers/mcg/mcg.c **** 
1773:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 4148              		.loc 1 1773 0
 4149 0082 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 4150 0084 002B     		cmp	r3, #0
 4151 0086 13D0     		beq	.L350
1774:../Sources/drivers/mcg/mcg.c ****         {
1775:../Sources/drivers/mcg/mcg.c ****             fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculat
 4152              		.loc 1 1775 0
 4153 0088 4FF48043 		mov	r3, #16384
 4154 008c C4F20603 		movt	r3, 16390
 4155 0090 1B7A     		ldrb	r3, [r3, #8]
 4156 0092 DBB2     		uxtb	r3, r3
 4157 0094 03F00E03 		and	r3, r3, #14
 4158 0098 4FEA5303 		lsr	r3, r3, #1
 4159 009c 4FF00102 		mov	r2, #1
 4160 00a0 02FA03F3 		lsl	r3, r2, r3
 4161 00a4 FB73     		strb	r3, [r7, #15]
1776:../Sources/drivers/mcg/mcg.c ****             return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided b
 4162              		.loc 1 1776 0
 4163 00a6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4164 00a8 7A68     		ldr	r2, [r7, #4]
 4165 00aa 92FBF3F3 		sdiv	r3, r2, r3
 4166 00ae 00E0     		b	.L349
 4167              	.L350:
1777:../Sources/drivers/mcg/mcg.c ****         }
1778:../Sources/drivers/mcg/mcg.c ****     else
1779:../Sources/drivers/mcg/mcg.c ****         {
1780:../Sources/drivers/mcg/mcg.c ****             return irc_freq;                // MCGOUT frequency equals slow IRC frequency
 4168              		.loc 1 1780 0
 4169 00b0 7B68     		ldr	r3, [r7, #4]
 4170              	.L349:
1781:../Sources/drivers/mcg/mcg.c ****         }
1782:../Sources/drivers/mcg/mcg.c **** }   // fbi_blpi
 4171              		.loc 1 1782 0
 4172 00b2 1846     		mov	r0, r3
 4173 00b4 07F11407 		add	r7, r7, #20
 4174 00b8 BD46     		mov	sp, r7
 4175 00ba 80BC     		pop	{r7}
 4176 00bc 7047     		bx	lr
 4177              		.cfi_endproc
 4178              	.LFE16:
 4180 00be 00BF     		.section	.text.blpi_fbi,"ax",%progbits
 4181              		.align	2
 4182              		.global	blpi_fbi
 4183              		.thumb
 4184              		.thumb_func
 4186              	blpi_fbi:
 4187              	.LFB17:
1783:../Sources/drivers/mcg/mcg.c **** 
1784:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
1785:../Sources/drivers/mcg/mcg.c **** 
1786:../Sources/drivers/mcg/mcg.c **** /* Functon name : blpi_fbi
1787:../Sources/drivers/mcg/mcg.c ****  *
1788:../Sources/drivers/mcg/mcg.c ****  * Mode transition: BLPI to FBI mode
1789:../Sources/drivers/mcg/mcg.c ****  *
1790:../Sources/drivers/mcg/mcg.c ****  * This function transitions the MCG from BLPI mode to FBI mode. This is
1791:../Sources/drivers/mcg/mcg.c ****  * achieved by clearing the MCG_C2[LP] bit. There is no status bit to
1792:../Sources/drivers/mcg/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1793:../Sources/drivers/mcg/mcg.c ****  * in BLPI mode.
1794:../Sources/drivers/mcg/mcg.c ****  *
1795:../Sources/drivers/mcg/mcg.c ****  * Parameters: irc_freq - internal reference clock frequency
1796:../Sources/drivers/mcg/mcg.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1797:../Sources/drivers/mcg/mcg.c ****  *
1798:../Sources/drivers/mcg/mcg.c ****  * Return value : MCGOUT frequency or error code 0x15
1799:../Sources/drivers/mcg/mcg.c ****  */
1800:../Sources/drivers/mcg/mcg.c **** 
1801:../Sources/drivers/mcg/mcg.c **** int blpi_fbi
1802:../Sources/drivers/mcg/mcg.c **** (
1803:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
1804:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select
1805:../Sources/drivers/mcg/mcg.c **** )
1806:../Sources/drivers/mcg/mcg.c **** {
 4188              		.loc 1 1806 0
 4189              		.cfi_startproc
 4190              		@ args = 0, pretend = 0, frame = 16
 4191              		@ frame_needed = 1, uses_anonymous_args = 0
 4192              		@ link register save eliminated.
 4193 0000 80B4     		push	{r7}
 4194              	.LCFI51:
 4195              		.cfi_def_cfa_offset 4
 4196              		.cfi_offset 7, -4
 4197 0002 85B0     		sub	sp, sp, #20
 4198              	.LCFI52:
 4199              		.cfi_def_cfa_offset 24
 4200 0004 00AF     		add	r7, sp, #0
 4201              	.LCFI53:
 4202              		.cfi_def_cfa_register 7
 4203 0006 7860     		str	r0, [r7, #4]
 4204 0008 0B46     		mov	r3, r1
 4205 000a FB70     		strb	r3, [r7, #3]
1807:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1808:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1809:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1810:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1811:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1812:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1813:../Sources/drivers/mcg/mcg.c ****     unsigned char   fcrdiv_val;
1814:../Sources/drivers/mcg/mcg.c **** 
1815:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1816:../Sources/drivers/mcg/mcg.c **** 
1817:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1818:../Sources/drivers/mcg/mcg.c **** 
1819:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1820:../Sources/drivers/mcg/mcg.c **** 
1821:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1822:../Sources/drivers/mcg/mcg.c **** 
1823:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1824:../Sources/drivers/mcg/mcg.c **** 
1825:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1826:../Sources/drivers/mcg/mcg.c **** 
1827:../Sources/drivers/mcg/mcg.c ****     // check if in BLPI mode
1828:../Sources/drivers/mcg/mcg.c **** 
1829:../Sources/drivers/mcg/mcg.c ****     if
1830:../Sources/drivers/mcg/mcg.c ****     (
1831:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4206              		.loc 1 1831 0
 4207 000c 4FF48043 		mov	r3, #16384
 4208 0010 C4F20603 		movt	r3, 16390
 4209 0014 9B79     		ldrb	r3, [r3, #6]
 4210 0016 DBB2     		uxtb	r3, r3
 4211 0018 03F00C03 		and	r3, r3, #12
 4212 001c 4FEA9303 		lsr	r3, r3, #2
1830:../Sources/drivers/mcg/mcg.c ****     (
 4213              		.loc 1 1830 0
 4214 0020 012B     		cmp	r3, #1
 4215 0022 1DD1     		bne	.L352
1832:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 4216              		.loc 1 1832 0
 4217 0024 4FF48043 		mov	r3, #16384
 4218 0028 C4F20603 		movt	r3, 16390
 4219 002c 9B79     		ldrb	r3, [r3, #6]
 4220 002e DBB2     		uxtb	r3, r3
 4221 0030 03F01003 		and	r3, r3, #16
 4222 0034 002B     		cmp	r3, #0
 4223 0036 13D0     		beq	.L352
1833:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 4224              		.loc 1 1833 0
 4225 0038 4FF48043 		mov	r3, #16384
 4226 003c C4F20603 		movt	r3, 16390
 4227 0040 9B79     		ldrb	r3, [r3, #6]
 4228 0042 DBB2     		uxtb	r3, r3
 4229 0044 03F02003 		and	r3, r3, #32
 4230 0048 002B     		cmp	r3, #0
 4231 004a 09D1     		bne	.L352
1834:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_C2 & MCG_C2_LP_MASK)
 4232              		.loc 1 1834 0
 4233 004c 4FF48043 		mov	r3, #16384
 4234 0050 C4F20603 		movt	r3, 16390
 4235 0054 5B78     		ldrb	r3, [r3, #1]
 4236 0056 DBB2     		uxtb	r3, r3
 4237 0058 03F00203 		and	r3, r3, #2
1831:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4238              		.loc 1 1831 0
 4239 005c 002B     		cmp	r3, #0
 4240 005e 02D1     		bne	.L353
 4241              	.L352:
1835:../Sources/drivers/mcg/mcg.c ****          )
1836:../Sources/drivers/mcg/mcg.c ****     )               // check LP bit is set
1837:../Sources/drivers/mcg/mcg.c ****         {
1838:../Sources/drivers/mcg/mcg.c ****             return 0x5; // MCG not in correct mode return fail code
 4242              		.loc 1 1838 0
 4243 0060 4FF00503 		mov	r3, #5
 4244 0064 25E0     		b	.L354
 4245              	.L353:
1839:../Sources/drivers/mcg/mcg.c ****         }
1840:../Sources/drivers/mcg/mcg.c **** 
1841:../Sources/drivers/mcg/mcg.c ****     // Clear LP bit to enable the FLL and enter FBI mode
1842:../Sources/drivers/mcg/mcg.c ****     MCG_C2 &= ~MCG_C2_LP_MASK;
 4246              		.loc 1 1842 0
 4247 0066 4FF48043 		mov	r3, #16384
 4248 006a C4F20603 		movt	r3, 16390
 4249 006e 4FF48042 		mov	r2, #16384
 4250 0072 C4F20602 		movt	r2, 16390
 4251 0076 5278     		ldrb	r2, [r2, #1]
 4252 0078 D2B2     		uxtb	r2, r2
 4253 007a 22F00202 		bic	r2, r2, #2
 4254 007e D2B2     		uxtb	r2, r2
 4255 0080 5A70     		strb	r2, [r3, #1]
1843:../Sources/drivers/mcg/mcg.c **** 
1844:../Sources/drivers/mcg/mcg.c ****     // Now in FBI mode
1845:../Sources/drivers/mcg/mcg.c **** 
1846:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 4256              		.loc 1 1846 0
 4257 0082 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 4258 0084 002B     		cmp	r3, #0
 4259 0086 13D0     		beq	.L355
1847:../Sources/drivers/mcg/mcg.c ****         {
1848:../Sources/drivers/mcg/mcg.c ****             fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculat
 4260              		.loc 1 1848 0
 4261 0088 4FF48043 		mov	r3, #16384
 4262 008c C4F20603 		movt	r3, 16390
 4263 0090 1B7A     		ldrb	r3, [r3, #8]
 4264 0092 DBB2     		uxtb	r3, r3
 4265 0094 03F00E03 		and	r3, r3, #14
 4266 0098 4FEA5303 		lsr	r3, r3, #1
 4267 009c 4FF00102 		mov	r2, #1
 4268 00a0 02FA03F3 		lsl	r3, r2, r3
 4269 00a4 FB73     		strb	r3, [r7, #15]
1849:../Sources/drivers/mcg/mcg.c ****             return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided b
 4270              		.loc 1 1849 0
 4271 00a6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4272 00a8 7A68     		ldr	r2, [r7, #4]
 4273 00aa 92FBF3F3 		sdiv	r3, r2, r3
 4274 00ae 00E0     		b	.L354
 4275              	.L355:
1850:../Sources/drivers/mcg/mcg.c ****         }
1851:../Sources/drivers/mcg/mcg.c ****     else
1852:../Sources/drivers/mcg/mcg.c ****         {
1853:../Sources/drivers/mcg/mcg.c ****             return irc_freq;                // MCGOUT frequency equals slow IRC frequency
 4276              		.loc 1 1853 0
 4277 00b0 7B68     		ldr	r3, [r7, #4]
 4278              	.L354:
1854:../Sources/drivers/mcg/mcg.c ****         }
1855:../Sources/drivers/mcg/mcg.c **** }   // blpi_fbi
 4279              		.loc 1 1855 0
 4280 00b2 1846     		mov	r0, r3
 4281 00b4 07F11407 		add	r7, r7, #20
 4282 00b8 BD46     		mov	sp, r7
 4283 00ba 80BC     		pop	{r7}
 4284 00bc 7047     		bx	lr
 4285              		.cfi_endproc
 4286              	.LFE17:
 4288 00be 00BF     		.section	.text.fbi_fee,"ax",%progbits
 4289              		.align	2
 4290              		.global	fbi_fee
 4291              		.thumb
 4292              		.thumb_func
 4294              	fbi_fee:
 4295              	.LFB18:
1856:../Sources/drivers/mcg/mcg.c **** 
1857:../Sources/drivers/mcg/mcg.c **** /* */
1858:../Sources/drivers/mcg/mcg.c **** 
1859:../Sources/drivers/mcg/mcg.c **** int fbi_fee
1860:../Sources/drivers/mcg/mcg.c **** (
1861:../Sources/drivers/mcg/mcg.c ****     int             crystal_val,
1862:../Sources/drivers/mcg/mcg.c ****     unsigned char   hgo_val,
1863:../Sources/drivers/mcg/mcg.c ****     unsigned char   erefs_val
1864:../Sources/drivers/mcg/mcg.c **** )
1865:../Sources/drivers/mcg/mcg.c **** {
 4296              		.loc 1 1865 0
 4297              		.cfi_startproc
 4298              		@ args = 0, pretend = 0, frame = 24
 4299              		@ frame_needed = 1, uses_anonymous_args = 0
 4300 0000 80B5     		push	{r7, lr}
 4301              	.LCFI54:
 4302              		.cfi_def_cfa_offset 8
 4303              		.cfi_offset 7, -8
 4304              		.cfi_offset 14, -4
 4305 0002 86B0     		sub	sp, sp, #24
 4306              	.LCFI55:
 4307              		.cfi_def_cfa_offset 32
 4308 0004 00AF     		add	r7, sp, #0
 4309              	.LCFI56:
 4310              		.cfi_def_cfa_register 7
 4311 0006 7860     		str	r0, [r7, #4]
 4312 0008 1346     		mov	r3, r2
 4313 000a 0A46     		mov	r2, r1
 4314 000c FA70     		strb	r2, [r7, #3]
 4315 000e BB70     		strb	r3, [r7, #2]
1866:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1867:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1868:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1869:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1870:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1871:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1872:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
1873:../Sources/drivers/mcg/mcg.c ****     unsigned char   frdiv_val;
1874:../Sources/drivers/mcg/mcg.c ****     short           i;
1875:../Sources/drivers/mcg/mcg.c ****     int             mcg_out, fll_ref_freq;
1876:../Sources/drivers/mcg/mcg.c **** 
1877:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1878:../Sources/drivers/mcg/mcg.c **** 
1879:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1880:../Sources/drivers/mcg/mcg.c **** 
1881:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1882:../Sources/drivers/mcg/mcg.c **** 
1883:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1884:../Sources/drivers/mcg/mcg.c **** 
1885:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1886:../Sources/drivers/mcg/mcg.c **** 
1887:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
1888:../Sources/drivers/mcg/mcg.c **** 
1889:../Sources/drivers/mcg/mcg.c ****     // check if in FBI mode
1890:../Sources/drivers/mcg/mcg.c **** 
1891:../Sources/drivers/mcg/mcg.c ****     if
1892:../Sources/drivers/mcg/mcg.c ****     (
1893:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4316              		.loc 1 1893 0
 4317 0010 4FF48043 		mov	r3, #16384
 4318 0014 C4F20603 		movt	r3, 16390
 4319 0018 9B79     		ldrb	r3, [r3, #6]
 4320 001a DBB2     		uxtb	r3, r3
 4321 001c 03F00C03 		and	r3, r3, #12
 4322 0020 4FEA9303 		lsr	r3, r3, #2
1892:../Sources/drivers/mcg/mcg.c ****     (
 4323              		.loc 1 1892 0
 4324 0024 012B     		cmp	r3, #1
 4325 0026 1DD1     		bne	.L357
1894:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 4326              		.loc 1 1894 0
 4327 0028 4FF48043 		mov	r3, #16384
 4328 002c C4F20603 		movt	r3, 16390
 4329 0030 9B79     		ldrb	r3, [r3, #6]
 4330 0032 DBB2     		uxtb	r3, r3
 4331 0034 03F01003 		and	r3, r3, #16
 4332 0038 002B     		cmp	r3, #0
 4333 003a 13D0     		beq	.L357
1895:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 4334              		.loc 1 1895 0
 4335 003c 4FF48043 		mov	r3, #16384
 4336 0040 C4F20603 		movt	r3, 16390
 4337 0044 9B79     		ldrb	r3, [r3, #6]
 4338 0046 DBB2     		uxtb	r3, r3
 4339 0048 03F02003 		and	r3, r3, #32
 4340 004c 002B     		cmp	r3, #0
 4341 004e 09D1     		bne	.L357
1896:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 4342              		.loc 1 1896 0
 4343 0050 4FF48043 		mov	r3, #16384
 4344 0054 C4F20603 		movt	r3, 16390
 4345 0058 5B78     		ldrb	r3, [r3, #1]
 4346 005a DBB2     		uxtb	r3, r3
 4347 005c 03F00203 		and	r3, r3, #2
1893:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4348              		.loc 1 1893 0
 4349 0060 002B     		cmp	r3, #0
 4350 0062 02D0     		beq	.L358
 4351              	.L357:
1897:../Sources/drivers/mcg/mcg.c ****          )
1898:../Sources/drivers/mcg/mcg.c ****     )                       // check LP bit is clear
1899:../Sources/drivers/mcg/mcg.c ****         {
1900:../Sources/drivers/mcg/mcg.c ****             return 0x3;         // MCG not in correct mode return fail code
 4352              		.loc 1 1900 0
 4353 0064 4FF00303 		mov	r3, #3
 4354 0068 7FE1     		b	.L359
 4355              	.L358:
1901:../Sources/drivers/mcg/mcg.c ****         }
1902:../Sources/drivers/mcg/mcg.c **** 
1903:../Sources/drivers/mcg/mcg.c ****     // check external frequency is less than the maximum frequency
1904:../Sources/drivers/mcg/mcg.c **** 
1905:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
 4356              		.loc 1 1905 0
 4357 006a 7A68     		ldr	r2, [r7, #4]
 4358 006c 4FF28003 		movw	r3, #61568
 4359 0070 C0F2FA23 		movt	r3, 762
 4360 0074 9A42     		cmp	r2, r3
 4361 0076 02DD     		ble	.L360
1906:../Sources/drivers/mcg/mcg.c ****         {
1907:../Sources/drivers/mcg/mcg.c ****             return 0x21;
 4362              		.loc 1 1907 0
 4363 0078 4FF02103 		mov	r3, #33
 4364 007c 75E1     		b	.L359
 4365              	.L360:
1908:../Sources/drivers/mcg/mcg.c ****         }
1909:../Sources/drivers/mcg/mcg.c **** 
1910:../Sources/drivers/mcg/mcg.c ****     // check crystal frequency is within spec. if crystal osc is being used
1911:../Sources/drivers/mcg/mcg.c **** 
1912:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 4366              		.loc 1 1912 0
 4367 007e BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 4368 0080 002B     		cmp	r3, #0
 4369 0082 1AD0     		beq	.L361
1913:../Sources/drivers/mcg/mcg.c ****         {
1914:../Sources/drivers/mcg/mcg.c ****             if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crys
 4370              		.loc 1 1914 0
 4371 0084 7A68     		ldr	r2, [r7, #4]
 4372 0086 47F22F53 		movw	r3, #29999
 4373 008a 9A42     		cmp	r2, r3
 4374 008c 12DD     		ble	.L362
 4375              		.loc 1 1914 0 is_stmt 0
 4376 008e 7A68     		ldr	r2, [r7, #4]
 4377 0090 49F64043 		movw	r3, #40000
 4378 0094 9A42     		cmp	r2, r3
 4379 0096 06DD     		ble	.L363
 4380 0098 7A68     		ldr	r2, [r7, #4]
 4381 009a 4CF2BF63 		movw	r3, #50879
 4382 009e C0F22D03 		movt	r3, 45
 4383 00a2 9A42     		cmp	r2, r3
 4384 00a4 06DD     		ble	.L362
 4385              	.L363:
 4386              		.loc 1 1914 0
 4387 00a6 7A68     		ldr	r2, [r7, #4]
 4388 00a8 4FF49043 		mov	r3, #18432
 4389 00ac C0F2E813 		movt	r3, 488
 4390 00b0 9A42     		cmp	r2, r3
 4391 00b2 02DD     		ble	.L361
 4392              	.L362:
1915:../Sources/drivers/mcg/mcg.c ****                 {
1916:../Sources/drivers/mcg/mcg.c ****                     return 0x22;    // return error if one of the available crystal options is not 
 4393              		.loc 1 1916 0 is_stmt 1
 4394 00b4 4FF02203 		mov	r3, #34
 4395 00b8 57E1     		b	.L359
 4396              	.L361:
1917:../Sources/drivers/mcg/mcg.c ****                 }
1918:../Sources/drivers/mcg/mcg.c ****         }
1919:../Sources/drivers/mcg/mcg.c **** 
1920:../Sources/drivers/mcg/mcg.c ****     // make sure HGO will never be greater than 1. Could return an error instead if desired.
1921:../Sources/drivers/mcg/mcg.c **** 
1922:../Sources/drivers/mcg/mcg.c ****     if(hgo_val > 0)
 4397              		.loc 1 1922 0
 4398 00ba FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 4399 00bc 002B     		cmp	r3, #0
 4400 00be 02D0     		beq	.L364
1923:../Sources/drivers/mcg/mcg.c ****         {
1924:../Sources/drivers/mcg/mcg.c ****             hgo_val = 1;        // force hgo_val to 1 if > 0
 4401              		.loc 1 1924 0
 4402 00c0 4FF00103 		mov	r3, #1
 4403 00c4 FB70     		strb	r3, [r7, #3]
 4404              	.L364:
1925:../Sources/drivers/mcg/mcg.c ****         }
1926:../Sources/drivers/mcg/mcg.c **** 
1927:../Sources/drivers/mcg/mcg.c ****     // configure the MCG_C2 register
1928:../Sources/drivers/mcg/mcg.c ****     // the RANGE value is determined by the external frequency. Since the RANGE parameter affects t
1929:../Sources/drivers/mcg/mcg.c ****     // it still needs to be set correctly even if the oscillator is not being used
1930:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 4405              		.loc 1 1930 0
 4406 00c6 4FF48043 		mov	r3, #16384
 4407 00ca C4F20603 		movt	r3, 16390
 4408 00ce 5B78     		ldrb	r3, [r3, #1]
 4409 00d0 FB75     		strb	r3, [r7, #23]
1931:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 4410              		.loc 1 1931 0
 4411 00d2 FB7D     		ldrb	r3, [r7, #23]
 4412 00d4 23F03C03 		bic	r3, r3, #60
 4413 00d8 FB75     		strb	r3, [r7, #23]
1932:../Sources/drivers/mcg/mcg.c **** 
1933:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 4414              		.loc 1 1933 0
 4415 00da 7A68     		ldr	r2, [r7, #4]
 4416 00dc 49F64043 		movw	r3, #40000
 4417 00e0 9A42     		cmp	r2, r3
 4418 00e2 0DDC     		bgt	.L365
1934:../Sources/drivers/mcg/mcg.c ****         {
1935:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 4419              		.loc 1 1935 0
 4420 00e4 FB78     		ldrb	r3, [r7, #3]
 4421 00e6 4FEAC303 		lsl	r3, r3, #3
 4422 00ea DAB2     		uxtb	r2, r3
 4423 00ec BB78     		ldrb	r3, [r7, #2]
 4424 00ee 4FEA8303 		lsl	r3, r3, #2
 4425 00f2 DBB2     		uxtb	r3, r3
 4426 00f4 1343     		orrs	r3, r3, r2
 4427 00f6 DAB2     		uxtb	r2, r3
 4428 00f8 FB7D     		ldrb	r3, [r7, #23]
 4429 00fa 1343     		orrs	r3, r3, r2
 4430 00fc FB75     		strb	r3, [r7, #23]
 4431 00fe 27E0     		b	.L366
 4432              	.L365:
1936:../Sources/drivers/mcg/mcg.c ****         }
1937:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
 4433              		.loc 1 1937 0
 4434 0100 7A68     		ldr	r2, [r7, #4]
 4435 0102 4FF49053 		mov	r3, #4608
 4436 0106 C0F27A03 		movt	r3, 122
 4437 010a 9A42     		cmp	r2, r3
 4438 010c 10DC     		bgt	.L367
1938:../Sources/drivers/mcg/mcg.c ****         {
1939:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 4439              		.loc 1 1939 0
 4440 010e FB78     		ldrb	r3, [r7, #3]
 4441 0110 4FEAC303 		lsl	r3, r3, #3
 4442 0114 DAB2     		uxtb	r2, r3
 4443 0116 BB78     		ldrb	r3, [r7, #2]
 4444 0118 4FEA8303 		lsl	r3, r3, #2
 4445 011c DBB2     		uxtb	r3, r3
 4446 011e 1343     		orrs	r3, r3, r2
 4447 0120 DAB2     		uxtb	r2, r3
 4448 0122 FB7D     		ldrb	r3, [r7, #23]
 4449 0124 1343     		orrs	r3, r3, r2
 4450 0126 DBB2     		uxtb	r3, r3
 4451 0128 43F01003 		orr	r3, r3, #16
 4452 012c FB75     		strb	r3, [r7, #23]
 4453 012e 0FE0     		b	.L366
 4454              	.L367:
1940:../Sources/drivers/mcg/mcg.c ****         }
1941:../Sources/drivers/mcg/mcg.c ****     else
1942:../Sources/drivers/mcg/mcg.c ****         {
1943:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 4455              		.loc 1 1943 0
 4456 0130 FB78     		ldrb	r3, [r7, #3]
 4457 0132 4FEAC303 		lsl	r3, r3, #3
 4458 0136 DAB2     		uxtb	r2, r3
 4459 0138 BB78     		ldrb	r3, [r7, #2]
 4460 013a 4FEA8303 		lsl	r3, r3, #2
 4461 013e DBB2     		uxtb	r3, r3
 4462 0140 1343     		orrs	r3, r3, r2
 4463 0142 DAB2     		uxtb	r2, r3
 4464 0144 FB7D     		ldrb	r3, [r7, #23]
 4465 0146 1343     		orrs	r3, r3, r2
 4466 0148 DBB2     		uxtb	r3, r3
 4467 014a 43F02003 		orr	r3, r3, #32
 4468 014e FB75     		strb	r3, [r7, #23]
 4469              	.L366:
1944:../Sources/drivers/mcg/mcg.c ****         }
1945:../Sources/drivers/mcg/mcg.c **** 
1946:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 4470              		.loc 1 1946 0
 4471 0150 4FF48043 		mov	r3, #16384
 4472 0154 C4F20603 		movt	r3, 16390
 4473 0158 FA7D     		ldrb	r2, [r7, #23]
 4474 015a 5A70     		strb	r2, [r3, #1]
1947:../Sources/drivers/mcg/mcg.c **** 
1948:../Sources/drivers/mcg/mcg.c ****     // determine FRDIV based on reference clock frequency
1949:../Sources/drivers/mcg/mcg.c ****     // since the external frequency has already been checked only the maximum frequency for each FR
1950:../Sources/drivers/mcg/mcg.c **** 
1951:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 4475              		.loc 1 1951 0
 4476 015c 7A68     		ldr	r2, [r7, #4]
 4477 015e 41F2D023 		movw	r3, #4816
 4478 0162 C0F21303 		movt	r3, 19
 4479 0166 9A42     		cmp	r2, r3
 4480 0168 03DC     		bgt	.L368
1952:../Sources/drivers/mcg/mcg.c ****         {
1953:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 0;
 4481              		.loc 1 1953 0
 4482 016a 4FF00003 		mov	r3, #0
 4483 016e BB75     		strb	r3, [r7, #22]
 4484 0170 2EE0     		b	.L369
 4485              	.L368:
1954:../Sources/drivers/mcg/mcg.c ****         }
1955:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 4486              		.loc 1 1955 0
 4487 0172 7A68     		ldr	r2, [r7, #4]
 4488 0174 42F2A053 		movw	r3, #9632
 4489 0178 C0F22603 		movt	r3, 38
 4490 017c 9A42     		cmp	r2, r3
 4491 017e 03DC     		bgt	.L370
1956:../Sources/drivers/mcg/mcg.c ****         {
1957:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 1;
 4492              		.loc 1 1957 0
 4493 0180 4FF00103 		mov	r3, #1
 4494 0184 BB75     		strb	r3, [r7, #22]
 4495 0186 23E0     		b	.L369
 4496              	.L370:
1958:../Sources/drivers/mcg/mcg.c ****         }
1959:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 4497              		.loc 1 1959 0
 4498 0188 7A68     		ldr	r2, [r7, #4]
 4499 018a 44F64033 		movw	r3, #19264
 4500 018e C0F24C03 		movt	r3, 76
 4501 0192 9A42     		cmp	r2, r3
 4502 0194 03DC     		bgt	.L371
1960:../Sources/drivers/mcg/mcg.c ****         {
1961:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 2;
 4503              		.loc 1 1961 0
 4504 0196 4FF00203 		mov	r3, #2
 4505 019a BB75     		strb	r3, [r7, #22]
 4506 019c 18E0     		b	.L369
 4507              	.L371:
1962:../Sources/drivers/mcg/mcg.c ****         }
1963:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 4508              		.loc 1 1963 0
 4509 019e 7A68     		ldr	r2, [r7, #4]
 4510 01a0 49F28063 		movw	r3, #38528
 4511 01a4 C0F29803 		movt	r3, 152
 4512 01a8 9A42     		cmp	r2, r3
 4513 01aa 03DC     		bgt	.L372
1964:../Sources/drivers/mcg/mcg.c ****         {
1965:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 3;
 4514              		.loc 1 1965 0
 4515 01ac 4FF00303 		mov	r3, #3
 4516 01b0 BB75     		strb	r3, [r7, #22]
 4517 01b2 0DE0     		b	.L369
 4518              	.L372:
1966:../Sources/drivers/mcg/mcg.c ****         }
1967:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 4519              		.loc 1 1967 0
 4520 01b4 7A68     		ldr	r2, [r7, #4]
 4521 01b6 4FF43453 		mov	r3, #11520
 4522 01ba C0F23113 		movt	r3, 305
 4523 01be 9A42     		cmp	r2, r3
 4524 01c0 03DC     		bgt	.L373
1968:../Sources/drivers/mcg/mcg.c ****         {
1969:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 4;
 4525              		.loc 1 1969 0
 4526 01c2 4FF00403 		mov	r3, #4
 4527 01c6 BB75     		strb	r3, [r7, #22]
 4528 01c8 02E0     		b	.L369
 4529              	.L373:
1970:../Sources/drivers/mcg/mcg.c ****         }
1971:../Sources/drivers/mcg/mcg.c ****     else
1972:../Sources/drivers/mcg/mcg.c ****         {
1973:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 5;
 4530              		.loc 1 1973 0
 4531 01ca 4FF00503 		mov	r3, #5
 4532 01ce BB75     		strb	r3, [r7, #22]
 4533              	.L369:
1974:../Sources/drivers/mcg/mcg.c ****         }
1975:../Sources/drivers/mcg/mcg.c **** 
1976:../Sources/drivers/mcg/mcg.c ****     // The FLL ref clk divide value depends on FRDIV and the RANGE value
1977:../Sources/drivers/mcg/mcg.c **** 
1978:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 4534              		.loc 1 1978 0
 4535 01d0 4FF48043 		mov	r3, #16384
 4536 01d4 C4F20603 		movt	r3, 16390
 4537 01d8 5B78     		ldrb	r3, [r3, #1]
 4538 01da DBB2     		uxtb	r3, r3
 4539 01dc 03F03003 		and	r3, r3, #48
 4540 01e0 4FEA1313 		lsr	r3, r3, #4
 4541 01e4 002B     		cmp	r3, #0
 4542 01e6 09D0     		beq	.L374
1979:../Sources/drivers/mcg/mcg.c ****         {
1980:../Sources/drivers/mcg/mcg.c ****             fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
 4543              		.loc 1 1980 0
 4544 01e8 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4545 01ea 4FF02002 		mov	r2, #32
 4546 01ee 02FA03F3 		lsl	r3, r2, r3
 4547 01f2 7A68     		ldr	r2, [r7, #4]
 4548 01f4 92FBF3F3 		sdiv	r3, r2, r3
 4549 01f8 3B61     		str	r3, [r7, #16]
 4550 01fa 08E0     		b	.L375
 4551              	.L374:
1981:../Sources/drivers/mcg/mcg.c ****         }
1982:../Sources/drivers/mcg/mcg.c ****     else
1983:../Sources/drivers/mcg/mcg.c ****         {
1984:../Sources/drivers/mcg/mcg.c ****             fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 4552              		.loc 1 1984 0
 4553 01fc BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4554 01fe 4FF00102 		mov	r2, #1
 4555 0202 02FA03F3 		lsl	r3, r2, r3
 4556 0206 7A68     		ldr	r2, [r7, #4]
 4557 0208 92FBF3F3 		sdiv	r3, r2, r3
 4558 020c 3B61     		str	r3, [r7, #16]
 4559              	.L375:
1985:../Sources/drivers/mcg/mcg.c ****         }
1986:../Sources/drivers/mcg/mcg.c **** 
1987:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
1988:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
 4560              		.loc 1 1988 0
 4561 020e 3869     		ldr	r0, [r7, #16]
 4562 0210 FFF7FEFF 		bl	fll_freq
 4563 0214 F860     		str	r0, [r7, #12]
1989:../Sources/drivers/mcg/mcg.c **** 
1990:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 4564              		.loc 1 1990 0
 4565 0216 FB68     		ldr	r3, [r7, #12]
 4566 0218 3B2B     		cmp	r3, #59
 4567 021a 01DC     		bgt	.L376
1991:../Sources/drivers/mcg/mcg.c ****         {
1992:../Sources/drivers/mcg/mcg.c ****             return mcg_out;                 // If error code returned, return the code to calling f
 4568              		.loc 1 1992 0
 4569 021c FB68     		ldr	r3, [r7, #12]
 4570 021e A4E0     		b	.L359
 4571              	.L376:
1993:../Sources/drivers/mcg/mcg.c ****         }
1994:../Sources/drivers/mcg/mcg.c **** 
1995:../Sources/drivers/mcg/mcg.c ****     // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1996:../Sources/drivers/mcg/mcg.c ****     // If IRCLK is required it must be enabled outside of this driver, existing state will be maint
1997:../Sources/drivers/mcg/mcg.c ****     // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=?, IREFSTEN=?
1998:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 4572              		.loc 1 1998 0
 4573 0220 4FF48043 		mov	r3, #16384
 4574 0224 C4F20603 		movt	r3, 16390
 4575 0228 1B78     		ldrb	r3, [r3, #0]
 4576 022a FB75     		strb	r3, [r7, #23]
1999:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear CLKS, FRDI
 4577              		.loc 1 1999 0
 4578 022c FB7D     		ldrb	r3, [r7, #23]
 4579 022e 03F00303 		and	r3, r3, #3
 4580 0232 FB75     		strb	r3, [r7, #23]
2000:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 4581              		.loc 1 2000 0
 4582 0234 BB7D     		ldrb	r3, [r7, #22]
 4583 0236 4FEAC303 		lsl	r3, r3, #3
 4584 023a DBB2     		uxtb	r3, r3
 4585 023c 03F03803 		and	r3, r3, #56
 4586 0240 DAB2     		uxtb	r2, r3
 4587 0242 FB7D     		ldrb	r3, [r7, #23]
 4588 0244 1343     		orrs	r3, r3, r2
 4589 0246 FB75     		strb	r3, [r7, #23]
2001:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 4590              		.loc 1 2001 0
 4591 0248 4FF48043 		mov	r3, #16384
 4592 024c C4F20603 		movt	r3, 16390
 4593 0250 FA7D     		ldrb	r2, [r7, #23]
 4594 0252 1A70     		strb	r2, [r3, #0]
2002:../Sources/drivers/mcg/mcg.c **** 
2003:../Sources/drivers/mcg/mcg.c ****     // if the external oscillator is used need to wait for OSCINIT to set
2004:../Sources/drivers/mcg/mcg.c **** 
2005:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 4595              		.loc 1 2005 0
 4596 0254 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 4597 0256 002B     		cmp	r3, #0
 4598 0258 26D0     		beq	.L377
2006:../Sources/drivers/mcg/mcg.c ****         {
2007:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 10000; i++)
 4599              		.loc 1 2007 0
 4600 025a 4FF00003 		mov	r3, #0
 4601 025e BB82     		strh	r3, [r7, #20]	@ movhi
 4602 0260 0DE0     		b	.L378
 4603              	.L381:
2008:../Sources/drivers/mcg/mcg.c ****                 {
2009:../Sources/drivers/mcg/mcg.c ****                     if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out ear
 4604              		.loc 1 2009 0
 4605 0262 4FF48043 		mov	r3, #16384
 4606 0266 C4F20603 		movt	r3, 16390
 4607 026a 9B79     		ldrb	r3, [r3, #6]
 4608 026c DBB2     		uxtb	r3, r3
 4609 026e 03F00203 		and	r3, r3, #2
 4610 0272 002B     		cmp	r3, #0
 4611 0274 0AD1     		bne	.L392
 4612              	.L379:
2007:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 10000; i++)
 4613              		.loc 1 2007 0
 4614 0276 BB8A     		ldrh	r3, [r7, #20]	@ movhi
 4615 0278 03F10103 		add	r3, r3, #1
 4616 027c BB82     		strh	r3, [r7, #20]	@ movhi
 4617              	.L378:
2007:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 10000; i++)
 4618              		.loc 1 2007 0 is_stmt 0
 4619 027e B7F91420 		ldrsh	r2, [r7, #20]
 4620 0282 42F20F73 		movw	r3, #9999
 4621 0286 9A42     		cmp	r2, r3
 4622 0288 EBDD     		ble	.L381
 4623 028a 00E0     		b	.L380
 4624              	.L392:
 4625              		.loc 1 2009 0 is_stmt 1
 4626 028c 00BF     		nop
 4627              	.L380:
2010:../Sources/drivers/mcg/mcg.c ****                 }
2011:../Sources/drivers/mcg/mcg.c **** 
2012:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is rea
 4628              		.loc 1 2012 0
 4629 028e 4FF48043 		mov	r3, #16384
 4630 0292 C4F20603 		movt	r3, 16390
 4631 0296 9B79     		ldrb	r3, [r3, #6]
 4632 0298 DBB2     		uxtb	r3, r3
 4633 029a 03F00203 		and	r3, r3, #2
 4634 029e 002B     		cmp	r3, #0
 4635 02a0 02D1     		bne	.L377
 4636              		.loc 1 2012 0 is_stmt 0
 4637 02a2 4FF02303 		mov	r3, #35
 4638 02a6 60E0     		b	.L359
 4639              	.L377:
2013:../Sources/drivers/mcg/mcg.c ****         }
2014:../Sources/drivers/mcg/mcg.c **** 
2015:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
2016:../Sources/drivers/mcg/mcg.c **** 
2017:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4640              		.loc 1 2017 0 is_stmt 1
 4641 02a8 4FF00003 		mov	r3, #0
 4642 02ac BB82     		strh	r3, [r7, #20]	@ movhi
 4643 02ae 0DE0     		b	.L382
 4644              	.L385:
2018:../Sources/drivers/mcg/mcg.c ****         {
2019:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early i
 4645              		.loc 1 2019 0
 4646 02b0 4FF48043 		mov	r3, #16384
 4647 02b4 C4F20603 		movt	r3, 16390
 4648 02b8 9B79     		ldrb	r3, [r3, #6]
 4649 02ba DBB2     		uxtb	r3, r3
 4650 02bc 03F01003 		and	r3, r3, #16
 4651 02c0 002B     		cmp	r3, #0
 4652 02c2 0AD0     		beq	.L393
 4653              	.L383:
2017:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4654              		.loc 1 2017 0
 4655 02c4 BB8A     		ldrh	r3, [r7, #20]	@ movhi
 4656 02c6 03F10103 		add	r3, r3, #1
 4657 02ca BB82     		strh	r3, [r7, #20]	@ movhi
 4658              	.L382:
2017:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4659              		.loc 1 2017 0 is_stmt 0
 4660 02cc B7F91420 		ldrsh	r2, [r7, #20]
 4661 02d0 40F2CF73 		movw	r3, #1999
 4662 02d4 9A42     		cmp	r2, r3
 4663 02d6 EBDD     		ble	.L385
 4664 02d8 00E0     		b	.L384
 4665              	.L393:
 4666              		.loc 1 2019 0 is_stmt 1
 4667 02da 00BF     		nop
 4668              	.L384:
2020:../Sources/drivers/mcg/mcg.c ****         }
2021:../Sources/drivers/mcg/mcg.c **** 
2022:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 4669              		.loc 1 2022 0
 4670 02dc 4FF48043 		mov	r3, #16384
 4671 02e0 C4F20603 		movt	r3, 16390
 4672 02e4 9B79     		ldrb	r3, [r3, #6]
 4673 02e6 DBB2     		uxtb	r3, r3
 4674 02e8 03F01003 		and	r3, r3, #16
 4675 02ec 002B     		cmp	r3, #0
 4676 02ee 02D0     		beq	.L386
 4677              		.loc 1 2022 0 is_stmt 0
 4678 02f0 4FF01103 		mov	r3, #17
 4679 02f4 39E0     		b	.L359
 4680              	.L386:
2023:../Sources/drivers/mcg/mcg.c **** 
2024:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
2025:../Sources/drivers/mcg/mcg.c **** 
2026:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4681              		.loc 1 2026 0 is_stmt 1
 4682 02f6 4FF00003 		mov	r3, #0
 4683 02fa BB82     		strh	r3, [r7, #20]	@ movhi
 4684 02fc 0FE0     		b	.L387
 4685              	.L390:
2027:../Sources/drivers/mcg/mcg.c ****         {
2028:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early i
 4686              		.loc 1 2028 0
 4687 02fe 4FF48043 		mov	r3, #16384
 4688 0302 C4F20603 		movt	r3, 16390
 4689 0306 9B79     		ldrb	r3, [r3, #6]
 4690 0308 DBB2     		uxtb	r3, r3
 4691 030a 03F00C03 		and	r3, r3, #12
 4692 030e 4FEA9303 		lsr	r3, r3, #2
 4693 0312 002B     		cmp	r3, #0
 4694 0314 0AD0     		beq	.L394
 4695              	.L388:
2026:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4696              		.loc 1 2026 0
 4697 0316 BB8A     		ldrh	r3, [r7, #20]	@ movhi
 4698 0318 03F10103 		add	r3, r3, #1
 4699 031c BB82     		strh	r3, [r7, #20]	@ movhi
 4700              	.L387:
2026:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4701              		.loc 1 2026 0 is_stmt 0
 4702 031e B7F91420 		ldrsh	r2, [r7, #20]
 4703 0322 40F2CF73 		movw	r3, #1999
 4704 0326 9A42     		cmp	r2, r3
 4705 0328 E9DD     		ble	.L390
 4706 032a 00E0     		b	.L389
 4707              	.L394:
 4708              		.loc 1 2028 0 is_stmt 1
 4709 032c 00BF     		nop
 4710              	.L389:
2029:../Sources/drivers/mcg/mcg.c ****         }
2030:../Sources/drivers/mcg/mcg.c **** 
2031:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check FLLK is re
 4711              		.loc 1 2031 0
 4712 032e 4FF48043 		mov	r3, #16384
 4713 0332 C4F20603 		movt	r3, 16390
 4714 0336 9B79     		ldrb	r3, [r3, #6]
 4715 0338 DBB2     		uxtb	r3, r3
 4716 033a 03F00C03 		and	r3, r3, #12
 4717 033e 4FEA9303 		lsr	r3, r3, #2
 4718 0342 002B     		cmp	r3, #0
 4719 0344 02D0     		beq	.L391
 4720              		.loc 1 2031 0 is_stmt 0
 4721 0346 4FF01803 		mov	r3, #24
 4722 034a 0EE0     		b	.L359
 4723              	.L391:
2032:../Sources/drivers/mcg/mcg.c **** 
2033:../Sources/drivers/mcg/mcg.c ****     // Now in FEE
2034:../Sources/drivers/mcg/mcg.c ****     // It is recommended that the clock monitor is enabled when using an external clock as the cloc
2035:../Sources/drivers/mcg/mcg.c ****     // It is enabled here but can be removed if this is not required.
2036:../Sources/drivers/mcg/mcg.c ****     // The clock monitor MUST be disabled when returning to a non-external clock mode (FEI, FBI and
2037:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 4724              		.loc 1 2037 0 is_stmt 1
 4725 034c 4FF48043 		mov	r3, #16384
 4726 0350 C4F20603 		movt	r3, 16390
 4727 0354 4FF48042 		mov	r2, #16384
 4728 0358 C4F20602 		movt	r2, 16390
 4729 035c 5279     		ldrb	r2, [r2, #5]
 4730 035e D2B2     		uxtb	r2, r2
 4731 0360 42F02002 		orr	r2, r2, #32
 4732 0364 D2B2     		uxtb	r2, r2
 4733 0366 5A71     		strb	r2, [r3, #5]
2038:../Sources/drivers/mcg/mcg.c ****     return mcg_out; // MCGOUT frequency equals FLL frequency
 4734              		.loc 1 2038 0
 4735 0368 FB68     		ldr	r3, [r7, #12]
 4736              	.L359:
2039:../Sources/drivers/mcg/mcg.c **** }                   //fbi_fee
 4737              		.loc 1 2039 0
 4738 036a 1846     		mov	r0, r3
 4739 036c 07F11807 		add	r7, r7, #24
 4740 0370 BD46     		mov	sp, r7
 4741 0372 80BD     		pop	{r7, pc}
 4742              		.cfi_endproc
 4743              	.LFE18:
 4745              		.section	.text.fee_fbi,"ax",%progbits
 4746              		.align	2
 4747              		.global	fee_fbi
 4748              		.thumb
 4749              		.thumb_func
 4751              	fee_fbi:
 4752              	.LFB19:
2040:../Sources/drivers/mcg/mcg.c **** 
2041:../Sources/drivers/mcg/mcg.c **** /* */
2042:../Sources/drivers/mcg/mcg.c **** 
2043:../Sources/drivers/mcg/mcg.c **** int fee_fbi
2044:../Sources/drivers/mcg/mcg.c **** (
2045:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
2046:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select
2047:../Sources/drivers/mcg/mcg.c **** )
2048:../Sources/drivers/mcg/mcg.c **** {
 4753              		.loc 1 2048 0
 4754              		.cfi_startproc
 4755              		@ args = 0, pretend = 0, frame = 16
 4756              		@ frame_needed = 1, uses_anonymous_args = 0
 4757              		@ link register save eliminated.
 4758 0000 80B4     		push	{r7}
 4759              	.LCFI57:
 4760              		.cfi_def_cfa_offset 4
 4761              		.cfi_offset 7, -4
 4762 0002 85B0     		sub	sp, sp, #20
 4763              	.LCFI58:
 4764              		.cfi_def_cfa_offset 24
 4765 0004 00AF     		add	r7, sp, #0
 4766              	.LCFI59:
 4767              		.cfi_def_cfa_register 7
 4768 0006 7860     		str	r0, [r7, #4]
 4769 0008 0B46     		mov	r3, r1
 4770 000a FB70     		strb	r3, [r7, #3]
2049:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2050:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2051:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2052:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2053:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2054:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2055:../Sources/drivers/mcg/mcg.c ****     unsigned char   fcrdiv_val;
2056:../Sources/drivers/mcg/mcg.c ****     short           i;
2057:../Sources/drivers/mcg/mcg.c **** 
2058:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2059:../Sources/drivers/mcg/mcg.c **** 
2060:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2061:../Sources/drivers/mcg/mcg.c **** 
2062:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2063:../Sources/drivers/mcg/mcg.c **** 
2064:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2065:../Sources/drivers/mcg/mcg.c **** 
2066:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2067:../Sources/drivers/mcg/mcg.c **** 
2068:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2069:../Sources/drivers/mcg/mcg.c **** 
2070:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FEE mode
2071:../Sources/drivers/mcg/mcg.c **** 
2072:../Sources/drivers/mcg/mcg.c ****     if
2073:../Sources/drivers/mcg/mcg.c ****     (
2074:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 4771              		.loc 1 2074 0
 4772 000c 4FF48043 		mov	r3, #16384
 4773 0010 C4F20603 		movt	r3, 16390
 4774 0014 9B79     		ldrb	r3, [r3, #6]
 4775 0016 DBB2     		uxtb	r3, r3
 4776 0018 03F00C03 		and	r3, r3, #12
 4777 001c 4FEA9303 		lsr	r3, r3, #2
2073:../Sources/drivers/mcg/mcg.c ****     (
 4778              		.loc 1 2073 0
 4779 0020 002B     		cmp	r3, #0
 4780 0022 13D1     		bne	.L396
2075:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 4781              		.loc 1 2075 0
 4782 0024 4FF48043 		mov	r3, #16384
 4783 0028 C4F20603 		movt	r3, 16390
 4784 002c 9B79     		ldrb	r3, [r3, #6]
 4785 002e DBB2     		uxtb	r3, r3
 4786 0030 03F01003 		and	r3, r3, #16
 4787 0034 002B     		cmp	r3, #0
 4788 0036 09D1     		bne	.L396
2076:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))
 4789              		.loc 1 2076 0
 4790 0038 4FF48043 		mov	r3, #16384
 4791 003c C4F20603 		movt	r3, 16390
 4792 0040 9B79     		ldrb	r3, [r3, #6]
 4793 0042 DBB2     		uxtb	r3, r3
 4794 0044 03F02003 		and	r3, r3, #32
2074:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 4795              		.loc 1 2074 0
 4796 0048 002B     		cmp	r3, #0
 4797 004a 02D0     		beq	.L397
 4798              	.L396:
2077:../Sources/drivers/mcg/mcg.c ****          )
2078:../Sources/drivers/mcg/mcg.c ****     )                       // check PLLS mux has selected FLL
2079:../Sources/drivers/mcg/mcg.c ****         {
2080:../Sources/drivers/mcg/mcg.c ****             return 0x2;         // return error code
 4799              		.loc 1 2080 0
 4800 004c 4FF00203 		mov	r3, #2
 4801 0050 17E1     		b	.L398
 4802              	.L397:
2081:../Sources/drivers/mcg/mcg.c ****         }
2082:../Sources/drivers/mcg/mcg.c **** 
2083:../Sources/drivers/mcg/mcg.c ****     // Check that the irc frequency matches the selected IRC
2084:../Sources/drivers/mcg/mcg.c **** 
2085:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
 4803              		.loc 1 2085 0
 4804 0052 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 4805 0054 002B     		cmp	r3, #0
 4806 0056 0CD1     		bne	.L399
2086:../Sources/drivers/mcg/mcg.c ****         {
2087:../Sources/drivers/mcg/mcg.c ****             if((irc_freq < 31250) || (irc_freq > 39063))
 4807              		.loc 1 2087 0
 4808 0058 7A68     		ldr	r2, [r7, #4]
 4809 005a 47F61123 		movw	r3, #31249
 4810 005e 9A42     		cmp	r2, r3
 4811 0060 04DD     		ble	.L400
 4812              		.loc 1 2087 0 is_stmt 0
 4813 0062 7A68     		ldr	r2, [r7, #4]
 4814 0064 49F69703 		movw	r3, #39063
 4815 0068 9A42     		cmp	r2, r3
 4816 006a 13DD     		ble	.L401
 4817              	.L400:
2088:../Sources/drivers/mcg/mcg.c ****                 {
2089:../Sources/drivers/mcg/mcg.c ****                     return 0x31;
 4818              		.loc 1 2089 0 is_stmt 1
 4819 006c 4FF03103 		mov	r3, #49
 4820 0070 07E1     		b	.L398
 4821              	.L399:
2090:../Sources/drivers/mcg/mcg.c ****                 }
2091:../Sources/drivers/mcg/mcg.c ****         }
2092:../Sources/drivers/mcg/mcg.c ****     else
2093:../Sources/drivers/mcg/mcg.c ****         {
2094:../Sources/drivers/mcg/mcg.c ****             if((irc_freq < 3000000) || (irc_freq > 5000000))
 4822              		.loc 1 2094 0
 4823 0072 7A68     		ldr	r2, [r7, #4]
 4824 0074 4CF2BF63 		movw	r3, #50879
 4825 0078 C0F22D03 		movt	r3, 45
 4826 007c 9A42     		cmp	r2, r3
 4827 007e 06DD     		ble	.L402
 4828              		.loc 1 2094 0 is_stmt 0
 4829 0080 7A68     		ldr	r2, [r7, #4]
 4830 0082 44F64033 		movw	r3, #19264
 4831 0086 C0F24C03 		movt	r3, 76
 4832 008a 9A42     		cmp	r2, r3
 4833 008c 02DD     		ble	.L401
 4834              	.L402:
2095:../Sources/drivers/mcg/mcg.c ****                 {
2096:../Sources/drivers/mcg/mcg.c ****                     return 0x32;    // Fast IRC freq
 4835              		.loc 1 2096 0 is_stmt 1
 4836 008e 4FF03203 		mov	r3, #50
 4837 0092 F6E0     		b	.L398
 4838              	.L401:
2097:../Sources/drivers/mcg/mcg.c ****                 }
2098:../Sources/drivers/mcg/mcg.c ****         }
2099:../Sources/drivers/mcg/mcg.c **** 
2100:../Sources/drivers/mcg/mcg.c ****     // Select the required IRC
2101:../Sources/drivers/mcg/mcg.c **** 
2102:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 4839              		.loc 1 2102 0
 4840 0094 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 4841 0096 002B     		cmp	r3, #0
 4842 0098 0ED0     		beq	.L403
2103:../Sources/drivers/mcg/mcg.c ****         {
2104:../Sources/drivers/mcg/mcg.c ****             MCG_C2 |= MCG_C2_IRCS_MASK;                     // select fast IRC by setting IRCS
 4843              		.loc 1 2104 0
 4844 009a 4FF48043 		mov	r3, #16384
 4845 009e C4F20603 		movt	r3, 16390
 4846 00a2 4FF48042 		mov	r2, #16384
 4847 00a6 C4F20602 		movt	r2, 16390
 4848 00aa 5278     		ldrb	r2, [r2, #1]
 4849 00ac D2B2     		uxtb	r2, r2
 4850 00ae 42F00102 		orr	r2, r2, #1
 4851 00b2 D2B2     		uxtb	r2, r2
 4852 00b4 5A70     		strb	r2, [r3, #1]
 4853 00b6 0DE0     		b	.L404
 4854              	.L403:
2105:../Sources/drivers/mcg/mcg.c ****         }
2106:../Sources/drivers/mcg/mcg.c ****     else
2107:../Sources/drivers/mcg/mcg.c ****         {
2108:../Sources/drivers/mcg/mcg.c ****             MCG_C2 &= ~MCG_C2_IRCS_MASK;                    // select slow IRC by clearing IRCS
 4855              		.loc 1 2108 0
 4856 00b8 4FF48043 		mov	r3, #16384
 4857 00bc C4F20603 		movt	r3, 16390
 4858 00c0 4FF48042 		mov	r2, #16384
 4859 00c4 C4F20602 		movt	r2, 16390
 4860 00c8 5278     		ldrb	r2, [r2, #1]
 4861 00ca D2B2     		uxtb	r2, r2
 4862 00cc 22F00102 		bic	r2, r2, #1
 4863 00d0 D2B2     		uxtb	r2, r2
 4864 00d2 5A70     		strb	r2, [r3, #1]
 4865              	.L404:
2109:../Sources/drivers/mcg/mcg.c ****         }
2110:../Sources/drivers/mcg/mcg.c **** 
2111:../Sources/drivers/mcg/mcg.c ****     // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
2112:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 4866              		.loc 1 2112 0
 4867 00d4 4FF48043 		mov	r3, #16384
 4868 00d8 C4F20603 		movt	r3, 16390
 4869 00dc 4FF48042 		mov	r2, #16384
 4870 00e0 C4F20602 		movt	r2, 16390
 4871 00e4 5279     		ldrb	r2, [r2, #5]
 4872 00e6 D2B2     		uxtb	r2, r2
 4873 00e8 22F02002 		bic	r2, r2, #32
 4874 00ec D2B2     		uxtb	r2, r2
 4875 00ee 5A71     		strb	r2, [r3, #5]
2113:../Sources/drivers/mcg/mcg.c ****     // Select the IRC as the CLKS mux selection
2114:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK;       // set IREFS and select IRC as MCGOUT
 4876              		.loc 1 2114 0
 4877 00f0 4FF48043 		mov	r3, #16384
 4878 00f4 C4F20603 		movt	r3, 16390
 4879 00f8 4FF48042 		mov	r2, #16384
 4880 00fc C4F20602 		movt	r2, 16390
 4881 0100 1278     		ldrb	r2, [r2, #0]
 4882 0102 D2B2     		uxtb	r2, r2
 4883 0104 42F04402 		orr	r2, r2, #68
 4884 0108 D2B2     		uxtb	r2, r2
 4885 010a 1A70     		strb	r2, [r3, #0]
2115:../Sources/drivers/mcg/mcg.c **** 
2116:../Sources/drivers/mcg/mcg.c ****     // wait until internal reference switches to requested irc.
2117:../Sources/drivers/mcg/mcg.c **** 
2118:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
 4886              		.loc 1 2118 0
 4887 010c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 4888 010e 002B     		cmp	r3, #0
 4889 0110 26D1     		bne	.L405
2119:../Sources/drivers/mcg/mcg.c ****         {
2120:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 4890              		.loc 1 2120 0
 4891 0112 4FF00003 		mov	r3, #0
 4892 0116 FB81     		strh	r3, [r7, #14]	@ movhi
 4893 0118 0DE0     		b	.L406
 4894              	.L409:
2121:../Sources/drivers/mcg/mcg.c ****                 {
2122:../Sources/drivers/mcg/mcg.c ****                     if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears b
 4895              		.loc 1 2122 0
 4896 011a 4FF48043 		mov	r3, #16384
 4897 011e C4F20603 		movt	r3, 16390
 4898 0122 9B79     		ldrb	r3, [r3, #6]
 4899 0124 DBB2     		uxtb	r3, r3
 4900 0126 03F00103 		and	r3, r3, #1
 4901 012a 002B     		cmp	r3, #0
 4902 012c 0AD0     		beq	.L426
 4903              	.L407:
2120:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 4904              		.loc 1 2120 0
 4905 012e FB89     		ldrh	r3, [r7, #14]	@ movhi
 4906 0130 03F10103 		add	r3, r3, #1
 4907 0134 FB81     		strh	r3, [r7, #14]	@ movhi
 4908              	.L406:
2120:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 4909              		.loc 1 2120 0 is_stmt 0
 4910 0136 B7F90E20 		ldrsh	r2, [r7, #14]
 4911 013a 40F2CF73 		movw	r3, #1999
 4912 013e 9A42     		cmp	r2, r3
 4913 0140 EBDD     		ble	.L409
 4914 0142 00E0     		b	.L408
 4915              	.L426:
 4916              		.loc 1 2122 0 is_stmt 1
 4917 0144 00BF     		nop
 4918              	.L408:
2123:../Sources/drivers/mcg/mcg.c ****                 }
2124:../Sources/drivers/mcg/mcg.c **** 
2125:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) return 0x13;       // check bit is really clear and return
 4919              		.loc 1 2125 0
 4920 0146 4FF48043 		mov	r3, #16384
 4921 014a C4F20603 		movt	r3, 16390
 4922 014e 9B79     		ldrb	r3, [r3, #6]
 4923 0150 DBB2     		uxtb	r3, r3
 4924 0152 03F00103 		and	r3, r3, #1
 4925 0156 002B     		cmp	r3, #0
 4926 0158 29D0     		beq	.L410
 4927              		.loc 1 2125 0 is_stmt 0
 4928 015a 4FF01303 		mov	r3, #19
 4929 015e 90E0     		b	.L398
 4930              	.L405:
2126:../Sources/drivers/mcg/mcg.c ****         }
2127:../Sources/drivers/mcg/mcg.c ****     else
2128:../Sources/drivers/mcg/mcg.c ****         {
2129:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 4931              		.loc 1 2129 0 is_stmt 1
 4932 0160 4FF00003 		mov	r3, #0
 4933 0164 FB81     		strh	r3, [r7, #14]	@ movhi
 4934 0166 0DE0     		b	.L411
 4935              	.L414:
2130:../Sources/drivers/mcg/mcg.c ****                 {
2131:../Sources/drivers/mcg/mcg.c ****                     if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets bef
 4936              		.loc 1 2131 0
 4937 0168 4FF48043 		mov	r3, #16384
 4938 016c C4F20603 		movt	r3, 16390
 4939 0170 9B79     		ldrb	r3, [r3, #6]
 4940 0172 DBB2     		uxtb	r3, r3
 4941 0174 03F00103 		and	r3, r3, #1
 4942 0178 002B     		cmp	r3, #0
 4943 017a 0AD1     		bne	.L427
 4944              	.L412:
2129:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 4945              		.loc 1 2129 0
 4946 017c FB89     		ldrh	r3, [r7, #14]	@ movhi
 4947 017e 03F10103 		add	r3, r3, #1
 4948 0182 FB81     		strh	r3, [r7, #14]	@ movhi
 4949              	.L411:
2129:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 4950              		.loc 1 2129 0 is_stmt 0
 4951 0184 B7F90E20 		ldrsh	r2, [r7, #14]
 4952 0188 40F2CF73 		movw	r3, #1999
 4953 018c 9A42     		cmp	r2, r3
 4954 018e EBDD     		ble	.L414
 4955 0190 00E0     		b	.L413
 4956              	.L427:
 4957              		.loc 1 2131 0 is_stmt 1
 4958 0192 00BF     		nop
 4959              	.L413:
2132:../Sources/drivers/mcg/mcg.c ****                 }
2133:../Sources/drivers/mcg/mcg.c **** 
2134:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) return 0x14;    // check bit is really set and return w
 4960              		.loc 1 2134 0
 4961 0194 4FF48043 		mov	r3, #16384
 4962 0198 C4F20603 		movt	r3, 16390
 4963 019c 9B79     		ldrb	r3, [r3, #6]
 4964 019e DBB2     		uxtb	r3, r3
 4965 01a0 03F00103 		and	r3, r3, #1
 4966 01a4 002B     		cmp	r3, #0
 4967 01a6 02D1     		bne	.L410
 4968              		.loc 1 2134 0 is_stmt 0
 4969 01a8 4FF01403 		mov	r3, #20
 4970 01ac 69E0     		b	.L398
 4971              	.L410:
2135:../Sources/drivers/mcg/mcg.c ****         }
2136:../Sources/drivers/mcg/mcg.c **** 
2137:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
2138:../Sources/drivers/mcg/mcg.c **** 
2139:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4972              		.loc 1 2139 0 is_stmt 1
 4973 01ae 4FF00003 		mov	r3, #0
 4974 01b2 FB81     		strh	r3, [r7, #14]	@ movhi
 4975 01b4 0FE0     		b	.L415
 4976              	.L418:
2140:../Sources/drivers/mcg/mcg.c ****         {
2141:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;     // jump out ear
 4977              		.loc 1 2141 0
 4978 01b6 4FF48043 		mov	r3, #16384
 4979 01ba C4F20603 		movt	r3, 16390
 4980 01be 9B79     		ldrb	r3, [r3, #6]
 4981 01c0 DBB2     		uxtb	r3, r3
 4982 01c2 03F00C03 		and	r3, r3, #12
 4983 01c6 4FEA9303 		lsr	r3, r3, #2
 4984 01ca 012B     		cmp	r3, #1
 4985 01cc 0AD0     		beq	.L428
 4986              	.L416:
2139:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4987              		.loc 1 2139 0
 4988 01ce FB89     		ldrh	r3, [r7, #14]	@ movhi
 4989 01d0 03F10103 		add	r3, r3, #1
 4990 01d4 FB81     		strh	r3, [r7, #14]	@ movhi
 4991              	.L415:
2139:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4992              		.loc 1 2139 0 is_stmt 0
 4993 01d6 B7F90E20 		ldrsh	r2, [r7, #14]
 4994 01da 40F2CF73 		movw	r3, #1999
 4995 01de 9A42     		cmp	r2, r3
 4996 01e0 E9DD     		ble	.L418
 4997 01e2 00E0     		b	.L417
 4998              	.L428:
 4999              		.loc 1 2141 0 is_stmt 1
 5000 01e4 00BF     		nop
 5001              	.L417:
2142:../Sources/drivers/mcg/mcg.c ****         }
2143:../Sources/drivers/mcg/mcg.c **** 
2144:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19;   // check IRC is rea
 5002              		.loc 1 2144 0
 5003 01e6 4FF48043 		mov	r3, #16384
 5004 01ea C4F20603 		movt	r3, 16390
 5005 01ee 9B79     		ldrb	r3, [r3, #6]
 5006 01f0 DBB2     		uxtb	r3, r3
 5007 01f2 03F00C03 		and	r3, r3, #12
 5008 01f6 4FEA9303 		lsr	r3, r3, #2
 5009 01fa 012B     		cmp	r3, #1
 5010 01fc 02D0     		beq	.L419
 5011              		.loc 1 2144 0 is_stmt 0
 5012 01fe 4FF01903 		mov	r3, #25
 5013 0202 3EE0     		b	.L398
 5014              	.L419:
2145:../Sources/drivers/mcg/mcg.c **** 
2146:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to set
2147:../Sources/drivers/mcg/mcg.c **** 
2148:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5015              		.loc 1 2148 0 is_stmt 1
 5016 0204 4FF00003 		mov	r3, #0
 5017 0208 FB81     		strh	r3, [r7, #14]	@ movhi
 5018 020a 0DE0     		b	.L420
 5019              	.L423:
2149:../Sources/drivers/mcg/mcg.c ****         {
2150:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loo
 5020              		.loc 1 2150 0
 5021 020c 4FF48043 		mov	r3, #16384
 5022 0210 C4F20603 		movt	r3, 16390
 5023 0214 9B79     		ldrb	r3, [r3, #6]
 5024 0216 DBB2     		uxtb	r3, r3
 5025 0218 03F01003 		and	r3, r3, #16
 5026 021c 002B     		cmp	r3, #0
 5027 021e 0AD1     		bne	.L429
 5028              	.L421:
2148:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5029              		.loc 1 2148 0
 5030 0220 FB89     		ldrh	r3, [r7, #14]	@ movhi
 5031 0222 03F10103 		add	r3, r3, #1
 5032 0226 FB81     		strh	r3, [r7, #14]	@ movhi
 5033              	.L420:
2148:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5034              		.loc 1 2148 0 is_stmt 0
 5035 0228 B7F90E20 		ldrsh	r2, [r7, #14]
 5036 022c 40F2CF73 		movw	r3, #1999
 5037 0230 9A42     		cmp	r2, r3
 5038 0232 EBDD     		ble	.L423
 5039 0234 00E0     		b	.L422
 5040              	.L429:
 5041              		.loc 1 2150 0 is_stmt 1
 5042 0236 00BF     		nop
 5043              	.L422:
2151:../Sources/drivers/mcg/mcg.c ****         }
2152:../Sources/drivers/mcg/mcg.c **** 
2153:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 5044              		.loc 1 2153 0
 5045 0238 4FF48043 		mov	r3, #16384
 5046 023c C4F20603 		movt	r3, 16390
 5047 0240 9B79     		ldrb	r3, [r3, #6]
 5048 0242 DBB2     		uxtb	r3, r3
 5049 0244 03F01003 		and	r3, r3, #16
 5050 0248 002B     		cmp	r3, #0
 5051 024a 02D1     		bne	.L424
 5052              		.loc 1 2153 0 is_stmt 0
 5053 024c 4FF01203 		mov	r3, #18
 5054 0250 17E0     		b	.L398
 5055              	.L424:
2154:../Sources/drivers/mcg/mcg.c **** 
2155:../Sources/drivers/mcg/mcg.c ****     // Now in FBI mode
2156:../Sources/drivers/mcg/mcg.c **** 
2157:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 5056              		.loc 1 2157 0 is_stmt 1
 5057 0252 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5058 0254 002B     		cmp	r3, #0
 5059 0256 13D0     		beq	.L425
2158:../Sources/drivers/mcg/mcg.c ****         {
2159:../Sources/drivers/mcg/mcg.c ****             fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculat
 5060              		.loc 1 2159 0
 5061 0258 4FF48043 		mov	r3, #16384
 5062 025c C4F20603 		movt	r3, 16390
 5063 0260 1B7A     		ldrb	r3, [r3, #8]
 5064 0262 DBB2     		uxtb	r3, r3
 5065 0264 03F00E03 		and	r3, r3, #14
 5066 0268 4FEA5303 		lsr	r3, r3, #1
 5067 026c 4FF00102 		mov	r2, #1
 5068 0270 02FA03F3 		lsl	r3, r2, r3
 5069 0274 7B73     		strb	r3, [r7, #13]
2160:../Sources/drivers/mcg/mcg.c ****             return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided b
 5070              		.loc 1 2160 0
 5071 0276 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 5072 0278 7A68     		ldr	r2, [r7, #4]
 5073 027a 92FBF3F3 		sdiv	r3, r2, r3
 5074 027e 00E0     		b	.L398
 5075              	.L425:
2161:../Sources/drivers/mcg/mcg.c ****         }
2162:../Sources/drivers/mcg/mcg.c ****     else
2163:../Sources/drivers/mcg/mcg.c ****         {
2164:../Sources/drivers/mcg/mcg.c ****             return irc_freq;                // MCGOUT frequency equals slow IRC frequency
 5076              		.loc 1 2164 0
 5077 0280 7B68     		ldr	r3, [r7, #4]
 5078              	.L398:
2165:../Sources/drivers/mcg/mcg.c ****         }
2166:../Sources/drivers/mcg/mcg.c **** }   // fee_fbi
 5079              		.loc 1 2166 0
 5080 0282 1846     		mov	r0, r3
 5081 0284 07F11407 		add	r7, r7, #20
 5082 0288 BD46     		mov	sp, r7
 5083 028a 80BC     		pop	{r7}
 5084 028c 7047     		bx	lr
 5085              		.cfi_endproc
 5086              	.LFE19:
 5088 028e 00BF     		.section	.text.fbi_fei,"ax",%progbits
 5089              		.align	2
 5090              		.global	fbi_fei
 5091              		.thumb
 5092              		.thumb_func
 5094              	fbi_fei:
 5095              	.LFB20:
2167:../Sources/drivers/mcg/mcg.c **** 
2168:../Sources/drivers/mcg/mcg.c **** /* */
2169:../Sources/drivers/mcg/mcg.c **** 
2170:../Sources/drivers/mcg/mcg.c **** int fbi_fei
2171:../Sources/drivers/mcg/mcg.c **** (int slow_irc_freq)
2172:../Sources/drivers/mcg/mcg.c **** {
 5096              		.loc 1 2172 0
 5097              		.cfi_startproc
 5098              		@ args = 0, pretend = 0, frame = 24
 5099              		@ frame_needed = 1, uses_anonymous_args = 0
 5100 0000 80B5     		push	{r7, lr}
 5101              	.LCFI60:
 5102              		.cfi_def_cfa_offset 8
 5103              		.cfi_offset 7, -8
 5104              		.cfi_offset 14, -4
 5105 0002 86B0     		sub	sp, sp, #24
 5106              	.LCFI61:
 5107              		.cfi_def_cfa_offset 32
 5108 0004 00AF     		add	r7, sp, #0
 5109              	.LCFI62:
 5110              		.cfi_def_cfa_register 7
 5111 0006 7860     		str	r0, [r7, #4]
2173:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2174:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2175:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2176:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2177:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2178:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2179:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
2180:../Sources/drivers/mcg/mcg.c ****     short           i;
2181:../Sources/drivers/mcg/mcg.c ****     int             mcg_out;
2182:../Sources/drivers/mcg/mcg.c **** 
2183:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2184:../Sources/drivers/mcg/mcg.c **** 
2185:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2186:../Sources/drivers/mcg/mcg.c **** 
2187:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2188:../Sources/drivers/mcg/mcg.c **** 
2189:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2190:../Sources/drivers/mcg/mcg.c **** 
2191:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2192:../Sources/drivers/mcg/mcg.c **** 
2193:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2194:../Sources/drivers/mcg/mcg.c **** 
2195:../Sources/drivers/mcg/mcg.c ****     // check if in FBI mode
2196:../Sources/drivers/mcg/mcg.c **** 
2197:../Sources/drivers/mcg/mcg.c ****     if
2198:../Sources/drivers/mcg/mcg.c ****     (
2199:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 5112              		.loc 1 2199 0
 5113 0008 4FF48043 		mov	r3, #16384
 5114 000c C4F20603 		movt	r3, 16390
 5115 0010 9B79     		ldrb	r3, [r3, #6]
 5116 0012 DBB2     		uxtb	r3, r3
 5117 0014 03F00C03 		and	r3, r3, #12
 5118 0018 4FEA9303 		lsr	r3, r3, #2
2198:../Sources/drivers/mcg/mcg.c ****     (
 5119              		.loc 1 2198 0
 5120 001c 012B     		cmp	r3, #1
 5121 001e 1DD1     		bne	.L431
2200:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 5122              		.loc 1 2200 0
 5123 0020 4FF48043 		mov	r3, #16384
 5124 0024 C4F20603 		movt	r3, 16390
 5125 0028 9B79     		ldrb	r3, [r3, #6]
 5126 002a DBB2     		uxtb	r3, r3
 5127 002c 03F01003 		and	r3, r3, #16
 5128 0030 002B     		cmp	r3, #0
 5129 0032 13D0     		beq	.L431
2201:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 5130              		.loc 1 2201 0
 5131 0034 4FF48043 		mov	r3, #16384
 5132 0038 C4F20603 		movt	r3, 16390
 5133 003c 9B79     		ldrb	r3, [r3, #6]
 5134 003e DBB2     		uxtb	r3, r3
 5135 0040 03F02003 		and	r3, r3, #32
 5136 0044 002B     		cmp	r3, #0
 5137 0046 09D1     		bne	.L431
2202:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 5138              		.loc 1 2202 0
 5139 0048 4FF48043 		mov	r3, #16384
 5140 004c C4F20603 		movt	r3, 16390
 5141 0050 5B78     		ldrb	r3, [r3, #1]
 5142 0052 DBB2     		uxtb	r3, r3
 5143 0054 03F00203 		and	r3, r3, #2
2199:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 5144              		.loc 1 2199 0
 5145 0058 002B     		cmp	r3, #0
 5146 005a 02D0     		beq	.L432
 5147              	.L431:
2203:../Sources/drivers/mcg/mcg.c ****          )
2204:../Sources/drivers/mcg/mcg.c ****     )                   // check LP bit is clear
2205:../Sources/drivers/mcg/mcg.c ****         {
2206:../Sources/drivers/mcg/mcg.c ****             return 0x3;     // MCG not in correct mode return fail code
 5148              		.loc 1 2206 0
 5149 005c 4FF00303 		mov	r3, #3
 5150 0060 7CE0     		b	.L433
 5151              	.L432:
2207:../Sources/drivers/mcg/mcg.c ****         }
2208:../Sources/drivers/mcg/mcg.c **** 
2209:../Sources/drivers/mcg/mcg.c ****     // Check IRC frequency is within spec.
2210:../Sources/drivers/mcg/mcg.c **** 
2211:../Sources/drivers/mcg/mcg.c ****     if((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 5152              		.loc 1 2211 0
 5153 0062 7A68     		ldr	r2, [r7, #4]
 5154 0064 47F61123 		movw	r3, #31249
 5155 0068 9A42     		cmp	r2, r3
 5156 006a 04DD     		ble	.L434
 5157              		.loc 1 2211 0 is_stmt 0
 5158 006c 7A68     		ldr	r2, [r7, #4]
 5159 006e 49F69703 		movw	r3, #39063
 5160 0072 9A42     		cmp	r2, r3
 5161 0074 02DD     		ble	.L435
 5162              	.L434:
2212:../Sources/drivers/mcg/mcg.c ****         {
2213:../Sources/drivers/mcg/mcg.c ****             return 0x31;
 5163              		.loc 1 2213 0 is_stmt 1
 5164 0076 4FF03103 		mov	r3, #49
 5165 007a 6FE0     		b	.L433
 5166              	.L435:
2214:../Sources/drivers/mcg/mcg.c ****         }
2215:../Sources/drivers/mcg/mcg.c **** 
2216:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
2217:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(slow_irc_freq);
 5167              		.loc 1 2217 0
 5168 007c 7868     		ldr	r0, [r7, #4]
 5169 007e FFF7FEFF 		bl	fll_freq
 5170 0082 3861     		str	r0, [r7, #16]
2218:../Sources/drivers/mcg/mcg.c **** 
2219:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 5171              		.loc 1 2219 0
 5172 0084 3B69     		ldr	r3, [r7, #16]
 5173 0086 3B2B     		cmp	r3, #59
 5174 0088 01DC     		bgt	.L436
2220:../Sources/drivers/mcg/mcg.c ****         {
2221:../Sources/drivers/mcg/mcg.c ****             return mcg_out; // If error code returned, return the code to calling function
 5175              		.loc 1 2221 0
 5176 008a 3B69     		ldr	r3, [r7, #16]
 5177 008c 66E0     		b	.L433
 5178              	.L436:
2222:../Sources/drivers/mcg/mcg.c ****         }
2223:../Sources/drivers/mcg/mcg.c **** 
2224:../Sources/drivers/mcg/mcg.c ****     // Change the CLKS mux to select the FLL output as MCGOUT
2225:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 5179              		.loc 1 2225 0
 5180 008e 4FF48043 		mov	r3, #16384
 5181 0092 C4F20603 		movt	r3, 16390
 5182 0096 1B78     		ldrb	r3, [r3, #0]
 5183 0098 FB73     		strb	r3, [r7, #15]
2226:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                  // clear CLKS field
 5184              		.loc 1 2226 0
 5185 009a FB7B     		ldrb	r3, [r7, #15]
 5186 009c 03F03F03 		and	r3, r3, #63
 5187 00a0 FB73     		strb	r3, [r7, #15]
2227:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_CLKS(0);                     // select FLL as MCGOUT
2228:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_IREFS_MASK;                  // make sure IRC is FLL reference
 5188              		.loc 1 2228 0
 5189 00a2 FB7B     		ldrb	r3, [r7, #15]
 5190 00a4 43F00403 		orr	r3, r3, #4
 5191 00a8 FB73     		strb	r3, [r7, #15]
2229:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;                              // update MCG_C1
 5192              		.loc 1 2229 0
 5193 00aa 4FF48043 		mov	r3, #16384
 5194 00ae C4F20603 		movt	r3, 16390
 5195 00b2 FA7B     		ldrb	r2, [r7, #15]
 5196 00b4 1A70     		strb	r2, [r3, #0]
2230:../Sources/drivers/mcg/mcg.c **** 
2231:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
2232:../Sources/drivers/mcg/mcg.c **** 
2233:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5197              		.loc 1 2233 0
 5198 00b6 4FF00003 		mov	r3, #0
 5199 00ba FB82     		strh	r3, [r7, #22]	@ movhi
 5200 00bc 0DE0     		b	.L437
 5201              	.L440:
2234:../Sources/drivers/mcg/mcg.c ****         {
2235:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST clears before l
 5202              		.loc 1 2235 0
 5203 00be 4FF48043 		mov	r3, #16384
 5204 00c2 C4F20603 		movt	r3, 16390
 5205 00c6 9B79     		ldrb	r3, [r3, #6]
 5206 00c8 DBB2     		uxtb	r3, r3
 5207 00ca 03F01003 		and	r3, r3, #16
 5208 00ce 002B     		cmp	r3, #0
 5209 00d0 0AD1     		bne	.L447
 5210              	.L438:
2233:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5211              		.loc 1 2233 0
 5212 00d2 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 5213 00d4 03F10103 		add	r3, r3, #1
 5214 00d8 FB82     		strh	r3, [r7, #22]	@ movhi
 5215              	.L437:
2233:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5216              		.loc 1 2233 0 is_stmt 0
 5217 00da B7F91620 		ldrsh	r2, [r7, #22]
 5218 00de 40F2CF73 		movw	r3, #1999
 5219 00e2 9A42     		cmp	r2, r3
 5220 00e4 EBDD     		ble	.L440
 5221 00e6 00E0     		b	.L439
 5222              	.L447:
 5223              		.loc 1 2235 0 is_stmt 1
 5224 00e8 00BF     		nop
 5225              	.L439:
2236:../Sources/drivers/mcg/mcg.c ****         }
2237:../Sources/drivers/mcg/mcg.c **** 
2238:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 5226              		.loc 1 2238 0
 5227 00ea 4FF48043 		mov	r3, #16384
 5228 00ee C4F20603 		movt	r3, 16390
 5229 00f2 9B79     		ldrb	r3, [r3, #6]
 5230 00f4 DBB2     		uxtb	r3, r3
 5231 00f6 03F01003 		and	r3, r3, #16
 5232 00fa 002B     		cmp	r3, #0
 5233 00fc 02D1     		bne	.L441
 5234              		.loc 1 2238 0 is_stmt 0
 5235 00fe 4FF01203 		mov	r3, #18
 5236 0102 2BE0     		b	.L433
 5237              	.L441:
2239:../Sources/drivers/mcg/mcg.c **** 
2240:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
2241:../Sources/drivers/mcg/mcg.c **** 
2242:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5238              		.loc 1 2242 0 is_stmt 1
 5239 0104 4FF00003 		mov	r3, #0
 5240 0108 FB82     		strh	r3, [r7, #22]	@ movhi
 5241 010a 0FE0     		b	.L442
 5242              	.L445:
2243:../Sources/drivers/mcg/mcg.c ****         {
2244:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out ear
 5243              		.loc 1 2244 0
 5244 010c 4FF48043 		mov	r3, #16384
 5245 0110 C4F20603 		movt	r3, 16390
 5246 0114 9B79     		ldrb	r3, [r3, #6]
 5247 0116 DBB2     		uxtb	r3, r3
 5248 0118 03F00C03 		and	r3, r3, #12
 5249 011c 4FEA9303 		lsr	r3, r3, #2
 5250 0120 002B     		cmp	r3, #0
 5251 0122 0AD0     		beq	.L448
 5252              	.L443:
2242:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5253              		.loc 1 2242 0
 5254 0124 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 5255 0126 03F10103 		add	r3, r3, #1
 5256 012a FB82     		strh	r3, [r7, #22]	@ movhi
 5257              	.L442:
2242:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5258              		.loc 1 2242 0 is_stmt 0
 5259 012c B7F91620 		ldrsh	r2, [r7, #22]
 5260 0130 40F2CF73 		movw	r3, #1999
 5261 0134 9A42     		cmp	r2, r3
 5262 0136 E9DD     		ble	.L445
 5263 0138 00E0     		b	.L444
 5264              	.L448:
 5265              		.loc 1 2244 0 is_stmt 1
 5266 013a 00BF     		nop
 5267              	.L444:
2245:../Sources/drivers/mcg/mcg.c ****         }
2246:../Sources/drivers/mcg/mcg.c **** 
2247:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check FLL is rea
 5268              		.loc 1 2247 0
 5269 013c 4FF48043 		mov	r3, #16384
 5270 0140 C4F20603 		movt	r3, 16390
 5271 0144 9B79     		ldrb	r3, [r3, #6]
 5272 0146 DBB2     		uxtb	r3, r3
 5273 0148 03F00C03 		and	r3, r3, #12
 5274 014c 4FEA9303 		lsr	r3, r3, #2
 5275 0150 002B     		cmp	r3, #0
 5276 0152 02D0     		beq	.L446
 5277              		.loc 1 2247 0 is_stmt 0
 5278 0154 4FF01803 		mov	r3, #24
 5279 0158 00E0     		b	.L433
 5280              	.L446:
2248:../Sources/drivers/mcg/mcg.c **** 
2249:../Sources/drivers/mcg/mcg.c ****     // Now in FEI mode
2250:../Sources/drivers/mcg/mcg.c ****     return mcg_out;
 5281              		.loc 1 2250 0 is_stmt 1
 5282 015a 3B69     		ldr	r3, [r7, #16]
 5283              	.L433:
2251:../Sources/drivers/mcg/mcg.c **** }   // fbi_fei
 5284              		.loc 1 2251 0
 5285 015c 1846     		mov	r0, r3
 5286 015e 07F11807 		add	r7, r7, #24
 5287 0162 BD46     		mov	sp, r7
 5288 0164 80BD     		pop	{r7, pc}
 5289              		.cfi_endproc
 5290              	.LFE20:
 5292 0166 00BF     		.section	.text.fei_fbi,"ax",%progbits
 5293              		.align	2
 5294              		.global	fei_fbi
 5295              		.thumb
 5296              		.thumb_func
 5298              	fei_fbi:
 5299              	.LFB21:
2252:../Sources/drivers/mcg/mcg.c **** 
2253:../Sources/drivers/mcg/mcg.c **** /* */
2254:../Sources/drivers/mcg/mcg.c **** 
2255:../Sources/drivers/mcg/mcg.c **** int fei_fbi
2256:../Sources/drivers/mcg/mcg.c **** (
2257:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
2258:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select
2259:../Sources/drivers/mcg/mcg.c **** )
2260:../Sources/drivers/mcg/mcg.c **** {
 5300              		.loc 1 2260 0
 5301              		.cfi_startproc
 5302              		@ args = 0, pretend = 0, frame = 16
 5303              		@ frame_needed = 1, uses_anonymous_args = 0
 5304              		@ link register save eliminated.
 5305 0000 80B4     		push	{r7}
 5306              	.LCFI63:
 5307              		.cfi_def_cfa_offset 4
 5308              		.cfi_offset 7, -4
 5309 0002 85B0     		sub	sp, sp, #20
 5310              	.LCFI64:
 5311              		.cfi_def_cfa_offset 24
 5312 0004 00AF     		add	r7, sp, #0
 5313              	.LCFI65:
 5314              		.cfi_def_cfa_register 7
 5315 0006 7860     		str	r0, [r7, #4]
 5316 0008 0B46     		mov	r3, r1
 5317 000a FB70     		strb	r3, [r7, #3]
2261:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2262:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2263:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2264:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2265:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2266:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2267:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
2268:../Sources/drivers/mcg/mcg.c ****     unsigned char   fcrdiv_val;
2269:../Sources/drivers/mcg/mcg.c ****     short           i;
2270:../Sources/drivers/mcg/mcg.c **** 
2271:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2272:../Sources/drivers/mcg/mcg.c **** 
2273:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2274:../Sources/drivers/mcg/mcg.c **** 
2275:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2276:../Sources/drivers/mcg/mcg.c **** 
2277:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2278:../Sources/drivers/mcg/mcg.c **** 
2279:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2280:../Sources/drivers/mcg/mcg.c **** 
2281:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2282:../Sources/drivers/mcg/mcg.c **** 
2283:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FEI mode
2284:../Sources/drivers/mcg/mcg.c **** 
2285:../Sources/drivers/mcg/mcg.c ****     if
2286:../Sources/drivers/mcg/mcg.c ****     (
2287:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 5318              		.loc 1 2287 0
 5319 000c 4FF48043 		mov	r3, #16384
 5320 0010 C4F20603 		movt	r3, 16390
 5321 0014 9B79     		ldrb	r3, [r3, #6]
 5322 0016 DBB2     		uxtb	r3, r3
 5323 0018 03F00C03 		and	r3, r3, #12
 5324 001c 4FEA9303 		lsr	r3, r3, #2
2286:../Sources/drivers/mcg/mcg.c ****     (
 5325              		.loc 1 2286 0
 5326 0020 002B     		cmp	r3, #0
 5327 0022 13D1     		bne	.L450
2288:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
 5328              		.loc 1 2288 0
 5329 0024 4FF48043 		mov	r3, #16384
 5330 0028 C4F20603 		movt	r3, 16390
 5331 002c 9B79     		ldrb	r3, [r3, #6]
 5332 002e DBB2     		uxtb	r3, r3
 5333 0030 03F01003 		and	r3, r3, #16
 5334 0034 002B     		cmp	r3, #0
 5335 0036 09D0     		beq	.L450
2289:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))
 5336              		.loc 1 2289 0
 5337 0038 4FF48043 		mov	r3, #16384
 5338 003c C4F20603 		movt	r3, 16390
 5339 0040 9B79     		ldrb	r3, [r3, #6]
 5340 0042 DBB2     		uxtb	r3, r3
 5341 0044 03F02003 		and	r3, r3, #32
2287:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 5342              		.loc 1 2287 0
 5343 0048 002B     		cmp	r3, #0
 5344 004a 02D0     		beq	.L451
 5345              	.L450:
2290:../Sources/drivers/mcg/mcg.c ****          )
2291:../Sources/drivers/mcg/mcg.c ****     )                       // check PLLS mux has selected FLL
2292:../Sources/drivers/mcg/mcg.c ****         {
2293:../Sources/drivers/mcg/mcg.c ****             return 0x1;         // return error code
 5346              		.loc 1 2293 0
 5347 004c 4FF00103 		mov	r3, #1
 5348 0050 E8E0     		b	.L452
 5349              	.L451:
2294:../Sources/drivers/mcg/mcg.c ****         }
2295:../Sources/drivers/mcg/mcg.c **** 
2296:../Sources/drivers/mcg/mcg.c ****     // Check that the irc frequency matches the selected IRC
2297:../Sources/drivers/mcg/mcg.c **** 
2298:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
 5350              		.loc 1 2298 0
 5351 0052 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5352 0054 002B     		cmp	r3, #0
 5353 0056 0CD1     		bne	.L453
2299:../Sources/drivers/mcg/mcg.c ****         {
2300:../Sources/drivers/mcg/mcg.c ****             if((irc_freq < 31250) || (irc_freq > 39063))
 5354              		.loc 1 2300 0
 5355 0058 7A68     		ldr	r2, [r7, #4]
 5356 005a 47F61123 		movw	r3, #31249
 5357 005e 9A42     		cmp	r2, r3
 5358 0060 04DD     		ble	.L454
 5359              		.loc 1 2300 0 is_stmt 0
 5360 0062 7A68     		ldr	r2, [r7, #4]
 5361 0064 49F69703 		movw	r3, #39063
 5362 0068 9A42     		cmp	r2, r3
 5363 006a 13DD     		ble	.L455
 5364              	.L454:
2301:../Sources/drivers/mcg/mcg.c ****                 {
2302:../Sources/drivers/mcg/mcg.c ****                     return 0x31;
 5365              		.loc 1 2302 0 is_stmt 1
 5366 006c 4FF03103 		mov	r3, #49
 5367 0070 D8E0     		b	.L452
 5368              	.L453:
2303:../Sources/drivers/mcg/mcg.c ****                 }
2304:../Sources/drivers/mcg/mcg.c ****         }
2305:../Sources/drivers/mcg/mcg.c ****     else
2306:../Sources/drivers/mcg/mcg.c ****         {
2307:../Sources/drivers/mcg/mcg.c ****             if((irc_freq < 3000000) || (irc_freq > 5000000))
 5369              		.loc 1 2307 0
 5370 0072 7A68     		ldr	r2, [r7, #4]
 5371 0074 4CF2BF63 		movw	r3, #50879
 5372 0078 C0F22D03 		movt	r3, 45
 5373 007c 9A42     		cmp	r2, r3
 5374 007e 06DD     		ble	.L456
 5375              		.loc 1 2307 0 is_stmt 0
 5376 0080 7A68     		ldr	r2, [r7, #4]
 5377 0082 44F64033 		movw	r3, #19264
 5378 0086 C0F24C03 		movt	r3, 76
 5379 008a 9A42     		cmp	r2, r3
 5380 008c 02DD     		ble	.L455
 5381              	.L456:
2308:../Sources/drivers/mcg/mcg.c ****                 {
2309:../Sources/drivers/mcg/mcg.c ****                     return 0x32;    // Fast IRC freq
 5382              		.loc 1 2309 0 is_stmt 1
 5383 008e 4FF03203 		mov	r3, #50
 5384 0092 C7E0     		b	.L452
 5385              	.L455:
2310:../Sources/drivers/mcg/mcg.c ****                 }
2311:../Sources/drivers/mcg/mcg.c ****         }
2312:../Sources/drivers/mcg/mcg.c **** 
2313:../Sources/drivers/mcg/mcg.c ****     // Select the desired IRC
2314:../Sources/drivers/mcg/mcg.c **** 
2315:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 5386              		.loc 1 2315 0
 5387 0094 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5388 0096 002B     		cmp	r3, #0
 5389 0098 0ED0     		beq	.L457
2316:../Sources/drivers/mcg/mcg.c ****         {
2317:../Sources/drivers/mcg/mcg.c ****             MCG_C2 |= MCG_C2_IRCS_MASK;                     // select fast IRCS
 5390              		.loc 1 2317 0
 5391 009a 4FF48043 		mov	r3, #16384
 5392 009e C4F20603 		movt	r3, 16390
 5393 00a2 4FF48042 		mov	r2, #16384
 5394 00a6 C4F20602 		movt	r2, 16390
 5395 00aa 5278     		ldrb	r2, [r2, #1]
 5396 00ac D2B2     		uxtb	r2, r2
 5397 00ae 42F00102 		orr	r2, r2, #1
 5398 00b2 D2B2     		uxtb	r2, r2
 5399 00b4 5A70     		strb	r2, [r3, #1]
 5400 00b6 0DE0     		b	.L458
 5401              	.L457:
2318:../Sources/drivers/mcg/mcg.c ****         }
2319:../Sources/drivers/mcg/mcg.c ****     else
2320:../Sources/drivers/mcg/mcg.c ****         {
2321:../Sources/drivers/mcg/mcg.c ****             MCG_C2 &= ~MCG_C2_IRCS_MASK;                    // select slow IRCS
 5402              		.loc 1 2321 0
 5403 00b8 4FF48043 		mov	r3, #16384
 5404 00bc C4F20603 		movt	r3, 16390
 5405 00c0 4FF48042 		mov	r2, #16384
 5406 00c4 C4F20602 		movt	r2, 16390
 5407 00c8 5278     		ldrb	r2, [r2, #1]
 5408 00ca D2B2     		uxtb	r2, r2
 5409 00cc 22F00102 		bic	r2, r2, #1
 5410 00d0 D2B2     		uxtb	r2, r2
 5411 00d2 5A70     		strb	r2, [r3, #1]
 5412              	.L458:
2322:../Sources/drivers/mcg/mcg.c ****         }
2323:../Sources/drivers/mcg/mcg.c **** 
2324:../Sources/drivers/mcg/mcg.c ****     // Change the CLKS mux to select the IRC as the MCGOUT
2325:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 5413              		.loc 1 2325 0
 5414 00d4 4FF48043 		mov	r3, #16384
 5415 00d8 C4F20603 		movt	r3, 16390
 5416 00dc 1B78     		ldrb	r3, [r3, #0]
 5417 00de 7B73     		strb	r3, [r7, #13]
2326:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                      // clear CLKS
 5418              		.loc 1 2326 0
 5419 00e0 7B7B     		ldrb	r3, [r7, #13]
 5420 00e2 03F03F03 		and	r3, r3, #63
 5421 00e6 7B73     		strb	r3, [r7, #13]
2327:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_CLKS(1);                         // select IRC as the MCG clock sourse
 5422              		.loc 1 2327 0
 5423 00e8 7B7B     		ldrb	r3, [r7, #13]
 5424 00ea 43F04003 		orr	r3, r3, #64
 5425 00ee 7B73     		strb	r3, [r7, #13]
2328:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 5426              		.loc 1 2328 0
 5427 00f0 4FF48043 		mov	r3, #16384
 5428 00f4 C4F20603 		movt	r3, 16390
 5429 00f8 7A7B     		ldrb	r2, [r7, #13]
 5430 00fa 1A70     		strb	r2, [r3, #0]
2329:../Sources/drivers/mcg/mcg.c **** 
2330:../Sources/drivers/mcg/mcg.c ****     // wait until internal reference switches to requested irc.
2331:../Sources/drivers/mcg/mcg.c **** 
2332:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
 5431              		.loc 1 2332 0
 5432 00fc FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5433 00fe 002B     		cmp	r3, #0
 5434 0100 26D1     		bne	.L459
2333:../Sources/drivers/mcg/mcg.c ****         {
2334:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 5435              		.loc 1 2334 0
 5436 0102 4FF00003 		mov	r3, #0
 5437 0106 FB81     		strh	r3, [r7, #14]	@ movhi
 5438 0108 0DE0     		b	.L460
 5439              	.L463:
2335:../Sources/drivers/mcg/mcg.c ****                 {
2336:../Sources/drivers/mcg/mcg.c ****                     if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears b
 5440              		.loc 1 2336 0
 5441 010a 4FF48043 		mov	r3, #16384
 5442 010e C4F20603 		movt	r3, 16390
 5443 0112 9B79     		ldrb	r3, [r3, #6]
 5444 0114 DBB2     		uxtb	r3, r3
 5445 0116 03F00103 		and	r3, r3, #1
 5446 011a 002B     		cmp	r3, #0
 5447 011c 0AD0     		beq	.L475
 5448              	.L461:
2334:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 5449              		.loc 1 2334 0
 5450 011e FB89     		ldrh	r3, [r7, #14]	@ movhi
 5451 0120 03F10103 		add	r3, r3, #1
 5452 0124 FB81     		strh	r3, [r7, #14]	@ movhi
 5453              	.L460:
2334:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 5454              		.loc 1 2334 0 is_stmt 0
 5455 0126 B7F90E20 		ldrsh	r2, [r7, #14]
 5456 012a 40F2CF73 		movw	r3, #1999
 5457 012e 9A42     		cmp	r2, r3
 5458 0130 EBDD     		ble	.L463
 5459 0132 00E0     		b	.L462
 5460              	.L475:
 5461              		.loc 1 2336 0 is_stmt 1
 5462 0134 00BF     		nop
 5463              	.L462:
2337:../Sources/drivers/mcg/mcg.c ****                 }
2338:../Sources/drivers/mcg/mcg.c **** 
2339:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) return 0x13;       // check bit is really clear and return
 5464              		.loc 1 2339 0
 5465 0136 4FF48043 		mov	r3, #16384
 5466 013a C4F20603 		movt	r3, 16390
 5467 013e 9B79     		ldrb	r3, [r3, #6]
 5468 0140 DBB2     		uxtb	r3, r3
 5469 0142 03F00103 		and	r3, r3, #1
 5470 0146 002B     		cmp	r3, #0
 5471 0148 29D0     		beq	.L464
 5472              		.loc 1 2339 0 is_stmt 0
 5473 014a 4FF01303 		mov	r3, #19
 5474 014e 69E0     		b	.L452
 5475              	.L459:
2340:../Sources/drivers/mcg/mcg.c ****         }
2341:../Sources/drivers/mcg/mcg.c ****     else
2342:../Sources/drivers/mcg/mcg.c ****         {
2343:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 5476              		.loc 1 2343 0 is_stmt 1
 5477 0150 4FF00003 		mov	r3, #0
 5478 0154 FB81     		strh	r3, [r7, #14]	@ movhi
 5479 0156 0DE0     		b	.L465
 5480              	.L468:
2344:../Sources/drivers/mcg/mcg.c ****                 {
2345:../Sources/drivers/mcg/mcg.c ****                     if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets bef
 5481              		.loc 1 2345 0
 5482 0158 4FF48043 		mov	r3, #16384
 5483 015c C4F20603 		movt	r3, 16390
 5484 0160 9B79     		ldrb	r3, [r3, #6]
 5485 0162 DBB2     		uxtb	r3, r3
 5486 0164 03F00103 		and	r3, r3, #1
 5487 0168 002B     		cmp	r3, #0
 5488 016a 0AD1     		bne	.L476
 5489              	.L466:
2343:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 5490              		.loc 1 2343 0
 5491 016c FB89     		ldrh	r3, [r7, #14]	@ movhi
 5492 016e 03F10103 		add	r3, r3, #1
 5493 0172 FB81     		strh	r3, [r7, #14]	@ movhi
 5494              	.L465:
2343:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 2000; i++)
 5495              		.loc 1 2343 0 is_stmt 0
 5496 0174 B7F90E20 		ldrsh	r2, [r7, #14]
 5497 0178 40F2CF73 		movw	r3, #1999
 5498 017c 9A42     		cmp	r2, r3
 5499 017e EBDD     		ble	.L468
 5500 0180 00E0     		b	.L467
 5501              	.L476:
 5502              		.loc 1 2345 0 is_stmt 1
 5503 0182 00BF     		nop
 5504              	.L467:
2346:../Sources/drivers/mcg/mcg.c ****                 }
2347:../Sources/drivers/mcg/mcg.c **** 
2348:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) return 0x14;    // check bit is really set and return w
 5505              		.loc 1 2348 0
 5506 0184 4FF48043 		mov	r3, #16384
 5507 0188 C4F20603 		movt	r3, 16390
 5508 018c 9B79     		ldrb	r3, [r3, #6]
 5509 018e DBB2     		uxtb	r3, r3
 5510 0190 03F00103 		and	r3, r3, #1
 5511 0194 002B     		cmp	r3, #0
 5512 0196 02D1     		bne	.L464
 5513              		.loc 1 2348 0 is_stmt 0
 5514 0198 4FF01403 		mov	r3, #20
 5515 019c 42E0     		b	.L452
 5516              	.L464:
2349:../Sources/drivers/mcg/mcg.c ****         }
2350:../Sources/drivers/mcg/mcg.c **** 
2351:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
2352:../Sources/drivers/mcg/mcg.c **** 
2353:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5517              		.loc 1 2353 0 is_stmt 1
 5518 019e 4FF00003 		mov	r3, #0
 5519 01a2 FB81     		strh	r3, [r7, #14]	@ movhi
 5520 01a4 0FE0     		b	.L469
 5521              	.L472:
2354:../Sources/drivers/mcg/mcg.c ****         {
2355:../Sources/drivers/mcg/mcg.c ****             if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;         // jump out
 5522              		.loc 1 2355 0
 5523 01a6 4FF48043 		mov	r3, #16384
 5524 01aa C4F20603 		movt	r3, 16390
 5525 01ae 9B79     		ldrb	r3, [r3, #6]
 5526 01b0 DBB2     		uxtb	r3, r3
 5527 01b2 03F00C03 		and	r3, r3, #12
 5528 01b6 4FEA9303 		lsr	r3, r3, #2
 5529 01ba 012B     		cmp	r3, #1
 5530 01bc 0AD0     		beq	.L477
 5531              	.L470:
2353:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5532              		.loc 1 2353 0
 5533 01be FB89     		ldrh	r3, [r7, #14]	@ movhi
 5534 01c0 03F10103 		add	r3, r3, #1
 5535 01c4 FB81     		strh	r3, [r7, #14]	@ movhi
 5536              	.L469:
2353:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5537              		.loc 1 2353 0 is_stmt 0
 5538 01c6 B7F90E20 		ldrsh	r2, [r7, #14]
 5539 01ca 40F2CF73 		movw	r3, #1999
 5540 01ce 9A42     		cmp	r2, r3
 5541 01d0 E9DD     		ble	.L472
 5542 01d2 00E0     		b	.L471
 5543              	.L477:
 5544              		.loc 1 2355 0 is_stmt 1
 5545 01d4 00BF     		nop
 5546              	.L471:
2356:../Sources/drivers/mcg/mcg.c ****         }
2357:../Sources/drivers/mcg/mcg.c **** 
2358:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19;       // check IRC is
 5547              		.loc 1 2358 0
 5548 01d6 4FF48043 		mov	r3, #16384
 5549 01da C4F20603 		movt	r3, 16390
 5550 01de 9B79     		ldrb	r3, [r3, #6]
 5551 01e0 DBB2     		uxtb	r3, r3
 5552 01e2 03F00C03 		and	r3, r3, #12
 5553 01e6 4FEA9303 		lsr	r3, r3, #2
 5554 01ea 012B     		cmp	r3, #1
 5555 01ec 02D0     		beq	.L473
 5556              		.loc 1 2358 0 is_stmt 0
 5557 01ee 4FF01903 		mov	r3, #25
 5558 01f2 17E0     		b	.L452
 5559              	.L473:
2359:../Sources/drivers/mcg/mcg.c **** 
2360:../Sources/drivers/mcg/mcg.c ****     // Now in FBI mode
2361:../Sources/drivers/mcg/mcg.c **** 
2362:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 5560              		.loc 1 2362 0 is_stmt 1
 5561 01f4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5562 01f6 002B     		cmp	r3, #0
 5563 01f8 13D0     		beq	.L474
2363:../Sources/drivers/mcg/mcg.c ****         {
2364:../Sources/drivers/mcg/mcg.c ****             fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculat
 5564              		.loc 1 2364 0
 5565 01fa 4FF48043 		mov	r3, #16384
 5566 01fe C4F20603 		movt	r3, 16390
 5567 0202 1B7A     		ldrb	r3, [r3, #8]
 5568 0204 DBB2     		uxtb	r3, r3
 5569 0206 03F00E03 		and	r3, r3, #14
 5570 020a 4FEA5303 		lsr	r3, r3, #1
 5571 020e 4FF00102 		mov	r2, #1
 5572 0212 02FA03F3 		lsl	r3, r2, r3
 5573 0216 3B73     		strb	r3, [r7, #12]
2365:../Sources/drivers/mcg/mcg.c ****             return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided b
 5574              		.loc 1 2365 0
 5575 0218 3B7B     		ldrb	r3, [r7, #12]	@ zero_extendqisi2
 5576 021a 7A68     		ldr	r2, [r7, #4]
 5577 021c 92FBF3F3 		sdiv	r3, r2, r3
 5578 0220 00E0     		b	.L452
 5579              	.L474:
2366:../Sources/drivers/mcg/mcg.c ****         }
2367:../Sources/drivers/mcg/mcg.c ****     else
2368:../Sources/drivers/mcg/mcg.c ****         {
2369:../Sources/drivers/mcg/mcg.c ****             return irc_freq;                // MCGOUT frequency equals slow IRC frequency
 5580              		.loc 1 2369 0
 5581 0222 7B68     		ldr	r3, [r7, #4]
 5582              	.L452:
2370:../Sources/drivers/mcg/mcg.c ****         }
2371:../Sources/drivers/mcg/mcg.c **** }   // fei_fbi
 5583              		.loc 1 2371 0
 5584 0224 1846     		mov	r0, r3
 5585 0226 07F11407 		add	r7, r7, #20
 5586 022a BD46     		mov	sp, r7
 5587 022c 80BC     		pop	{r7}
 5588 022e 7047     		bx	lr
 5589              		.cfi_endproc
 5590              	.LFE21:
 5592              		.section	.text.fei_fee,"ax",%progbits
 5593              		.align	2
 5594              		.global	fei_fee
 5595              		.thumb
 5596              		.thumb_func
 5598              	fei_fee:
 5599              	.LFB22:
2372:../Sources/drivers/mcg/mcg.c **** 
2373:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
2374:../Sources/drivers/mcg/mcg.c **** 
2375:../Sources/drivers/mcg/mcg.c **** /* Functon name : fei_fee
2376:../Sources/drivers/mcg/mcg.c ****  *
2377:../Sources/drivers/mcg/mcg.c ****  * Mode transition: FEI to FEE mode
2378:../Sources/drivers/mcg/mcg.c ****  *
2379:../Sources/drivers/mcg/mcg.c ****  * This function transitions the MCG from FEI mode to FEE mode. This is
2380:../Sources/drivers/mcg/mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to
2381:../Sources/drivers/mcg/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
2382:../Sources/drivers/mcg/mcg.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
2383:../Sources/drivers/mcg/mcg.c ****  *
2384:../Sources/drivers/mcg/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
2385:../Sources/drivers/mcg/mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
2386:../Sources/drivers/mcg/mcg.c ****  *                           for the crystal oscillator. This has no meaning if an
2387:../Sources/drivers/mcg/mcg.c ****  *                           external clock is used.
2388:../Sources/drivers/mcg/mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
2389:../Sources/drivers/mcg/mcg.c ****  *
2390:../Sources/drivers/mcg/mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
2391:../Sources/drivers/mcg/mcg.c ****  */
2392:../Sources/drivers/mcg/mcg.c **** 
2393:../Sources/drivers/mcg/mcg.c **** int fei_fee
2394:../Sources/drivers/mcg/mcg.c **** (
2395:../Sources/drivers/mcg/mcg.c ****     int             crystal_val,
2396:../Sources/drivers/mcg/mcg.c ****     unsigned char   hgo_val,
2397:../Sources/drivers/mcg/mcg.c ****     unsigned char   erefs_val
2398:../Sources/drivers/mcg/mcg.c **** )
2399:../Sources/drivers/mcg/mcg.c **** {
 5600              		.loc 1 2399 0
 5601              		.cfi_startproc
 5602              		@ args = 0, pretend = 0, frame = 24
 5603              		@ frame_needed = 1, uses_anonymous_args = 0
 5604 0000 80B5     		push	{r7, lr}
 5605              	.LCFI66:
 5606              		.cfi_def_cfa_offset 8
 5607              		.cfi_offset 7, -8
 5608              		.cfi_offset 14, -4
 5609 0002 86B0     		sub	sp, sp, #24
 5610              	.LCFI67:
 5611              		.cfi_def_cfa_offset 32
 5612 0004 00AF     		add	r7, sp, #0
 5613              	.LCFI68:
 5614              		.cfi_def_cfa_register 7
 5615 0006 7860     		str	r0, [r7, #4]
 5616 0008 1346     		mov	r3, r2
 5617 000a 0A46     		mov	r2, r1
 5618 000c FA70     		strb	r2, [r7, #3]
 5619 000e BB70     		strb	r3, [r7, #2]
2400:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2401:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2402:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2403:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2404:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2405:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2406:../Sources/drivers/mcg/mcg.c ****     unsigned char   frdiv_val;
2407:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
2408:../Sources/drivers/mcg/mcg.c ****     // short i;
2409:../Sources/drivers/mcg/mcg.c ****     int             mcg_out, fll_ref_freq, i;
2410:../Sources/drivers/mcg/mcg.c **** 
2411:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2412:../Sources/drivers/mcg/mcg.c **** 
2413:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2414:../Sources/drivers/mcg/mcg.c **** 
2415:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2416:../Sources/drivers/mcg/mcg.c **** 
2417:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2418:../Sources/drivers/mcg/mcg.c **** 
2419:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2420:../Sources/drivers/mcg/mcg.c **** 
2421:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2422:../Sources/drivers/mcg/mcg.c **** 
2423:../Sources/drivers/mcg/mcg.c ****     // check if in FEI mode
2424:../Sources/drivers/mcg/mcg.c **** 
2425:../Sources/drivers/mcg/mcg.c ****     if
2426:../Sources/drivers/mcg/mcg.c ****     (
2427:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 5620              		.loc 1 2427 0
 5621 0010 4FF48043 		mov	r3, #16384
 5622 0014 C4F20603 		movt	r3, 16390
 5623 0018 9B79     		ldrb	r3, [r3, #6]
 5624 001a DBB2     		uxtb	r3, r3
 5625 001c 03F00C03 		and	r3, r3, #12
 5626 0020 4FEA9303 		lsr	r3, r3, #2
2426:../Sources/drivers/mcg/mcg.c ****     (
 5627              		.loc 1 2426 0
 5628 0024 002B     		cmp	r3, #0
 5629 0026 13D1     		bne	.L479
2428:../Sources/drivers/mcg/mcg.c ****           &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
 5630              		.loc 1 2428 0
 5631 0028 4FF48043 		mov	r3, #16384
 5632 002c C4F20603 		movt	r3, 16390
 5633 0030 9B79     		ldrb	r3, [r3, #6]
 5634 0032 DBB2     		uxtb	r3, r3
 5635 0034 03F01003 		and	r3, r3, #16
 5636 0038 002B     		cmp	r3, #0
 5637 003a 09D0     		beq	.L479
2429:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))
 5638              		.loc 1 2429 0
 5639 003c 4FF48043 		mov	r3, #16384
 5640 0040 C4F20603 		movt	r3, 16390
 5641 0044 9B79     		ldrb	r3, [r3, #6]
 5642 0046 DBB2     		uxtb	r3, r3
 5643 0048 03F02003 		and	r3, r3, #32
2427:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 5644              		.loc 1 2427 0
 5645 004c 002B     		cmp	r3, #0
 5646 004e 02D0     		beq	.L480
 5647              	.L479:
2430:../Sources/drivers/mcg/mcg.c ****          )
2431:../Sources/drivers/mcg/mcg.c ****     )                       // check PLLS mux has selected FLL
2432:../Sources/drivers/mcg/mcg.c ****         {
2433:../Sources/drivers/mcg/mcg.c ****             return 0x1;         // return error code
 5648              		.loc 1 2433 0
 5649 0050 4FF00103 		mov	r3, #1
 5650 0054 54E1     		b	.L481
 5651              	.L480:
2434:../Sources/drivers/mcg/mcg.c ****         }
2435:../Sources/drivers/mcg/mcg.c **** 
2436:../Sources/drivers/mcg/mcg.c ****     // check external frequency is less than the maximum frequency
2437:../Sources/drivers/mcg/mcg.c **** 
2438:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
 5652              		.loc 1 2438 0
 5653 0056 7A68     		ldr	r2, [r7, #4]
 5654 0058 4FF28003 		movw	r3, #61568
 5655 005c C0F2FA23 		movt	r3, 762
 5656 0060 9A42     		cmp	r2, r3
 5657 0062 02DD     		ble	.L482
2439:../Sources/drivers/mcg/mcg.c ****         {
2440:../Sources/drivers/mcg/mcg.c ****             return 0x21;
 5658              		.loc 1 2440 0
 5659 0064 4FF02103 		mov	r3, #33
 5660 0068 4AE1     		b	.L481
 5661              	.L482:
2441:../Sources/drivers/mcg/mcg.c ****         }
2442:../Sources/drivers/mcg/mcg.c **** 
2443:../Sources/drivers/mcg/mcg.c ****     // check crystal frequency is within spec. if crystal osc is being used
2444:../Sources/drivers/mcg/mcg.c **** 
2445:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 5662              		.loc 1 2445 0
 5663 006a BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 5664 006c 002B     		cmp	r3, #0
 5665 006e 1AD0     		beq	.L483
2446:../Sources/drivers/mcg/mcg.c ****         {
2447:../Sources/drivers/mcg/mcg.c ****             if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crys
 5666              		.loc 1 2447 0
 5667 0070 7A68     		ldr	r2, [r7, #4]
 5668 0072 47F22F53 		movw	r3, #29999
 5669 0076 9A42     		cmp	r2, r3
 5670 0078 12DD     		ble	.L484
 5671              		.loc 1 2447 0 is_stmt 0
 5672 007a 7A68     		ldr	r2, [r7, #4]
 5673 007c 49F64043 		movw	r3, #40000
 5674 0080 9A42     		cmp	r2, r3
 5675 0082 06DD     		ble	.L485
 5676 0084 7A68     		ldr	r2, [r7, #4]
 5677 0086 4CF2BF63 		movw	r3, #50879
 5678 008a C0F22D03 		movt	r3, 45
 5679 008e 9A42     		cmp	r2, r3
 5680 0090 06DD     		ble	.L484
 5681              	.L485:
 5682              		.loc 1 2447 0
 5683 0092 7A68     		ldr	r2, [r7, #4]
 5684 0094 4FF49043 		mov	r3, #18432
 5685 0098 C0F2E813 		movt	r3, 488
 5686 009c 9A42     		cmp	r2, r3
 5687 009e 02DD     		ble	.L483
 5688              	.L484:
2448:../Sources/drivers/mcg/mcg.c ****                 {
2449:../Sources/drivers/mcg/mcg.c ****                     return 0x22;    // return error if one of the available crystal options is not 
 5689              		.loc 1 2449 0 is_stmt 1
 5690 00a0 4FF02203 		mov	r3, #34
 5691 00a4 2CE1     		b	.L481
 5692              	.L483:
2450:../Sources/drivers/mcg/mcg.c ****                 }
2451:../Sources/drivers/mcg/mcg.c ****         }
2452:../Sources/drivers/mcg/mcg.c **** 
2453:../Sources/drivers/mcg/mcg.c ****     // make sure HGO will never be greater than 1. Could return an error instead if desired.
2454:../Sources/drivers/mcg/mcg.c **** 
2455:../Sources/drivers/mcg/mcg.c ****     if(hgo_val > 0)
 5693              		.loc 1 2455 0
 5694 00a6 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5695 00a8 002B     		cmp	r3, #0
 5696 00aa 02D0     		beq	.L486
2456:../Sources/drivers/mcg/mcg.c ****         {
2457:../Sources/drivers/mcg/mcg.c ****             hgo_val = 1;        // force hgo_val to 1 if > 0
 5697              		.loc 1 2457 0
 5698 00ac 4FF00103 		mov	r3, #1
 5699 00b0 FB70     		strb	r3, [r7, #3]
 5700              	.L486:
2458:../Sources/drivers/mcg/mcg.c ****         }
2459:../Sources/drivers/mcg/mcg.c **** 
2460:../Sources/drivers/mcg/mcg.c ****     // configure the MCG_C2 register
2461:../Sources/drivers/mcg/mcg.c ****     // the RANGE value is determined by the external frequency. Since the RANGE parameter affects t
2462:../Sources/drivers/mcg/mcg.c ****     // it still needs to be set correctly even if the oscillator is not being used
2463:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 5701              		.loc 1 2463 0
 5702 00b2 4FF48043 		mov	r3, #16384
 5703 00b6 C4F20603 		movt	r3, 16390
 5704 00ba 5B78     		ldrb	r3, [r3, #1]
 5705 00bc BB75     		strb	r3, [r7, #22]
2464:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 5706              		.loc 1 2464 0
 5707 00be BB7D     		ldrb	r3, [r7, #22]
 5708 00c0 23F03C03 		bic	r3, r3, #60
 5709 00c4 BB75     		strb	r3, [r7, #22]
2465:../Sources/drivers/mcg/mcg.c **** 
2466:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 5710              		.loc 1 2466 0
 5711 00c6 7A68     		ldr	r2, [r7, #4]
 5712 00c8 49F64043 		movw	r3, #40000
 5713 00cc 9A42     		cmp	r2, r3
 5714 00ce 0DDC     		bgt	.L487
2467:../Sources/drivers/mcg/mcg.c ****         {
2468:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 5715              		.loc 1 2468 0
 5716 00d0 FB78     		ldrb	r3, [r7, #3]
 5717 00d2 4FEAC303 		lsl	r3, r3, #3
 5718 00d6 DAB2     		uxtb	r2, r3
 5719 00d8 BB78     		ldrb	r3, [r7, #2]
 5720 00da 4FEA8303 		lsl	r3, r3, #2
 5721 00de DBB2     		uxtb	r3, r3
 5722 00e0 1343     		orrs	r3, r3, r2
 5723 00e2 DAB2     		uxtb	r2, r3
 5724 00e4 BB7D     		ldrb	r3, [r7, #22]
 5725 00e6 1343     		orrs	r3, r3, r2
 5726 00e8 BB75     		strb	r3, [r7, #22]
 5727 00ea 27E0     		b	.L488
 5728              	.L487:
2469:../Sources/drivers/mcg/mcg.c ****         }
2470:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
 5729              		.loc 1 2470 0
 5730 00ec 7A68     		ldr	r2, [r7, #4]
 5731 00ee 4FF49053 		mov	r3, #4608
 5732 00f2 C0F27A03 		movt	r3, 122
 5733 00f6 9A42     		cmp	r2, r3
 5734 00f8 10DC     		bgt	.L489
2471:../Sources/drivers/mcg/mcg.c ****         {
2472:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 5735              		.loc 1 2472 0
 5736 00fa FB78     		ldrb	r3, [r7, #3]
 5737 00fc 4FEAC303 		lsl	r3, r3, #3
 5738 0100 DAB2     		uxtb	r2, r3
 5739 0102 BB78     		ldrb	r3, [r7, #2]
 5740 0104 4FEA8303 		lsl	r3, r3, #2
 5741 0108 DBB2     		uxtb	r3, r3
 5742 010a 1343     		orrs	r3, r3, r2
 5743 010c DAB2     		uxtb	r2, r3
 5744 010e BB7D     		ldrb	r3, [r7, #22]
 5745 0110 1343     		orrs	r3, r3, r2
 5746 0112 DBB2     		uxtb	r3, r3
 5747 0114 43F01003 		orr	r3, r3, #16
 5748 0118 BB75     		strb	r3, [r7, #22]
 5749 011a 0FE0     		b	.L488
 5750              	.L489:
2473:../Sources/drivers/mcg/mcg.c ****         }
2474:../Sources/drivers/mcg/mcg.c ****     else
2475:../Sources/drivers/mcg/mcg.c ****         {
2476:../Sources/drivers/mcg/mcg.c ****             temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_E
 5751              		.loc 1 2476 0
 5752 011c FB78     		ldrb	r3, [r7, #3]
 5753 011e 4FEAC303 		lsl	r3, r3, #3
 5754 0122 DAB2     		uxtb	r2, r3
 5755 0124 BB78     		ldrb	r3, [r7, #2]
 5756 0126 4FEA8303 		lsl	r3, r3, #2
 5757 012a DBB2     		uxtb	r3, r3
 5758 012c 1343     		orrs	r3, r3, r2
 5759 012e DAB2     		uxtb	r2, r3
 5760 0130 BB7D     		ldrb	r3, [r7, #22]
 5761 0132 1343     		orrs	r3, r3, r2
 5762 0134 DBB2     		uxtb	r3, r3
 5763 0136 43F02003 		orr	r3, r3, #32
 5764 013a BB75     		strb	r3, [r7, #22]
 5765              	.L488:
2477:../Sources/drivers/mcg/mcg.c ****         }
2478:../Sources/drivers/mcg/mcg.c **** 
2479:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 5766              		.loc 1 2479 0
 5767 013c 4FF48043 		mov	r3, #16384
 5768 0140 C4F20603 		movt	r3, 16390
 5769 0144 BA7D     		ldrb	r2, [r7, #22]
 5770 0146 5A70     		strb	r2, [r3, #1]
2480:../Sources/drivers/mcg/mcg.c **** 
2481:../Sources/drivers/mcg/mcg.c ****     // determine FRDIV based on reference clock frequency
2482:../Sources/drivers/mcg/mcg.c ****     // since the external frequency has already been checked only the maximum frequency for each FR
2483:../Sources/drivers/mcg/mcg.c **** 
2484:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 5771              		.loc 1 2484 0
 5772 0148 7A68     		ldr	r2, [r7, #4]
 5773 014a 41F2D023 		movw	r3, #4816
 5774 014e C0F21303 		movt	r3, 19
 5775 0152 9A42     		cmp	r2, r3
 5776 0154 03DC     		bgt	.L490
2485:../Sources/drivers/mcg/mcg.c ****         {
2486:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 0;
 5777              		.loc 1 2486 0
 5778 0156 4FF00003 		mov	r3, #0
 5779 015a FB75     		strb	r3, [r7, #23]
 5780 015c 2EE0     		b	.L491
 5781              	.L490:
2487:../Sources/drivers/mcg/mcg.c ****         }
2488:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 5782              		.loc 1 2488 0
 5783 015e 7A68     		ldr	r2, [r7, #4]
 5784 0160 42F2A053 		movw	r3, #9632
 5785 0164 C0F22603 		movt	r3, 38
 5786 0168 9A42     		cmp	r2, r3
 5787 016a 03DC     		bgt	.L492
2489:../Sources/drivers/mcg/mcg.c ****         {
2490:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 1;
 5788              		.loc 1 2490 0
 5789 016c 4FF00103 		mov	r3, #1
 5790 0170 FB75     		strb	r3, [r7, #23]
 5791 0172 23E0     		b	.L491
 5792              	.L492:
2491:../Sources/drivers/mcg/mcg.c ****         }
2492:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 5793              		.loc 1 2492 0
 5794 0174 7A68     		ldr	r2, [r7, #4]
 5795 0176 44F64033 		movw	r3, #19264
 5796 017a C0F24C03 		movt	r3, 76
 5797 017e 9A42     		cmp	r2, r3
 5798 0180 03DC     		bgt	.L493
2493:../Sources/drivers/mcg/mcg.c ****         {
2494:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 2;
 5799              		.loc 1 2494 0
 5800 0182 4FF00203 		mov	r3, #2
 5801 0186 FB75     		strb	r3, [r7, #23]
 5802 0188 18E0     		b	.L491
 5803              	.L493:
2495:../Sources/drivers/mcg/mcg.c ****         }
2496:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 5804              		.loc 1 2496 0
 5805 018a 7A68     		ldr	r2, [r7, #4]
 5806 018c 49F28063 		movw	r3, #38528
 5807 0190 C0F29803 		movt	r3, 152
 5808 0194 9A42     		cmp	r2, r3
 5809 0196 03DC     		bgt	.L494
2497:../Sources/drivers/mcg/mcg.c ****         {
2498:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 3;
 5810              		.loc 1 2498 0
 5811 0198 4FF00303 		mov	r3, #3
 5812 019c FB75     		strb	r3, [r7, #23]
 5813 019e 0DE0     		b	.L491
 5814              	.L494:
2499:../Sources/drivers/mcg/mcg.c ****         }
2500:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 5815              		.loc 1 2500 0
 5816 01a0 7A68     		ldr	r2, [r7, #4]
 5817 01a2 4FF43453 		mov	r3, #11520
 5818 01a6 C0F23113 		movt	r3, 305
 5819 01aa 9A42     		cmp	r2, r3
 5820 01ac 03DC     		bgt	.L495
2501:../Sources/drivers/mcg/mcg.c ****         {
2502:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 4;
 5821              		.loc 1 2502 0
 5822 01ae 4FF00403 		mov	r3, #4
 5823 01b2 FB75     		strb	r3, [r7, #23]
 5824 01b4 02E0     		b	.L491
 5825              	.L495:
2503:../Sources/drivers/mcg/mcg.c ****         }
2504:../Sources/drivers/mcg/mcg.c ****     else
2505:../Sources/drivers/mcg/mcg.c ****         {
2506:../Sources/drivers/mcg/mcg.c ****             frdiv_val = 5;
 5826              		.loc 1 2506 0
 5827 01b6 4FF00503 		mov	r3, #5
 5828 01ba FB75     		strb	r3, [r7, #23]
 5829              	.L491:
2507:../Sources/drivers/mcg/mcg.c ****         }
2508:../Sources/drivers/mcg/mcg.c **** 
2509:../Sources/drivers/mcg/mcg.c ****     // The FLL ref clk divide value depends on FRDIV and the RANGE value
2510:../Sources/drivers/mcg/mcg.c **** 
2511:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 5830              		.loc 1 2511 0
 5831 01bc 4FF48043 		mov	r3, #16384
 5832 01c0 C4F20603 		movt	r3, 16390
 5833 01c4 5B78     		ldrb	r3, [r3, #1]
 5834 01c6 DBB2     		uxtb	r3, r3
 5835 01c8 03F03003 		and	r3, r3, #48
 5836 01cc 4FEA1313 		lsr	r3, r3, #4
 5837 01d0 002B     		cmp	r3, #0
 5838 01d2 09D0     		beq	.L496
2512:../Sources/drivers/mcg/mcg.c ****         {
2513:../Sources/drivers/mcg/mcg.c ****             fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
 5839              		.loc 1 2513 0
 5840 01d4 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 5841 01d6 4FF02002 		mov	r2, #32
 5842 01da 02FA03F3 		lsl	r3, r2, r3
 5843 01de 7A68     		ldr	r2, [r7, #4]
 5844 01e0 92FBF3F3 		sdiv	r3, r2, r3
 5845 01e4 3B61     		str	r3, [r7, #16]
 5846 01e6 08E0     		b	.L497
 5847              	.L496:
2514:../Sources/drivers/mcg/mcg.c ****         }
2515:../Sources/drivers/mcg/mcg.c ****     else
2516:../Sources/drivers/mcg/mcg.c ****         {
2517:../Sources/drivers/mcg/mcg.c ****             fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 5848              		.loc 1 2517 0
 5849 01e8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 5850 01ea 4FF00102 		mov	r2, #1
 5851 01ee 02FA03F3 		lsl	r3, r2, r3
 5852 01f2 7A68     		ldr	r2, [r7, #4]
 5853 01f4 92FBF3F3 		sdiv	r3, r2, r3
 5854 01f8 3B61     		str	r3, [r7, #16]
 5855              	.L497:
2518:../Sources/drivers/mcg/mcg.c ****         }
2519:../Sources/drivers/mcg/mcg.c **** 
2520:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
2521:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
 5856              		.loc 1 2521 0
 5857 01fa 3869     		ldr	r0, [r7, #16]
 5858 01fc FFF7FEFF 		bl	fll_freq
 5859 0200 B860     		str	r0, [r7, #8]
2522:../Sources/drivers/mcg/mcg.c **** 
2523:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 5860              		.loc 1 2523 0
 5861 0202 BB68     		ldr	r3, [r7, #8]
 5862 0204 3B2B     		cmp	r3, #59
 5863 0206 01DC     		bgt	.L498
2524:../Sources/drivers/mcg/mcg.c ****         {
2525:../Sources/drivers/mcg/mcg.c ****             return mcg_out;                 // If error code returned, return the code to calling f
 5864              		.loc 1 2525 0
 5865 0208 BB68     		ldr	r3, [r7, #8]
 5866 020a 79E0     		b	.L481
 5867              	.L498:
2526:../Sources/drivers/mcg/mcg.c ****         }
2527:../Sources/drivers/mcg/mcg.c **** 
2528:../Sources/drivers/mcg/mcg.c ****     // Select external oscilator and Reference Divider and clear IREFS to start ext osc
2529:../Sources/drivers/mcg/mcg.c ****     // If IRCLK is required it must be enabled outside of this driver, existing state will be maint
2530:../Sources/drivers/mcg/mcg.c ****     // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
2531:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 5868              		.loc 1 2531 0
 5869 020c 4FF48043 		mov	r3, #16384
 5870 0210 C4F20603 		movt	r3, 16390
 5871 0214 1B78     		ldrb	r3, [r3, #0]
 5872 0216 BB75     		strb	r3, [r7, #22]
2532:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
 5873              		.loc 1 2532 0
 5874 0218 BB7D     		ldrb	r3, [r7, #22]
 5875 021a 03F00303 		and	r3, r3, #3
 5876 021e BB75     		strb	r3, [r7, #22]
2533:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 5877              		.loc 1 2533 0
 5878 0220 FB7D     		ldrb	r3, [r7, #23]
 5879 0222 4FEAC303 		lsl	r3, r3, #3
 5880 0226 DBB2     		uxtb	r3, r3
 5881 0228 03F03803 		and	r3, r3, #56
 5882 022c DAB2     		uxtb	r2, r3
 5883 022e BB7D     		ldrb	r3, [r7, #22]
 5884 0230 1343     		orrs	r3, r3, r2
 5885 0232 BB75     		strb	r3, [r7, #22]
2534:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 5886              		.loc 1 2534 0
 5887 0234 4FF48043 		mov	r3, #16384
 5888 0238 C4F20603 		movt	r3, 16390
 5889 023c BA7D     		ldrb	r2, [r7, #22]
 5890 023e 1A70     		strb	r2, [r3, #0]
2535:../Sources/drivers/mcg/mcg.c **** 
2536:../Sources/drivers/mcg/mcg.c ****     // if the external oscillator is used need to wait for OSCINIT to set
2537:../Sources/drivers/mcg/mcg.c **** 
2538:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 5891              		.loc 1 2538 0
 5892 0240 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 5893 0242 002B     		cmp	r3, #0
 5894 0244 27D0     		beq	.L499
2539:../Sources/drivers/mcg/mcg.c ****         {
2540:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 20000000; i++)
 5895              		.loc 1 2540 0
 5896 0246 4FF00003 		mov	r3, #0
 5897 024a FB60     		str	r3, [r7, #12]
 5898 024c 0DE0     		b	.L500
 5899              	.L503:
2541:../Sources/drivers/mcg/mcg.c ****                 {
2542:../Sources/drivers/mcg/mcg.c ****                     if(MCG_S & MCG_S_OSCINIT0_MASK) break;      // jump out early if OSCINIT sets b
 5900              		.loc 1 2542 0
 5901 024e 4FF48043 		mov	r3, #16384
 5902 0252 C4F20603 		movt	r3, 16390
 5903 0256 9B79     		ldrb	r3, [r3, #6]
 5904 0258 DBB2     		uxtb	r3, r3
 5905 025a 03F00203 		and	r3, r3, #2
 5906 025e 002B     		cmp	r3, #0
 5907 0260 0BD1     		bne	.L509
 5908              	.L501:
2540:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 20000000; i++)
 5909              		.loc 1 2540 0
 5910 0262 FB68     		ldr	r3, [r7, #12]
 5911 0264 03F10103 		add	r3, r3, #1
 5912 0268 FB60     		str	r3, [r7, #12]
 5913              	.L500:
2540:../Sources/drivers/mcg/mcg.c ****             for(i = 0; i < 20000000; i++)
 5914              		.loc 1 2540 0 is_stmt 0
 5915 026a FA68     		ldr	r2, [r7, #12]
 5916 026c 42F6FF43 		movw	r3, #11519
 5917 0270 C0F23113 		movt	r3, 305
 5918 0274 9A42     		cmp	r2, r3
 5919 0276 EADD     		ble	.L503
 5920 0278 00E0     		b	.L502
 5921              	.L509:
 5922              		.loc 1 2542 0 is_stmt 1
 5923 027a 00BF     		nop
 5924              	.L502:
2543:../Sources/drivers/mcg/mcg.c ****                 }
2544:../Sources/drivers/mcg/mcg.c **** 
2545:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return w
 5925              		.loc 1 2545 0
 5926 027c 4FF48043 		mov	r3, #16384
 5927 0280 C4F20603 		movt	r3, 16390
 5928 0284 9B79     		ldrb	r3, [r3, #6]
 5929 0286 DBB2     		uxtb	r3, r3
 5930 0288 03F00203 		and	r3, r3, #2
 5931 028c 002B     		cmp	r3, #0
 5932 028e 02D1     		bne	.L499
 5933              		.loc 1 2545 0 is_stmt 0
 5934 0290 4FF02303 		mov	r3, #35
 5935 0294 34E0     		b	.L481
 5936              	.L499:
2546:../Sources/drivers/mcg/mcg.c ****         }
2547:../Sources/drivers/mcg/mcg.c **** 
2548:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
2549:../Sources/drivers/mcg/mcg.c **** 
2550:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5937              		.loc 1 2550 0 is_stmt 1
 5938 0296 4FF00003 		mov	r3, #0
 5939 029a FB60     		str	r3, [r7, #12]
 5940 029c 0DE0     		b	.L504
 5941              	.L507:
2551:../Sources/drivers/mcg/mcg.c ****         {
2552:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IREFST_MASK)) break;         // jump out early if IREFST clears befo
 5942              		.loc 1 2552 0
 5943 029e 4FF48043 		mov	r3, #16384
 5944 02a2 C4F20603 		movt	r3, 16390
 5945 02a6 9B79     		ldrb	r3, [r3, #6]
 5946 02a8 DBB2     		uxtb	r3, r3
 5947 02aa 03F01003 		and	r3, r3, #16
 5948 02ae 002B     		cmp	r3, #0
 5949 02b0 09D0     		beq	.L510
 5950              	.L505:
2550:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5951              		.loc 1 2550 0
 5952 02b2 FB68     		ldr	r3, [r7, #12]
 5953 02b4 03F10103 		add	r3, r3, #1
 5954 02b8 FB60     		str	r3, [r7, #12]
 5955              	.L504:
2550:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 5956              		.loc 1 2550 0 is_stmt 0
 5957 02ba FA68     		ldr	r2, [r7, #12]
 5958 02bc 40F2CF73 		movw	r3, #1999
 5959 02c0 9A42     		cmp	r2, r3
 5960 02c2 ECDD     		ble	.L507
 5961 02c4 00E0     		b	.L506
 5962              	.L510:
 5963              		.loc 1 2552 0 is_stmt 1
 5964 02c6 00BF     		nop
 5965              	.L506:
2553:../Sources/drivers/mcg/mcg.c ****         }
2554:../Sources/drivers/mcg/mcg.c **** 
2555:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;          // check bit is really clear and return wit
 5966              		.loc 1 2555 0
 5967 02c8 4FF48043 		mov	r3, #16384
 5968 02cc C4F20603 		movt	r3, 16390
 5969 02d0 9B79     		ldrb	r3, [r3, #6]
 5970 02d2 DBB2     		uxtb	r3, r3
 5971 02d4 03F01003 		and	r3, r3, #16
 5972 02d8 002B     		cmp	r3, #0
 5973 02da 02D0     		beq	.L508
 5974              		.loc 1 2555 0 is_stmt 0
 5975 02dc 4FF01103 		mov	r3, #17
 5976 02e0 0EE0     		b	.L481
 5977              	.L508:
2556:../Sources/drivers/mcg/mcg.c **** 
2557:../Sources/drivers/mcg/mcg.c ****     // Now in FBE
2558:../Sources/drivers/mcg/mcg.c ****     // It is recommended that the clock monitor is enabled when using an external clock as the cloc
2559:../Sources/drivers/mcg/mcg.c ****     // It is enabled here but can be removed if this is not required.
2560:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 5978              		.loc 1 2560 0 is_stmt 1
 5979 02e2 4FF48043 		mov	r3, #16384
 5980 02e6 C4F20603 		movt	r3, 16390
 5981 02ea 4FF48042 		mov	r2, #16384
 5982 02ee C4F20602 		movt	r2, 16390
 5983 02f2 5279     		ldrb	r2, [r2, #5]
 5984 02f4 D2B2     		uxtb	r2, r2
 5985 02f6 42F02002 		orr	r2, r2, #32
 5986 02fa D2B2     		uxtb	r2, r2
 5987 02fc 5A71     		strb	r2, [r3, #5]
2561:../Sources/drivers/mcg/mcg.c ****     return mcg_out; // MCGOUT frequency equals FLL frequency
 5988              		.loc 1 2561 0
 5989 02fe BB68     		ldr	r3, [r7, #8]
 5990              	.L481:
2562:../Sources/drivers/mcg/mcg.c **** }                   // fei_fee
 5991              		.loc 1 2562 0
 5992 0300 1846     		mov	r0, r3
 5993 0302 07F11807 		add	r7, r7, #24
 5994 0306 BD46     		mov	sp, r7
 5995 0308 80BD     		pop	{r7, pc}
 5996              		.cfi_endproc
 5997              	.LFE22:
 5999 030a 00BF     		.section	.text.fee_fei,"ax",%progbits
 6000              		.align	2
 6001              		.global	fee_fei
 6002              		.thumb
 6003              		.thumb_func
 6005              	fee_fei:
 6006              	.LFB23:
2563:../Sources/drivers/mcg/mcg.c **** 
2564:../Sources/drivers/mcg/mcg.c **** /* */
2565:../Sources/drivers/mcg/mcg.c **** 
2566:../Sources/drivers/mcg/mcg.c **** int fee_fei
2567:../Sources/drivers/mcg/mcg.c **** (int slow_irc_freq)
2568:../Sources/drivers/mcg/mcg.c **** {
 6007              		.loc 1 2568 0
 6008              		.cfi_startproc
 6009              		@ args = 0, pretend = 0, frame = 16
 6010              		@ frame_needed = 1, uses_anonymous_args = 0
 6011 0000 80B5     		push	{r7, lr}
 6012              	.LCFI69:
 6013              		.cfi_def_cfa_offset 8
 6014              		.cfi_offset 7, -8
 6015              		.cfi_offset 14, -4
 6016 0002 84B0     		sub	sp, sp, #16
 6017              	.LCFI70:
 6018              		.cfi_def_cfa_offset 24
 6019 0004 00AF     		add	r7, sp, #0
 6020              	.LCFI71:
 6021              		.cfi_def_cfa_register 7
 6022 0006 7860     		str	r0, [r7, #4]
2569:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2570:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2571:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2572:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2573:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2574:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2575:../Sources/drivers/mcg/mcg.c ****     short   i;
2576:../Sources/drivers/mcg/mcg.c ****     int     mcg_out;
2577:../Sources/drivers/mcg/mcg.c **** 
2578:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2579:../Sources/drivers/mcg/mcg.c **** 
2580:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2581:../Sources/drivers/mcg/mcg.c **** 
2582:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2583:../Sources/drivers/mcg/mcg.c **** 
2584:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2585:../Sources/drivers/mcg/mcg.c **** 
2586:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2587:../Sources/drivers/mcg/mcg.c **** 
2588:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2589:../Sources/drivers/mcg/mcg.c **** 
2590:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FEE mode
2591:../Sources/drivers/mcg/mcg.c **** 
2592:../Sources/drivers/mcg/mcg.c ****     if
2593:../Sources/drivers/mcg/mcg.c ****     (
2594:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 6023              		.loc 1 2594 0
 6024 0008 4FF48043 		mov	r3, #16384
 6025 000c C4F20603 		movt	r3, 16390
 6026 0010 9B79     		ldrb	r3, [r3, #6]
 6027 0012 DBB2     		uxtb	r3, r3
 6028 0014 03F00C03 		and	r3, r3, #12
 6029 0018 4FEA9303 		lsr	r3, r3, #2
2593:../Sources/drivers/mcg/mcg.c ****     (
 6030              		.loc 1 2593 0
 6031 001c 002B     		cmp	r3, #0
 6032 001e 13D1     		bne	.L512
2595:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 6033              		.loc 1 2595 0
 6034 0020 4FF48043 		mov	r3, #16384
 6035 0024 C4F20603 		movt	r3, 16390
 6036 0028 9B79     		ldrb	r3, [r3, #6]
 6037 002a DBB2     		uxtb	r3, r3
 6038 002c 03F01003 		and	r3, r3, #16
 6039 0030 002B     		cmp	r3, #0
 6040 0032 09D1     		bne	.L512
2596:../Sources/drivers/mcg/mcg.c ****           &&  (!(MCG_S & MCG_S_PLLST_MASK))
 6041              		.loc 1 2596 0
 6042 0034 4FF48043 		mov	r3, #16384
 6043 0038 C4F20603 		movt	r3, 16390
 6044 003c 9B79     		ldrb	r3, [r3, #6]
 6045 003e DBB2     		uxtb	r3, r3
 6046 0040 03F02003 		and	r3, r3, #32
2594:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 6047              		.loc 1 2594 0
 6048 0044 002B     		cmp	r3, #0
 6049 0046 02D0     		beq	.L513
 6050              	.L512:
2597:../Sources/drivers/mcg/mcg.c ****          )
2598:../Sources/drivers/mcg/mcg.c ****     )                   // check PLLS mux has selected FLL
2599:../Sources/drivers/mcg/mcg.c ****         {
2600:../Sources/drivers/mcg/mcg.c ****             return 0x2;     // return error code
 6051              		.loc 1 2600 0
 6052 0048 4FF00203 		mov	r3, #2
 6053 004c 59E0     		b	.L514
 6054              	.L513:
2601:../Sources/drivers/mcg/mcg.c ****         }
2602:../Sources/drivers/mcg/mcg.c **** 
2603:../Sources/drivers/mcg/mcg.c ****     // Check IRC frequency is within spec.
2604:../Sources/drivers/mcg/mcg.c **** 
2605:../Sources/drivers/mcg/mcg.c ****     if((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 6055              		.loc 1 2605 0
 6056 004e 7A68     		ldr	r2, [r7, #4]
 6057 0050 47F61123 		movw	r3, #31249
 6058 0054 9A42     		cmp	r2, r3
 6059 0056 04DD     		ble	.L515
 6060              		.loc 1 2605 0 is_stmt 0
 6061 0058 7A68     		ldr	r2, [r7, #4]
 6062 005a 49F69703 		movw	r3, #39063
 6063 005e 9A42     		cmp	r2, r3
 6064 0060 02DD     		ble	.L516
 6065              	.L515:
2606:../Sources/drivers/mcg/mcg.c ****         {
2607:../Sources/drivers/mcg/mcg.c ****             return 0x31;
 6066              		.loc 1 2607 0 is_stmt 1
 6067 0062 4FF03103 		mov	r3, #49
 6068 0066 4CE0     		b	.L514
 6069              	.L516:
2608:../Sources/drivers/mcg/mcg.c ****         }
2609:../Sources/drivers/mcg/mcg.c **** 
2610:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
2611:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(slow_irc_freq);
 6070              		.loc 1 2611 0
 6071 0068 7868     		ldr	r0, [r7, #4]
 6072 006a FFF7FEFF 		bl	fll_freq
 6073 006e B860     		str	r0, [r7, #8]
2612:../Sources/drivers/mcg/mcg.c **** 
2613:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 6074              		.loc 1 2613 0
 6075 0070 BB68     		ldr	r3, [r7, #8]
 6076 0072 3B2B     		cmp	r3, #59
 6077 0074 01DC     		bgt	.L517
2614:../Sources/drivers/mcg/mcg.c ****         {
2615:../Sources/drivers/mcg/mcg.c ****             return mcg_out; // If error code returned, return the code to calling function
 6078              		.loc 1 2615 0
 6079 0076 BB68     		ldr	r3, [r7, #8]
 6080 0078 43E0     		b	.L514
 6081              	.L517:
2616:../Sources/drivers/mcg/mcg.c ****         }
2617:../Sources/drivers/mcg/mcg.c **** 
2618:../Sources/drivers/mcg/mcg.c ****     // Ensure clock monitor is disabled before switching to FEI otherwise a loss of clock will trig
2619:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 6082              		.loc 1 2619 0
 6083 007a 4FF48043 		mov	r3, #16384
 6084 007e C4F20603 		movt	r3, 16390
 6085 0082 4FF48042 		mov	r2, #16384
 6086 0086 C4F20602 		movt	r2, 16390
 6087 008a 5279     		ldrb	r2, [r2, #5]
 6088 008c D2B2     		uxtb	r2, r2
 6089 008e 22F02002 		bic	r2, r2, #32
 6090 0092 D2B2     		uxtb	r2, r2
 6091 0094 5A71     		strb	r2, [r3, #5]
2620:../Sources/drivers/mcg/mcg.c ****     // Change FLL reference clock from external to internal by setting IREFS bit
2621:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_IREFS_MASK;                    // select internal reference
 6092              		.loc 1 2621 0
 6093 0096 4FF48043 		mov	r3, #16384
 6094 009a C4F20603 		movt	r3, 16390
 6095 009e 4FF48042 		mov	r2, #16384
 6096 00a2 C4F20602 		movt	r2, 16390
 6097 00a6 1278     		ldrb	r2, [r2, #0]
 6098 00a8 D2B2     		uxtb	r2, r2
 6099 00aa 42F00402 		orr	r2, r2, #4
 6100 00ae D2B2     		uxtb	r2, r2
 6101 00b0 1A70     		strb	r2, [r3, #0]
2622:../Sources/drivers/mcg/mcg.c **** 
2623:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock to switch to internal reference
2624:../Sources/drivers/mcg/mcg.c **** 
2625:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 6102              		.loc 1 2625 0
 6103 00b2 4FF00003 		mov	r3, #0
 6104 00b6 FB81     		strh	r3, [r7, #14]	@ movhi
 6105 00b8 0DE0     		b	.L518
 6106              	.L521:
2626:../Sources/drivers/mcg/mcg.c ****         {
2627:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loo
 6107              		.loc 1 2627 0
 6108 00ba 4FF48043 		mov	r3, #16384
 6109 00be C4F20603 		movt	r3, 16390
 6110 00c2 9B79     		ldrb	r3, [r3, #6]
 6111 00c4 DBB2     		uxtb	r3, r3
 6112 00c6 03F01003 		and	r3, r3, #16
 6113 00ca 002B     		cmp	r3, #0
 6114 00cc 0AD1     		bne	.L523
 6115              	.L519:
2625:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 6116              		.loc 1 2625 0
 6117 00ce FB89     		ldrh	r3, [r7, #14]	@ movhi
 6118 00d0 03F10103 		add	r3, r3, #1
 6119 00d4 FB81     		strh	r3, [r7, #14]	@ movhi
 6120              	.L518:
2625:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 6121              		.loc 1 2625 0 is_stmt 0
 6122 00d6 B7F90E20 		ldrsh	r2, [r7, #14]
 6123 00da 40F2CF73 		movw	r3, #1999
 6124 00de 9A42     		cmp	r2, r3
 6125 00e0 EBDD     		ble	.L521
 6126 00e2 00E0     		b	.L520
 6127              	.L523:
 6128              		.loc 1 2627 0 is_stmt 1
 6129 00e4 00BF     		nop
 6130              	.L520:
2628:../Sources/drivers/mcg/mcg.c ****         }
2629:../Sources/drivers/mcg/mcg.c **** 
2630:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 6131              		.loc 1 2630 0
 6132 00e6 4FF48043 		mov	r3, #16384
 6133 00ea C4F20603 		movt	r3, 16390
 6134 00ee 9B79     		ldrb	r3, [r3, #6]
 6135 00f0 DBB2     		uxtb	r3, r3
 6136 00f2 03F01003 		and	r3, r3, #16
 6137 00f6 002B     		cmp	r3, #0
 6138 00f8 02D1     		bne	.L522
 6139              		.loc 1 2630 0 is_stmt 0
 6140 00fa 4FF01203 		mov	r3, #18
 6141 00fe 00E0     		b	.L514
 6142              	.L522:
2631:../Sources/drivers/mcg/mcg.c **** 
2632:../Sources/drivers/mcg/mcg.c ****     // Now in FEI mode
2633:../Sources/drivers/mcg/mcg.c ****     return mcg_out;
 6143              		.loc 1 2633 0 is_stmt 1
 6144 0100 BB68     		ldr	r3, [r7, #8]
 6145              	.L514:
2634:../Sources/drivers/mcg/mcg.c **** }   // fee_fei
 6146              		.loc 1 2634 0
 6147 0102 1846     		mov	r0, r3
 6148 0104 07F11007 		add	r7, r7, #16
 6149 0108 BD46     		mov	sp, r7
 6150 010a 80BD     		pop	{r7, pc}
 6151              		.cfi_endproc
 6152              	.LFE23:
 6154              		.global	__aeabi_i2f
 6155              		.global	__aeabi_fdiv
 6156              		.global	__aeabi_fmul
 6157              		.global	__aeabi_f2uiz
 6158              		.section	.text.atc,"ax",%progbits
 6159              		.align	2
 6160              		.global	atc
 6161              		.thumb
 6162              		.thumb_func
 6164              	atc:
 6165              	.LFB24:
2635:../Sources/drivers/mcg/mcg.c **** 
2636:../Sources/drivers/mcg/mcg.c **** /* */
2637:../Sources/drivers/mcg/mcg.c **** 
2638:../Sources/drivers/mcg/mcg.c **** unsigned char atc
2639:../Sources/drivers/mcg/mcg.c **** (
2640:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select,
2641:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
2642:../Sources/drivers/mcg/mcg.c ****     int             mcg_out_freq
2643:../Sources/drivers/mcg/mcg.c **** )
2644:../Sources/drivers/mcg/mcg.c **** {
 6166              		.loc 1 2644 0
 6167              		.cfi_startproc
 6168              		@ args = 0, pretend = 0, frame = 40
 6169              		@ frame_needed = 1, uses_anonymous_args = 0
 6170 0000 90B5     		push	{r4, r7, lr}
 6171              	.LCFI72:
 6172              		.cfi_def_cfa_offset 12
 6173              		.cfi_offset 4, -12
 6174              		.cfi_offset 7, -8
 6175              		.cfi_offset 14, -4
 6176 0002 8BB0     		sub	sp, sp, #44
 6177              	.LCFI73:
 6178              		.cfi_def_cfa_offset 56
 6179 0004 00AF     		add	r7, sp, #0
 6180              	.LCFI74:
 6181              		.cfi_def_cfa_register 7
 6182 0006 0346     		mov	r3, r0
 6183 0008 B960     		str	r1, [r7, #8]
 6184 000a 7A60     		str	r2, [r7, #4]
 6185 000c FB73     		strb	r3, [r7, #15]
2645:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2646:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2647:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2648:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2649:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2650:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2651:../Sources/drivers/mcg/mcg.c ****     unsigned char   mcg_mode;
2652:../Sources/drivers/mcg/mcg.c ****     unsigned short  atcv;
2653:../Sources/drivers/mcg/mcg.c ****     int             bus_clock_freq;
2654:../Sources/drivers/mcg/mcg.c ****     int             bus_clk_div_val;
2655:../Sources/drivers/mcg/mcg.c ****     int             orig_div;
2656:../Sources/drivers/mcg/mcg.c ****     int             temp_reg;
2657:../Sources/drivers/mcg/mcg.c **** 
2658:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2659:../Sources/drivers/mcg/mcg.c **** 
2660:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2661:../Sources/drivers/mcg/mcg.c **** 
2662:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2663:../Sources/drivers/mcg/mcg.c **** 
2664:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2665:../Sources/drivers/mcg/mcg.c **** 
2666:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2667:../Sources/drivers/mcg/mcg.c **** 
2668:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2669:../Sources/drivers/mcg/mcg.c **** 
2670:../Sources/drivers/mcg/mcg.c ****     if(irc_select > 0)  // force irc to 1 if greater than 0
 6186              		.loc 1 2670 0
 6187 000e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6188 0010 002B     		cmp	r3, #0
 6189 0012 02D0     		beq	.L525
2671:../Sources/drivers/mcg/mcg.c ****         {
2672:../Sources/drivers/mcg/mcg.c ****             irc_select = 1;
 6190              		.loc 1 2672 0
 6191 0014 4FF00103 		mov	r3, #1
 6192 0018 FB73     		strb	r3, [r7, #15]
 6193              	.L525:
2673:../Sources/drivers/mcg/mcg.c ****         }
2674:../Sources/drivers/mcg/mcg.c **** 
2675:../Sources/drivers/mcg/mcg.c ****     mcg_mode = what_mcg_mode();                                     // get present MCG mode
 6194              		.loc 1 2675 0
 6195 001a FFF7FEFF 		bl	what_mcg_mode
 6196 001e 0346     		mov	r3, r0
 6197 0020 87F82530 		strb	r3, [r7, #37]
2676:../Sources/drivers/mcg/mcg.c **** 
2677:../Sources/drivers/mcg/mcg.c ****     if((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 6198              		.loc 1 2677 0
 6199 0024 97F82530 		ldrb	r3, [r7, #37]	@ zero_extendqisi2
 6200 0028 082B     		cmp	r3, #8
 6201 002a 0AD0     		beq	.L526
 6202              		.loc 1 2677 0 is_stmt 0
 6203 002c 97F82530 		ldrb	r3, [r7, #37]	@ zero_extendqisi2
 6204 0030 072B     		cmp	r3, #7
 6205 0032 06D0     		beq	.L526
 6206 0034 97F82530 		ldrb	r3, [r7, #37]	@ zero_extendqisi2
 6207 0038 052B     		cmp	r3, #5
 6208 003a 02D0     		beq	.L526
2678:../Sources/drivers/mcg/mcg.c ****         {
2679:../Sources/drivers/mcg/mcg.c ****             return 1;                                                   // return error code if not
 6209              		.loc 1 2679 0 is_stmt 1
 6210 003c 4FF00103 		mov	r3, #1
 6211 0040 98E1     		b	.L527
 6212              	.L526:
2680:../Sources/drivers/mcg/mcg.c ****         }
2681:../Sources/drivers/mcg/mcg.c **** 
2682:../Sources/drivers/mcg/mcg.c ****     orig_div = SIM_CLKDIV1;                                         //store present clock divider v
 6213              		.loc 1 2682 0
 6214 0042 4FF4E043 		mov	r3, #28672
 6215 0046 C4F20403 		movt	r3, 16388
 6216 004a 03F58253 		add	r3, r3, #4160
 6217 004e 03F10403 		add	r3, r3, #4
 6218 0052 1B68     		ldr	r3, [r3, #0]
 6219 0054 3B62     		str	r3, [r7, #32]
2683:../Sources/drivers/mcg/mcg.c ****     bus_clk_div_val = mcg_out_freq / 16000000;                      // calculate bus clock divider 
 6220              		.loc 1 2683 0
 6221 0056 7A68     		ldr	r2, [r7, #4]
 6222 0058 4DF68363 		movw	r3, #56963
 6223 005c C4F21B33 		movt	r3, 17179
 6224 0060 83FB0213 		smull	r1, r3, r3, r2
 6225 0064 4FEAA351 		asr	r1, r3, #22
 6226 0068 4FEAE273 		asr	r3, r2, #31
 6227 006c CB1A     		subs	r3, r1, r3
 6228 006e FB61     		str	r3, [r7, #28]
2684:../Sources/drivers/mcg/mcg.c ****     temp_reg = SIM_CLKDIV1;
 6229              		.loc 1 2684 0
 6230 0070 4FF4E043 		mov	r3, #28672
 6231 0074 C4F20403 		movt	r3, 16388
 6232 0078 03F58253 		add	r3, r3, #4160
 6233 007c 03F10403 		add	r3, r3, #4
 6234 0080 1B68     		ldr	r3, [r3, #0]
 6235 0082 BB61     		str	r3, [r7, #24]
2685:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK;                          // clear dividers except core
 6236              		.loc 1 2685 0
 6237 0084 BB69     		ldr	r3, [r7, #24]
 6238 0086 23F47023 		bic	r3, r3, #983040
 6239 008a BB61     		str	r3, [r7, #24]
2686:../Sources/drivers/mcg/mcg.c ****     // set all bus and flash dividers to same value to ensure clocking restrictions are met
2687:../Sources/drivers/mcg/mcg.c ****     temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
 6240              		.loc 1 2687 0
 6241 008c FB69     		ldr	r3, [r7, #28]
 6242 008e 4FEA0343 		lsl	r3, r3, #16
 6243 0092 03F47022 		and	r2, r3, #983040
 6244 0096 BB69     		ldr	r3, [r7, #24]
 6245 0098 1343     		orrs	r3, r3, r2
 6246 009a BB61     		str	r3, [r7, #24]
2688:../Sources/drivers/mcg/mcg.c ****     SIM_CLKDIV1 = temp_reg;                                         // set actual dividers
 6247              		.loc 1 2688 0
 6248 009c 4FF4E043 		mov	r3, #28672
 6249 00a0 C4F20403 		movt	r3, 16388
 6250 00a4 BA69     		ldr	r2, [r7, #24]
 6251 00a6 03F58253 		add	r3, r3, #4160
 6252 00aa 03F10403 		add	r3, r3, #4
 6253 00ae 1A60     		str	r2, [r3, #0]
2689:../Sources/drivers/mcg/mcg.c ****     bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16) + 1);    //For KL25, flash and bus use t
 6254              		.loc 1 2689 0
 6255 00b0 7A68     		ldr	r2, [r7, #4]
 6256 00b2 4FF4E043 		mov	r3, #28672
 6257 00b6 C4F20403 		movt	r3, 16388
 6258 00ba 03F58253 		add	r3, r3, #4160
 6259 00be 03F10403 		add	r3, r3, #4
 6260 00c2 1B68     		ldr	r3, [r3, #0]
 6261 00c4 4FEA1343 		lsr	r3, r3, #16
 6262 00c8 03F10103 		add	r3, r3, #1
 6263 00cc B2FBF3F3 		udiv	r3, r2, r3
 6264 00d0 7B61     		str	r3, [r7, #20]
2690:../Sources/drivers/mcg/mcg.c **** 
2691:../Sources/drivers/mcg/mcg.c ****     if((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
 6265              		.loc 1 2691 0
 6266 00d2 7A69     		ldr	r2, [r7, #20]
 6267 00d4 41F2FF13 		movw	r3, #4607
 6268 00d8 C0F27A03 		movt	r3, 122
 6269 00dc 9A42     		cmp	r2, r3
 6270 00de 06DD     		ble	.L528
 6271              		.loc 1 2691 0 is_stmt 0
 6272 00e0 7A69     		ldr	r2, [r7, #20]
 6273 00e2 4FF41053 		mov	r3, #9216
 6274 00e6 C0F2F403 		movt	r3, 244
 6275 00ea 9A42     		cmp	r2, r3
 6276 00ec 0CDD     		ble	.L529
 6277              	.L528:
2692:../Sources/drivers/mcg/mcg.c ****         {
2693:../Sources/drivers/mcg/mcg.c ****             SIM_CLKDIV1 = orig_div;     // set SIM_CLKDIV1 back to original value
 6278              		.loc 1 2693 0 is_stmt 1
 6279 00ee 4FF4E043 		mov	r3, #28672
 6280 00f2 C4F20403 		movt	r3, 16388
 6281 00f6 3A6A     		ldr	r2, [r7, #32]
 6282 00f8 03F58253 		add	r3, r3, #4160
 6283 00fc 03F10403 		add	r3, r3, #4
 6284 0100 1A60     		str	r2, [r3, #0]
2694:../Sources/drivers/mcg/mcg.c ****             return 3;                   // error, bus clock frequency is not within 8MHz to 16MHz
 6285              		.loc 1 2694 0
 6286 0102 4FF00303 		mov	r3, #3
 6287 0106 35E1     		b	.L527
 6288              	.L529:
2695:../Sources/drivers/mcg/mcg.c ****         }
2696:../Sources/drivers/mcg/mcg.c **** 
2697:../Sources/drivers/mcg/mcg.c ****     if(!irc_select)                 //determine if slow or fast IRC to be trimmed
 6289              		.loc 1 2697 0
 6290 0108 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6291 010a 002B     		cmp	r3, #0
 6292 010c 23D1     		bne	.L530
2698:../Sources/drivers/mcg/mcg.c ****         {
2699:../Sources/drivers/mcg/mcg.c ****             if(irc_freq < 31250)        // check frequency is above min spec.
 6293              		.loc 1 2699 0
 6294 010e BA68     		ldr	r2, [r7, #8]
 6295 0110 47F61123 		movw	r3, #31249
 6296 0114 9A42     		cmp	r2, r3
 6297 0116 0CDC     		bgt	.L531
2700:../Sources/drivers/mcg/mcg.c ****                 {
2701:../Sources/drivers/mcg/mcg.c ****                     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 6298              		.loc 1 2701 0
 6299 0118 4FF4E043 		mov	r3, #28672
 6300 011c C4F20403 		movt	r3, 16388
 6301 0120 3A6A     		ldr	r2, [r7, #32]
 6302 0122 03F58253 		add	r3, r3, #4160
 6303 0126 03F10403 		add	r3, r3, #4
 6304 012a 1A60     		str	r2, [r3, #0]
2702:../Sources/drivers/mcg/mcg.c ****                     return 4;
 6305              		.loc 1 2702 0
 6306 012c 4FF00403 		mov	r3, #4
 6307 0130 20E1     		b	.L527
 6308              	.L531:
2703:../Sources/drivers/mcg/mcg.c ****                 }
2704:../Sources/drivers/mcg/mcg.c **** 
2705:../Sources/drivers/mcg/mcg.c ****             if(irc_freq > 39062)        // check frequency is below max spec.
 6309              		.loc 1 2705 0
 6310 0132 BA68     		ldr	r2, [r7, #8]
 6311 0134 49F69603 		movw	r3, #39062
 6312 0138 9A42     		cmp	r2, r3
 6313 013a 34DD     		ble	.L532
2706:../Sources/drivers/mcg/mcg.c ****                 {
2707:../Sources/drivers/mcg/mcg.c ****                     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 6314              		.loc 1 2707 0
 6315 013c 4FF4E043 		mov	r3, #28672
 6316 0140 C4F20403 		movt	r3, 16388
 6317 0144 3A6A     		ldr	r2, [r7, #32]
 6318 0146 03F58253 		add	r3, r3, #4160
 6319 014a 03F10403 		add	r3, r3, #4
 6320 014e 1A60     		str	r2, [r3, #0]
2708:../Sources/drivers/mcg/mcg.c ****                     return 5;
 6321              		.loc 1 2708 0
 6322 0150 4FF00503 		mov	r3, #5
 6323 0154 0EE1     		b	.L527
 6324              	.L530:
2709:../Sources/drivers/mcg/mcg.c ****                 }
2710:../Sources/drivers/mcg/mcg.c ****         }
2711:../Sources/drivers/mcg/mcg.c ****     else
2712:../Sources/drivers/mcg/mcg.c ****         {
2713:../Sources/drivers/mcg/mcg.c ****             if(irc_freq < 3000000)      // check frequency is above min spec.
 6325              		.loc 1 2713 0
 6326 0156 BA68     		ldr	r2, [r7, #8]
 6327 0158 4CF2BF63 		movw	r3, #50879
 6328 015c C0F22D03 		movt	r3, 45
 6329 0160 9A42     		cmp	r2, r3
 6330 0162 0CDC     		bgt	.L533
2714:../Sources/drivers/mcg/mcg.c ****                 {
2715:../Sources/drivers/mcg/mcg.c ****                     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 6331              		.loc 1 2715 0
 6332 0164 4FF4E043 		mov	r3, #28672
 6333 0168 C4F20403 		movt	r3, 16388
 6334 016c 3A6A     		ldr	r2, [r7, #32]
 6335 016e 03F58253 		add	r3, r3, #4160
 6336 0172 03F10403 		add	r3, r3, #4
 6337 0176 1A60     		str	r2, [r3, #0]
2716:../Sources/drivers/mcg/mcg.c ****                     return 6;
 6338              		.loc 1 2716 0
 6339 0178 4FF00603 		mov	r3, #6
 6340 017c FAE0     		b	.L527
 6341              	.L533:
2717:../Sources/drivers/mcg/mcg.c ****                 }
2718:../Sources/drivers/mcg/mcg.c **** 
2719:../Sources/drivers/mcg/mcg.c ****             if(irc_freq > 5000000)      // check frequency is below max spec.
 6342              		.loc 1 2719 0
 6343 017e BA68     		ldr	r2, [r7, #8]
 6344 0180 44F64033 		movw	r3, #19264
 6345 0184 C0F24C03 		movt	r3, 76
 6346 0188 9A42     		cmp	r2, r3
 6347 018a 0CDD     		ble	.L532
2720:../Sources/drivers/mcg/mcg.c ****                 {
2721:../Sources/drivers/mcg/mcg.c ****                     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 6348              		.loc 1 2721 0
 6349 018c 4FF4E043 		mov	r3, #28672
 6350 0190 C4F20403 		movt	r3, 16388
 6351 0194 3A6A     		ldr	r2, [r7, #32]
 6352 0196 03F58253 		add	r3, r3, #4160
 6353 019a 03F10403 		add	r3, r3, #4
 6354 019e 1A60     		str	r2, [r3, #0]
2722:../Sources/drivers/mcg/mcg.c ****                     return 7;
 6355              		.loc 1 2722 0
 6356 01a0 4FF00703 		mov	r3, #7
 6357 01a4 E6E0     		b	.L527
 6358              	.L532:
2723:../Sources/drivers/mcg/mcg.c ****                 }
2724:../Sources/drivers/mcg/mcg.c ****         }   // if
2725:../Sources/drivers/mcg/mcg.c **** 
2726:../Sources/drivers/mcg/mcg.c ****     // Set up autocal registers, must use floating point calculation
2727:../Sources/drivers/mcg/mcg.c **** 
2728:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 6359              		.loc 1 2728 0
 6360 01a6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6361 01a8 002B     		cmp	r3, #0
 6362 01aa 20D0     		beq	.L534
2729:../Sources/drivers/mcg/mcg.c ****         atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
 6363              		.loc 1 2729 0
 6364 01ac 7869     		ldr	r0, [r7, #20]
 6365 01ae FFF7FEFF 		bl	__aeabi_i2f
 6366 01b2 0446     		mov	r4, r0
 6367 01b4 B868     		ldr	r0, [r7, #8]
 6368 01b6 FFF7FEFF 		bl	__aeabi_i2f
 6369 01ba 0346     		mov	r3, r0
 6370 01bc 2046     		mov	r0, r4
 6371 01be 1946     		mov	r1, r3
 6372 01c0 FFF7FEFF 		bl	__aeabi_fdiv
 6373 01c4 0346     		mov	r3, r0
 6374 01c6 1846     		mov	r0, r3
 6375 01c8 4FF00001 		mov	r1, #0
 6376 01cc C4F2A811 		movt	r1, 16808
 6377 01d0 FFF7FEFF 		bl	__aeabi_fmul
 6378 01d4 0346     		mov	r3, r0
 6379 01d6 1846     		mov	r0, r3
 6380 01d8 4FF08641 		mov	r1, #1124073472
 6381 01dc FFF7FEFF 		bl	__aeabi_fmul
 6382 01e0 0346     		mov	r3, r0
 6383 01e2 1846     		mov	r0, r3
 6384 01e4 FFF7FEFF 		bl	__aeabi_f2uiz
 6385 01e8 0346     		mov	r3, r0
 6386 01ea FB84     		strh	r3, [r7, #38]	@ movhi
 6387 01ec 19E0     		b	.L535
 6388              	.L534:
2730:../Sources/drivers/mcg/mcg.c ****     else
2731:../Sources/drivers/mcg/mcg.c ****         atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
 6389              		.loc 1 2731 0
 6390 01ee 7869     		ldr	r0, [r7, #20]
 6391 01f0 FFF7FEFF 		bl	__aeabi_i2f
 6392 01f4 0446     		mov	r4, r0
 6393 01f6 B868     		ldr	r0, [r7, #8]
 6394 01f8 FFF7FEFF 		bl	__aeabi_i2f
 6395 01fc 0346     		mov	r3, r0
 6396 01fe 2046     		mov	r0, r4
 6397 0200 1946     		mov	r1, r3
 6398 0202 FFF7FEFF 		bl	__aeabi_fdiv
 6399 0206 0346     		mov	r3, r0
 6400 0208 1846     		mov	r0, r3
 6401 020a 4FF00001 		mov	r1, #0
 6402 020e C4F2A811 		movt	r1, 16808
 6403 0212 FFF7FEFF 		bl	__aeabi_fmul
 6404 0216 0346     		mov	r3, r0
 6405 0218 1846     		mov	r0, r3
 6406 021a FFF7FEFF 		bl	__aeabi_f2uiz
 6407 021e 0346     		mov	r3, r0
 6408 0220 FB84     		strh	r3, [r7, #38]	@ movhi
 6409              	.L535:
2732:../Sources/drivers/mcg/mcg.c **** 
2733:../Sources/drivers/mcg/mcg.c ****     MCG_ATCVL = (atcv & 0xFF);          //Set ATCVL to lower 8 bits of count value
 6410              		.loc 1 2733 0
 6411 0222 4FF48043 		mov	r3, #16384
 6412 0226 C4F20603 		movt	r3, 16390
 6413 022a FA8C     		ldrh	r2, [r7, #38]	@ movhi
 6414 022c D2B2     		uxtb	r2, r2
 6415 022e DA72     		strb	r2, [r3, #11]
2734:../Sources/drivers/mcg/mcg.c ****     MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
 6416              		.loc 1 2734 0
 6417 0230 4FF48043 		mov	r3, #16384
 6418 0234 C4F20603 		movt	r3, 16390
 6419 0238 FA8C     		ldrh	r2, [r7, #38]
 6420 023a 4FEA1222 		lsr	r2, r2, #8
 6421 023e 92B2     		uxth	r2, r2
 6422 0240 D2B2     		uxtb	r2, r2
 6423 0242 9A72     		strb	r2, [r3, #10]
2735:../Sources/drivers/mcg/mcg.c ****     // Enable autocal
2736:../Sources/drivers/mcg/mcg.c ****     MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK | MCG_SC_ATMF_MASK);    // clear auto trim sett
 6424              		.loc 1 2736 0
 6425 0244 4FF48043 		mov	r3, #16384
 6426 0248 C4F20603 		movt	r3, 16390
 6427 024c 4FF48042 		mov	r2, #16384
 6428 0250 C4F20602 		movt	r2, 16390
 6429 0254 127A     		ldrb	r2, [r2, #8]
 6430 0256 D2B2     		uxtb	r2, r2
 6431 0258 02F01F02 		and	r2, r2, #31
 6432 025c D2B2     		uxtb	r2, r2
 6433 025e 1A72     		strb	r2, [r3, #8]
2737:../Sources/drivers/mcg/mcg.c ****     temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT));      //Select IRC to trim an
 6434              		.loc 1 2737 0
 6435 0260 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6436 0262 4FEA8313 		lsl	r3, r3, #6
 6437 0266 43F08003 		orr	r3, r3, #128
 6438 026a BB61     		str	r3, [r7, #24]
2738:../Sources/drivers/mcg/mcg.c ****     MCG_SC |= temp_reg;
 6439              		.loc 1 2738 0
 6440 026c 4FF48043 		mov	r3, #16384
 6441 0270 C4F20603 		movt	r3, 16390
 6442 0274 4FF48042 		mov	r2, #16384
 6443 0278 C4F20602 		movt	r2, 16390
 6444 027c 127A     		ldrb	r2, [r2, #8]
 6445 027e D2B2     		uxtb	r2, r2
 6446 0280 D1B2     		uxtb	r1, r2
 6447 0282 BA69     		ldr	r2, [r7, #24]
 6448 0284 D2B2     		uxtb	r2, r2
 6449 0286 0A43     		orrs	r2, r2, r1
 6450 0288 D2B2     		uxtb	r2, r2
 6451 028a D2B2     		uxtb	r2, r2
 6452 028c 1A72     		strb	r2, [r3, #8]
2739:../Sources/drivers/mcg/mcg.c **** 
2740:../Sources/drivers/mcg/mcg.c ****     while(MCG_SC & MCG_SC_ATME_MASK)
 6453              		.loc 1 2740 0
 6454 028e 00BF     		nop
 6455              	.L536:
 6456              		.loc 1 2740 0 is_stmt 0
 6457 0290 4FF48043 		mov	r3, #16384
 6458 0294 C4F20603 		movt	r3, 16390
 6459 0298 1B7A     		ldrb	r3, [r3, #8]
 6460 029a DBB2     		uxtb	r3, r3
 6461 029c DBB2     		uxtb	r3, r3
 6462 029e 5BB2     		sxtb	r3, r3
 6463 02a0 002B     		cmp	r3, #0
 6464 02a2 F5DB     		blt	.L536
2741:../Sources/drivers/mcg/mcg.c ****         {
2742:../Sources/drivers/mcg/mcg.c ****         };
2743:../Sources/drivers/mcg/mcg.c **** 
2744:../Sources/drivers/mcg/mcg.c ****     //poll for ATME bit to clear
2745:../Sources/drivers/mcg/mcg.c ****     if(MCG_SC & MCG_SC_ATMF_MASK)       // check if error flag set
 6465              		.loc 1 2745 0 is_stmt 1
 6466 02a4 4FF48043 		mov	r3, #16384
 6467 02a8 C4F20603 		movt	r3, 16390
 6468 02ac 1B7A     		ldrb	r3, [r3, #8]
 6469 02ae DBB2     		uxtb	r3, r3
 6470 02b0 03F02003 		and	r3, r3, #32
 6471 02b4 002B     		cmp	r3, #0
 6472 02b6 0CD0     		beq	.L537
2746:../Sources/drivers/mcg/mcg.c ****         {
2747:../Sources/drivers/mcg/mcg.c ****             SIM_CLKDIV1 = orig_div;         // set SIM_CLKDIV1 back to original value
 6473              		.loc 1 2747 0
 6474 02b8 4FF4E043 		mov	r3, #28672
 6475 02bc C4F20403 		movt	r3, 16388
 6476 02c0 3A6A     		ldr	r2, [r7, #32]
 6477 02c2 03F58253 		add	r3, r3, #4160
 6478 02c6 03F10403 		add	r3, r3, #4
 6479 02ca 1A60     		str	r2, [r3, #0]
2748:../Sources/drivers/mcg/mcg.c ****             return 8;
 6480              		.loc 1 2748 0
 6481 02cc 4FF00803 		mov	r3, #8
 6482 02d0 50E0     		b	.L527
 6483              	.L537:
2749:../Sources/drivers/mcg/mcg.c ****         }
2750:../Sources/drivers/mcg/mcg.c ****     else
2751:../Sources/drivers/mcg/mcg.c ****         {
2752:../Sources/drivers/mcg/mcg.c ****             if(!irc_select)
 6484              		.loc 1 2752 0
 6485 02d2 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6486 02d4 002B     		cmp	r3, #0
 6487 02d6 1CD1     		bne	.L538
2753:../Sources/drivers/mcg/mcg.c ****                 {
2754:../Sources/drivers/mcg/mcg.c ****                     if((MCG_C3 == 0xFF) || (MCG_C3 == 0))
 6488              		.loc 1 2754 0
 6489 02d8 4FF48043 		mov	r3, #16384
 6490 02dc C4F20603 		movt	r3, 16390
 6491 02e0 9B78     		ldrb	r3, [r3, #2]
 6492 02e2 DBB2     		uxtb	r3, r3
 6493 02e4 FF2B     		cmp	r3, #255
 6494 02e6 07D0     		beq	.L539
 6495              		.loc 1 2754 0 is_stmt 0
 6496 02e8 4FF48043 		mov	r3, #16384
 6497 02ec C4F20603 		movt	r3, 16390
 6498 02f0 9B78     		ldrb	r3, [r3, #2]
 6499 02f2 DBB2     		uxtb	r3, r3
 6500 02f4 002B     		cmp	r3, #0
 6501 02f6 31D1     		bne	.L540
 6502              	.L539:
2755:../Sources/drivers/mcg/mcg.c ****                         {
2756:../Sources/drivers/mcg/mcg.c ****                             SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 6503              		.loc 1 2756 0 is_stmt 1
 6504 02f8 4FF4E043 		mov	r3, #28672
 6505 02fc C4F20403 		movt	r3, 16388
 6506 0300 3A6A     		ldr	r2, [r7, #32]
 6507 0302 03F58253 		add	r3, r3, #4160
 6508 0306 03F10403 		add	r3, r3, #4
 6509 030a 1A60     		str	r2, [r3, #0]
2757:../Sources/drivers/mcg/mcg.c ****                             return 9;
 6510              		.loc 1 2757 0
 6511 030c 4FF00903 		mov	r3, #9
 6512 0310 30E0     		b	.L527
 6513              	.L538:
2758:../Sources/drivers/mcg/mcg.c ****                         }
2759:../Sources/drivers/mcg/mcg.c ****                 }
2760:../Sources/drivers/mcg/mcg.c ****             else
2761:../Sources/drivers/mcg/mcg.c ****                 {
2762:../Sources/drivers/mcg/mcg.c ****                     if
2763:../Sources/drivers/mcg/mcg.c ****                     (
2764:../Sources/drivers/mcg/mcg.c ****                         (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF)
 6514              		.loc 1 2764 0
 6515 0312 4FF48043 		mov	r3, #16384
 6516 0316 C4F20603 		movt	r3, 16390
 6517 031a DB78     		ldrb	r3, [r3, #3]
 6518 031c DBB2     		uxtb	r3, r3
 6519 031e 03F01E03 		and	r3, r3, #30
 6520 0322 4FEA5303 		lsr	r3, r3, #1
2763:../Sources/drivers/mcg/mcg.c ****                     (
 6521              		.loc 1 2763 0
 6522 0326 0F2B     		cmp	r3, #15
 6523 0328 0BD0     		beq	.L541
2765:../Sources/drivers/mcg/mcg.c ****                         ||  (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0)
 6524              		.loc 1 2765 0
 6525 032a 4FF48043 		mov	r3, #16384
 6526 032e C4F20603 		movt	r3, 16390
 6527 0332 DB78     		ldrb	r3, [r3, #3]
 6528 0334 DBB2     		uxtb	r3, r3
 6529 0336 03F01E03 		and	r3, r3, #30
 6530 033a 4FEA5303 		lsr	r3, r3, #1
 6531 033e 002B     		cmp	r3, #0
 6532 0340 0CD1     		bne	.L540
 6533              	.L541:
2766:../Sources/drivers/mcg/mcg.c ****                     )
2767:../Sources/drivers/mcg/mcg.c ****                         {
2768:../Sources/drivers/mcg/mcg.c ****                             SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 6534              		.loc 1 2768 0
 6535 0342 4FF4E043 		mov	r3, #28672
 6536 0346 C4F20403 		movt	r3, 16388
 6537 034a 3A6A     		ldr	r2, [r7, #32]
 6538 034c 03F58253 		add	r3, r3, #4160
 6539 0350 03F10403 		add	r3, r3, #4
 6540 0354 1A60     		str	r2, [r3, #0]
2769:../Sources/drivers/mcg/mcg.c ****                             return 10;
 6541              		.loc 1 2769 0
 6542 0356 4FF00A03 		mov	r3, #10
 6543 035a 0BE0     		b	.L527
 6544              	.L540:
2770:../Sources/drivers/mcg/mcg.c ****                         }
2771:../Sources/drivers/mcg/mcg.c ****                 }
2772:../Sources/drivers/mcg/mcg.c ****         }
2773:../Sources/drivers/mcg/mcg.c **** 
2774:../Sources/drivers/mcg/mcg.c ****     SIM_CLKDIV1 = orig_div;             // set SIM_CLKDIV1 back to original value
 6545              		.loc 1 2774 0
 6546 035c 4FF4E043 		mov	r3, #28672
 6547 0360 C4F20403 		movt	r3, 16388
 6548 0364 3A6A     		ldr	r2, [r7, #32]
 6549 0366 03F58253 		add	r3, r3, #4160
 6550 036a 03F10403 		add	r3, r3, #4
 6551 036e 1A60     		str	r2, [r3, #0]
2775:../Sources/drivers/mcg/mcg.c ****     return 0;
 6552              		.loc 1 2775 0
 6553 0370 4FF00003 		mov	r3, #0
 6554              	.L527:
2776:../Sources/drivers/mcg/mcg.c **** }   // atc
 6555              		.loc 1 2776 0
 6556 0374 1846     		mov	r0, r3
 6557 0376 07F12C07 		add	r7, r7, #44
 6558 037a BD46     		mov	sp, r7
 6559 037c 90BD     		pop	{r4, r7, pc}
 6560              		.cfi_endproc
 6561              	.LFE24:
 6563 037e 00BF     		.section	.text.fll_freq,"ax",%progbits
 6564              		.align	2
 6565              		.global	fll_freq
 6566              		.thumb
 6567              		.thumb_func
 6569              	fll_freq:
 6570              	.LFB25:
2777:../Sources/drivers/mcg/mcg.c **** 
2778:../Sources/drivers/mcg/mcg.c **** /* */
2779:../Sources/drivers/mcg/mcg.c **** 
2780:../Sources/drivers/mcg/mcg.c **** int fll_freq
2781:../Sources/drivers/mcg/mcg.c **** (int fll_ref)
2782:../Sources/drivers/mcg/mcg.c **** {
 6571              		.loc 1 2782 0
 6572              		.cfi_startproc
 6573              		@ args = 0, pretend = 0, frame = 16
 6574              		@ frame_needed = 1, uses_anonymous_args = 0
 6575              		@ link register save eliminated.
 6576 0000 80B4     		push	{r7}
 6577              	.LCFI75:
 6578              		.cfi_def_cfa_offset 4
 6579              		.cfi_offset 7, -4
 6580 0002 85B0     		sub	sp, sp, #20
 6581              	.LCFI76:
 6582              		.cfi_def_cfa_offset 24
 6583 0004 00AF     		add	r7, sp, #0
 6584              	.LCFI77:
 6585              		.cfi_def_cfa_register 7
 6586 0006 7860     		str	r0, [r7, #4]
2783:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2784:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2785:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2786:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2787:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2788:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2789:../Sources/drivers/mcg/mcg.c ****     int fll_freq_hz;
2790:../Sources/drivers/mcg/mcg.c **** 
2791:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2792:../Sources/drivers/mcg/mcg.c **** 
2793:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2794:../Sources/drivers/mcg/mcg.c **** 
2795:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2796:../Sources/drivers/mcg/mcg.c **** 
2797:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2798:../Sources/drivers/mcg/mcg.c **** 
2799:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2800:../Sources/drivers/mcg/mcg.c **** 
2801:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2802:../Sources/drivers/mcg/mcg.c **** 
2803:../Sources/drivers/mcg/mcg.c ****     // Check that only allowed ranges have been selected
2804:../Sources/drivers/mcg/mcg.c **** 
2805:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1)
 6587              		.loc 1 2805 0
 6588 0008 4FF48043 		mov	r3, #16384
 6589 000c C4F20603 		movt	r3, 16390
 6590 0010 DB78     		ldrb	r3, [r3, #3]
 6591 0012 DBB2     		uxtb	r3, r3
 6592 0014 03F06003 		and	r3, r3, #96
 6593 0018 4FEA5313 		lsr	r3, r3, #5
 6594 001c 012B     		cmp	r3, #1
 6595 001e 02D9     		bls	.L543
2806:../Sources/drivers/mcg/mcg.c ****         {
2807:../Sources/drivers/mcg/mcg.c ****             return 0x3B;    // return error code if DRS range 2 or 3 selected
 6596              		.loc 1 2807 0
 6597 0020 4FF03B03 		mov	r3, #59
 6598 0024 26E1     		b	.L544
 6599              	.L543:
2808:../Sources/drivers/mcg/mcg.c ****         }
2809:../Sources/drivers/mcg/mcg.c **** 
2810:../Sources/drivers/mcg/mcg.c ****     if(MCG_C4 & MCG_C4_DMX32_MASK)  // if DMX32 set
 6600              		.loc 1 2810 0
 6601 0026 4FF48043 		mov	r3, #16384
 6602 002a C4F20603 		movt	r3, 16390
 6603 002e DB78     		ldrb	r3, [r3, #3]
 6604 0030 DBB2     		uxtb	r3, r3
 6605 0032 DBB2     		uxtb	r3, r3
 6606 0034 5BB2     		sxtb	r3, r3
 6607 0036 002B     		cmp	r3, #0
 6608 0038 80F28480 		bge	.L545
2811:../Sources/drivers/mcg/mcg.c ****         {
2812:../Sources/drivers/mcg/mcg.c ****             switch((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)    // determine multip
 6609              		.loc 1 2812 0
 6610 003c 4FF48043 		mov	r3, #16384
 6611 0040 C4F20603 		movt	r3, 16390
 6612 0044 DB78     		ldrb	r3, [r3, #3]
 6613 0046 DBB2     		uxtb	r3, r3
 6614 0048 03F06003 		and	r3, r3, #96
 6615 004c 4FEA5313 		lsr	r3, r3, #5
 6616 0050 032B     		cmp	r3, #3
 6617 0052 00F20E81 		bhi	.L560
 6618 0056 01A2     		adr	r2, .L551
 6619 0058 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 6620              		.align	2
 6621              	.L551:
 6622 005c 6D000000 		.word	.L547+1
 6623 0060 A3000000 		.word	.L548+1
 6624 0064 D9000000 		.word	.L549+1
 6625 0068 0F010000 		.word	.L550+1
 6626              	.L547:
2813:../Sources/drivers/mcg/mcg.c ****                 {
2814:../Sources/drivers/mcg/mcg.c ****                     case 0:
2815:../Sources/drivers/mcg/mcg.c ****                         fll_freq_hz = (fll_ref * 732);
 6627              		.loc 1 2815 0
 6628 006c 7B68     		ldr	r3, [r7, #4]
 6629 006e 4FF43772 		mov	r2, #732
 6630 0072 02FB03F3 		mul	r3, r2, r3
 6631 0076 FB60     		str	r3, [r7, #12]
2816:../Sources/drivers/mcg/mcg.c **** 
2817:../Sources/drivers/mcg/mcg.c ****                         if(fll_freq_hz < 20000000)
 6632              		.loc 1 2817 0
 6633 0078 FA68     		ldr	r2, [r7, #12]
 6634 007a 42F6FF43 		movw	r3, #11519
 6635 007e C0F23113 		movt	r3, 305
 6636 0082 9A42     		cmp	r2, r3
 6637 0084 02DC     		bgt	.L552
2818:../Sources/drivers/mcg/mcg.c ****                             {
2819:../Sources/drivers/mcg/mcg.c ****                                 return 0x33;
 6638              		.loc 1 2819 0
 6639 0086 4FF03303 		mov	r3, #51
 6640 008a F3E0     		b	.L544
 6641              	.L552:
2820:../Sources/drivers/mcg/mcg.c ****                             }
2821:../Sources/drivers/mcg/mcg.c ****                         else if(fll_freq_hz > 25000000)
 6642              		.loc 1 2821 0
 6643 008c FA68     		ldr	r2, [r7, #12]
 6644 008e 47F64003 		movw	r3, #30784
 6645 0092 C0F27D13 		movt	r3, 381
 6646 0096 9A42     		cmp	r2, r3
 6647 0098 40F3DC80 		ble	.L574
2822:../Sources/drivers/mcg/mcg.c ****                             {
2823:../Sources/drivers/mcg/mcg.c ****                                 return 0x34;
 6648              		.loc 1 2823 0
 6649 009c 4FF03403 		mov	r3, #52
 6650 00a0 E8E0     		b	.L544
 6651              	.L548:
2824:../Sources/drivers/mcg/mcg.c ****                             }
2825:../Sources/drivers/mcg/mcg.c **** 
2826:../Sources/drivers/mcg/mcg.c ****                         break;
2827:../Sources/drivers/mcg/mcg.c **** 
2828:../Sources/drivers/mcg/mcg.c ****                     case 1:
2829:../Sources/drivers/mcg/mcg.c ****                         fll_freq_hz = (fll_ref * 1464);
 6652              		.loc 1 2829 0
 6653 00a2 7B68     		ldr	r3, [r7, #4]
 6654 00a4 4FF4B762 		mov	r2, #1464
 6655 00a8 02FB03F3 		mul	r3, r2, r3
 6656 00ac FB60     		str	r3, [r7, #12]
2830:../Sources/drivers/mcg/mcg.c **** 
2831:../Sources/drivers/mcg/mcg.c ****                         if(fll_freq_hz < 40000000)
 6657              		.loc 1 2831 0
 6658 00ae FA68     		ldr	r2, [r7, #12]
 6659 00b0 45F6FF13 		movw	r3, #23039
 6660 00b4 C0F26223 		movt	r3, 610
 6661 00b8 9A42     		cmp	r2, r3
 6662 00ba 02DC     		bgt	.L554
2832:../Sources/drivers/mcg/mcg.c ****                             {
2833:../Sources/drivers/mcg/mcg.c ****                                 return 0x35;
 6663              		.loc 1 2833 0
 6664 00bc 4FF03503 		mov	r3, #53
 6665 00c0 D8E0     		b	.L544
 6666              	.L554:
2834:../Sources/drivers/mcg/mcg.c ****                             }
2835:../Sources/drivers/mcg/mcg.c ****                         else if(fll_freq_hz > 50000000)
 6667              		.loc 1 2835 0
 6668 00c2 FA68     		ldr	r2, [r7, #12]
 6669 00c4 4FF28003 		movw	r3, #61568
 6670 00c8 C0F2FA23 		movt	r3, 762
 6671 00cc 9A42     		cmp	r2, r3
 6672 00ce 40F3C380 		ble	.L575
2836:../Sources/drivers/mcg/mcg.c ****                             {
2837:../Sources/drivers/mcg/mcg.c ****                                 return 0x36;
 6673              		.loc 1 2837 0
 6674 00d2 4FF03603 		mov	r3, #54
 6675 00d6 CDE0     		b	.L544
 6676              	.L549:
2838:../Sources/drivers/mcg/mcg.c ****                             }
2839:../Sources/drivers/mcg/mcg.c **** 
2840:../Sources/drivers/mcg/mcg.c ****                         break;
2841:../Sources/drivers/mcg/mcg.c **** 
2842:../Sources/drivers/mcg/mcg.c ****                     case 2:
2843:../Sources/drivers/mcg/mcg.c ****                         fll_freq_hz = (fll_ref * 2197);
 6677              		.loc 1 2843 0
 6678 00d8 7B68     		ldr	r3, [r7, #4]
 6679 00da 40F69502 		movw	r2, #2197
 6680 00de 02FB03F3 		mul	r3, r2, r3
 6681 00e2 FB60     		str	r3, [r7, #12]
2844:../Sources/drivers/mcg/mcg.c **** 
2845:../Sources/drivers/mcg/mcg.c ****                         if(fll_freq_hz < 60000000)
 6682              		.loc 1 2845 0
 6683 00e4 FA68     		ldr	r2, [r7, #12]
 6684 00e6 48F2FF63 		movw	r3, #34559
 6685 00ea C0F29333 		movt	r3, 915
 6686 00ee 9A42     		cmp	r2, r3
 6687 00f0 02DC     		bgt	.L556
2846:../Sources/drivers/mcg/mcg.c ****                             {
2847:../Sources/drivers/mcg/mcg.c ****                                 return 0x37;
 6688              		.loc 1 2847 0
 6689 00f2 4FF03703 		mov	r3, #55
 6690 00f6 BDE0     		b	.L544
 6691              	.L556:
2848:../Sources/drivers/mcg/mcg.c ****                             }
2849:../Sources/drivers/mcg/mcg.c ****                         else if(fll_freq_hz > 75000000)
 6692              		.loc 1 2849 0
 6693 00f8 FA68     		ldr	r2, [r7, #12]
 6694 00fa 46F6C003 		movw	r3, #26816
 6695 00fe C0F27843 		movt	r3, 1144
 6696 0102 9A42     		cmp	r2, r3
 6697 0104 40F3AA80 		ble	.L576
2850:../Sources/drivers/mcg/mcg.c ****                             {
2851:../Sources/drivers/mcg/mcg.c ****                                 return 0x38;
 6698              		.loc 1 2851 0
 6699 0108 4FF03803 		mov	r3, #56
 6700 010c B2E0     		b	.L544
 6701              	.L550:
2852:../Sources/drivers/mcg/mcg.c ****                             }
2853:../Sources/drivers/mcg/mcg.c **** 
2854:../Sources/drivers/mcg/mcg.c ****                         break;
2855:../Sources/drivers/mcg/mcg.c **** 
2856:../Sources/drivers/mcg/mcg.c ****                     case 3:
2857:../Sources/drivers/mcg/mcg.c ****                         fll_freq_hz = (fll_ref * 2929);
 6702              		.loc 1 2857 0
 6703 010e 7B68     		ldr	r3, [r7, #4]
 6704 0110 40F67132 		movw	r2, #2929
 6705 0114 02FB03F3 		mul	r3, r2, r3
 6706 0118 FB60     		str	r3, [r7, #12]
2858:../Sources/drivers/mcg/mcg.c **** 
2859:../Sources/drivers/mcg/mcg.c ****                         if(fll_freq_hz < 80000000)
 6707              		.loc 1 2859 0
 6708 011a FA68     		ldr	r2, [r7, #12]
 6709 011c 4BF2FF33 		movw	r3, #46079
 6710 0120 C0F2C443 		movt	r3, 1220
 6711 0124 9A42     		cmp	r2, r3
 6712 0126 02DC     		bgt	.L558
2860:../Sources/drivers/mcg/mcg.c ****                             {
2861:../Sources/drivers/mcg/mcg.c ****                                 return 0x39;
 6713              		.loc 1 2861 0
 6714 0128 4FF03903 		mov	r3, #57
 6715 012c A2E0     		b	.L544
 6716              	.L558:
2862:../Sources/drivers/mcg/mcg.c ****                             }
2863:../Sources/drivers/mcg/mcg.c ****                         else if(fll_freq_hz > 100000000)
 6717              		.loc 1 2863 0
 6718 012e FA68     		ldr	r2, [r7, #12]
 6719 0130 4FF46143 		mov	r3, #57600
 6720 0134 C0F2F553 		movt	r3, 1525
 6721 0138 9A42     		cmp	r2, r3
 6722 013a 40F39180 		ble	.L577
2864:../Sources/drivers/mcg/mcg.c ****                             {
2865:../Sources/drivers/mcg/mcg.c ****                                 return 0x3A;
 6723              		.loc 1 2865 0
 6724 013e 4FF03A03 		mov	r3, #58
 6725 0142 97E0     		b	.L544
 6726              	.L545:
2866:../Sources/drivers/mcg/mcg.c ****                             }
2867:../Sources/drivers/mcg/mcg.c **** 
2868:../Sources/drivers/mcg/mcg.c ****                         break;
2869:../Sources/drivers/mcg/mcg.c ****                 }
2870:../Sources/drivers/mcg/mcg.c ****         }
2871:../Sources/drivers/mcg/mcg.c ****     else    // if DMX32 = 0
2872:../Sources/drivers/mcg/mcg.c ****         {
2873:../Sources/drivers/mcg/mcg.c ****             switch((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)    // determine multip
 6727              		.loc 1 2873 0
 6728 0144 4FF48043 		mov	r3, #16384
 6729 0148 C4F20603 		movt	r3, 16390
 6730 014c DB78     		ldrb	r3, [r3, #3]
 6731 014e DBB2     		uxtb	r3, r3
 6732 0150 03F06003 		and	r3, r3, #96
 6733 0154 4FEA5313 		lsr	r3, r3, #5
 6734 0158 032B     		cmp	r3, #3
 6735 015a 00F28A80 		bhi	.L560
 6736 015e 01A2     		adr	r2, .L565
 6737 0160 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 6738              		.align	2
 6739              	.L565:
 6740 0164 75010000 		.word	.L561+1
 6741 0168 AD010000 		.word	.L562+1
 6742 016c E5010000 		.word	.L563+1
 6743 0170 1D020000 		.word	.L564+1
 6744              	.L561:
2874:../Sources/drivers/mcg/mcg.c ****                 {
2875:../Sources/drivers/mcg/mcg.c ****                     case 0:
2876:../Sources/drivers/mcg/mcg.c ****                         fll_freq_hz = (fll_ref * 640);
 6745              		.loc 1 2876 0
 6746 0174 7A68     		ldr	r2, [r7, #4]
 6747 0176 1346     		mov	r3, r2
 6748 0178 4FEA8303 		lsl	r3, r3, #2
 6749 017c 9B18     		adds	r3, r3, r2
 6750 017e 4FEAC313 		lsl	r3, r3, #7
 6751 0182 FB60     		str	r3, [r7, #12]
2877:../Sources/drivers/mcg/mcg.c **** 
2878:../Sources/drivers/mcg/mcg.c ****                         if(fll_freq_hz < 20000000)
 6752              		.loc 1 2878 0
 6753 0184 FA68     		ldr	r2, [r7, #12]
 6754 0186 42F6FF43 		movw	r3, #11519
 6755 018a C0F23113 		movt	r3, 305
 6756 018e 9A42     		cmp	r2, r3
 6757 0190 02DC     		bgt	.L566
2879:../Sources/drivers/mcg/mcg.c ****                             {
2880:../Sources/drivers/mcg/mcg.c ****                                 return 0x33;
 6758              		.loc 1 2880 0
 6759 0192 4FF03303 		mov	r3, #51
 6760 0196 6DE0     		b	.L544
 6761              	.L566:
2881:../Sources/drivers/mcg/mcg.c ****                             }
2882:../Sources/drivers/mcg/mcg.c ****                         else if(fll_freq_hz > 25000000)
 6762              		.loc 1 2882 0
 6763 0198 FA68     		ldr	r2, [r7, #12]
 6764 019a 47F64003 		movw	r3, #30784
 6765 019e C0F27D13 		movt	r3, 381
 6766 01a2 9A42     		cmp	r2, r3
 6767 01a4 5EDD     		ble	.L578
2883:../Sources/drivers/mcg/mcg.c ****                             {
2884:../Sources/drivers/mcg/mcg.c ****                                 return 0x34;
 6768              		.loc 1 2884 0
 6769 01a6 4FF03403 		mov	r3, #52
 6770 01aa 63E0     		b	.L544
 6771              	.L562:
2885:../Sources/drivers/mcg/mcg.c ****                             }
2886:../Sources/drivers/mcg/mcg.c **** 
2887:../Sources/drivers/mcg/mcg.c ****                         break;
2888:../Sources/drivers/mcg/mcg.c **** 
2889:../Sources/drivers/mcg/mcg.c ****                     case 1:
2890:../Sources/drivers/mcg/mcg.c ****                         fll_freq_hz = (fll_ref * 1280);
 6772              		.loc 1 2890 0
 6773 01ac 7A68     		ldr	r2, [r7, #4]
 6774 01ae 1346     		mov	r3, r2
 6775 01b0 4FEA8303 		lsl	r3, r3, #2
 6776 01b4 9B18     		adds	r3, r3, r2
 6777 01b6 4FEA0323 		lsl	r3, r3, #8
 6778 01ba FB60     		str	r3, [r7, #12]
2891:../Sources/drivers/mcg/mcg.c **** 
2892:../Sources/drivers/mcg/mcg.c ****                         if(fll_freq_hz < 40000000)
 6779              		.loc 1 2892 0
 6780 01bc FA68     		ldr	r2, [r7, #12]
 6781 01be 45F6FF13 		movw	r3, #23039
 6782 01c2 C0F26223 		movt	r3, 610
 6783 01c6 9A42     		cmp	r2, r3
 6784 01c8 02DC     		bgt	.L568
2893:../Sources/drivers/mcg/mcg.c ****                             {
2894:../Sources/drivers/mcg/mcg.c ****                                 return 0x35;
 6785              		.loc 1 2894 0
 6786 01ca 4FF03503 		mov	r3, #53
 6787 01ce 51E0     		b	.L544
 6788              	.L568:
2895:../Sources/drivers/mcg/mcg.c ****                             }
2896:../Sources/drivers/mcg/mcg.c ****                         else if(fll_freq_hz > 50000000)
 6789              		.loc 1 2896 0
 6790 01d0 FA68     		ldr	r2, [r7, #12]
 6791 01d2 4FF28003 		movw	r3, #61568
 6792 01d6 C0F2FA23 		movt	r3, 762
 6793 01da 9A42     		cmp	r2, r3
 6794 01dc 44DD     		ble	.L579
2897:../Sources/drivers/mcg/mcg.c ****                             {
2898:../Sources/drivers/mcg/mcg.c ****                                 return 0x36;
 6795              		.loc 1 2898 0
 6796 01de 4FF03603 		mov	r3, #54
 6797 01e2 47E0     		b	.L544
 6798              	.L563:
2899:../Sources/drivers/mcg/mcg.c ****                             }
2900:../Sources/drivers/mcg/mcg.c **** 
2901:../Sources/drivers/mcg/mcg.c ****                         break;
2902:../Sources/drivers/mcg/mcg.c **** 
2903:../Sources/drivers/mcg/mcg.c ****                     case 2:
2904:../Sources/drivers/mcg/mcg.c ****                         fll_freq_hz = (fll_ref * 1920);
 6799              		.loc 1 2904 0
 6800 01e4 7A68     		ldr	r2, [r7, #4]
 6801 01e6 1346     		mov	r3, r2
 6802 01e8 4FEA0313 		lsl	r3, r3, #4
 6803 01ec 9B1A     		subs	r3, r3, r2
 6804 01ee 4FEAC313 		lsl	r3, r3, #7
 6805 01f2 FB60     		str	r3, [r7, #12]
2905:../Sources/drivers/mcg/mcg.c **** 
2906:../Sources/drivers/mcg/mcg.c ****                         if(fll_freq_hz < 60000000)
 6806              		.loc 1 2906 0
 6807 01f4 FA68     		ldr	r2, [r7, #12]
 6808 01f6 48F2FF63 		movw	r3, #34559
 6809 01fa C0F29333 		movt	r3, 915
 6810 01fe 9A42     		cmp	r2, r3
 6811 0200 02DC     		bgt	.L570
2907:../Sources/drivers/mcg/mcg.c ****                             {
2908:../Sources/drivers/mcg/mcg.c ****                                 return 0x37;
 6812              		.loc 1 2908 0
 6813 0202 4FF03703 		mov	r3, #55
 6814 0206 35E0     		b	.L544
 6815              	.L570:
2909:../Sources/drivers/mcg/mcg.c ****                             }
2910:../Sources/drivers/mcg/mcg.c ****                         else if(fll_freq_hz > 75000000)
 6816              		.loc 1 2910 0
 6817 0208 FA68     		ldr	r2, [r7, #12]
 6818 020a 46F6C003 		movw	r3, #26816
 6819 020e C0F27843 		movt	r3, 1144
 6820 0212 9A42     		cmp	r2, r3
 6821 0214 2ADD     		ble	.L580
2911:../Sources/drivers/mcg/mcg.c ****                             {
2912:../Sources/drivers/mcg/mcg.c ****                                 return 0x38;
 6822              		.loc 1 2912 0
 6823 0216 4FF03803 		mov	r3, #56
 6824 021a 2BE0     		b	.L544
 6825              	.L564:
2913:../Sources/drivers/mcg/mcg.c ****                             }
2914:../Sources/drivers/mcg/mcg.c **** 
2915:../Sources/drivers/mcg/mcg.c ****                         break;
2916:../Sources/drivers/mcg/mcg.c **** 
2917:../Sources/drivers/mcg/mcg.c ****                     case 3:
2918:../Sources/drivers/mcg/mcg.c ****                         fll_freq_hz = (fll_ref * 2560);
 6826              		.loc 1 2918 0
 6827 021c 7A68     		ldr	r2, [r7, #4]
 6828 021e 1346     		mov	r3, r2
 6829 0220 4FEA8303 		lsl	r3, r3, #2
 6830 0224 9B18     		adds	r3, r3, r2
 6831 0226 4FEA4323 		lsl	r3, r3, #9
 6832 022a FB60     		str	r3, [r7, #12]
2919:../Sources/drivers/mcg/mcg.c **** 
2920:../Sources/drivers/mcg/mcg.c ****                         if(fll_freq_hz < 80000000)
 6833              		.loc 1 2920 0
 6834 022c FA68     		ldr	r2, [r7, #12]
 6835 022e 4BF2FF33 		movw	r3, #46079
 6836 0232 C0F2C443 		movt	r3, 1220
 6837 0236 9A42     		cmp	r2, r3
 6838 0238 02DC     		bgt	.L572
2921:../Sources/drivers/mcg/mcg.c ****                             {
2922:../Sources/drivers/mcg/mcg.c ****                                 return 0x39;
 6839              		.loc 1 2922 0
 6840 023a 4FF03903 		mov	r3, #57
 6841 023e 19E0     		b	.L544
 6842              	.L572:
2923:../Sources/drivers/mcg/mcg.c ****                             }
2924:../Sources/drivers/mcg/mcg.c ****                         else if(fll_freq_hz > 100000000)
 6843              		.loc 1 2924 0
 6844 0240 FA68     		ldr	r2, [r7, #12]
 6845 0242 4FF46143 		mov	r3, #57600
 6846 0246 C0F2F553 		movt	r3, 1525
 6847 024a 9A42     		cmp	r2, r3
 6848 024c 10DD     		ble	.L581
2925:../Sources/drivers/mcg/mcg.c ****                             {
2926:../Sources/drivers/mcg/mcg.c ****                                 return 0x3A;
 6849              		.loc 1 2926 0
 6850 024e 4FF03A03 		mov	r3, #58
 6851 0252 0FE0     		b	.L544
 6852              	.L574:
2826:../Sources/drivers/mcg/mcg.c ****                         break;
 6853              		.loc 1 2826 0
 6854 0254 00BF     		nop
 6855 0256 0CE0     		b	.L560
 6856              	.L575:
2840:../Sources/drivers/mcg/mcg.c ****                         break;
 6857              		.loc 1 2840 0
 6858 0258 00BF     		nop
 6859 025a 0AE0     		b	.L560
 6860              	.L576:
2854:../Sources/drivers/mcg/mcg.c ****                         break;
 6861              		.loc 1 2854 0
 6862 025c 00BF     		nop
 6863 025e 08E0     		b	.L560
 6864              	.L577:
2868:../Sources/drivers/mcg/mcg.c ****                         break;
 6865              		.loc 1 2868 0
 6866 0260 00BF     		nop
 6867 0262 06E0     		b	.L560
 6868              	.L578:
2887:../Sources/drivers/mcg/mcg.c ****                         break;
 6869              		.loc 1 2887 0
 6870 0264 00BF     		nop
 6871 0266 04E0     		b	.L560
 6872              	.L579:
2901:../Sources/drivers/mcg/mcg.c ****                         break;
 6873              		.loc 1 2901 0
 6874 0268 00BF     		nop
 6875 026a 02E0     		b	.L560
 6876              	.L580:
2915:../Sources/drivers/mcg/mcg.c ****                         break;
 6877              		.loc 1 2915 0
 6878 026c 00BF     		nop
 6879 026e 00E0     		b	.L560
 6880              	.L581:
2927:../Sources/drivers/mcg/mcg.c ****                             }
2928:../Sources/drivers/mcg/mcg.c **** 
2929:../Sources/drivers/mcg/mcg.c ****                         break;
 6881              		.loc 1 2929 0
 6882 0270 00BF     		nop
 6883              	.L560:
2930:../Sources/drivers/mcg/mcg.c ****                 }
2931:../Sources/drivers/mcg/mcg.c ****         }
2932:../Sources/drivers/mcg/mcg.c **** 
2933:../Sources/drivers/mcg/mcg.c ****     return fll_freq_hz;
 6884              		.loc 1 2933 0
 6885 0272 FB68     		ldr	r3, [r7, #12]
 6886              	.L544:
2934:../Sources/drivers/mcg/mcg.c **** }   // fll_freq
 6887              		.loc 1 2934 0
 6888 0274 1846     		mov	r0, r3
 6889 0276 07F11407 		add	r7, r7, #20
 6890 027a BD46     		mov	sp, r7
 6891 027c 80BC     		pop	{r7}
 6892 027e 7047     		bx	lr
 6893              		.cfi_endproc
 6894              	.LFE25:
 6896              		.section	.text.what_mcg_mode,"ax",%progbits
 6897              		.align	2
 6898              		.global	what_mcg_mode
 6899              		.thumb
 6900              		.thumb_func
 6902              	what_mcg_mode:
 6903              	.LFB26:
2935:../Sources/drivers/mcg/mcg.c **** 
2936:../Sources/drivers/mcg/mcg.c **** /* */
2937:../Sources/drivers/mcg/mcg.c **** 
2938:../Sources/drivers/mcg/mcg.c **** unsigned char what_mcg_mode(void)
2939:../Sources/drivers/mcg/mcg.c **** {
 6904              		.loc 1 2939 0
 6905              		.cfi_startproc
 6906              		@ args = 0, pretend = 0, frame = 0
 6907              		@ frame_needed = 1, uses_anonymous_args = 0
 6908              		@ link register save eliminated.
 6909 0000 80B4     		push	{r7}
 6910              	.LCFI78:
 6911              		.cfi_def_cfa_offset 4
 6912              		.cfi_offset 7, -4
 6913 0002 00AF     		add	r7, sp, #0
 6914              	.LCFI79:
 6915              		.cfi_def_cfa_register 7
2940:../Sources/drivers/mcg/mcg.c ****     // check if in FEI mode
2941:../Sources/drivers/mcg/mcg.c ****     if
2942:../Sources/drivers/mcg/mcg.c ****     (
2943:../Sources/drivers/mcg/mcg.c ****         (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)  // check CLKS mux has selcted F
 6916              		.loc 1 2943 0
 6917 0004 4FF48043 		mov	r3, #16384
 6918 0008 C4F20603 		movt	r3, 16390
 6919 000c 9B79     		ldrb	r3, [r3, #6]
 6920 000e DBB2     		uxtb	r3, r3
 6921 0010 03F00C03 		and	r3, r3, #12
 6922 0014 4FEA9303 		lsr	r3, r3, #2
2942:../Sources/drivers/mcg/mcg.c ****     (
 6923              		.loc 1 2942 0
 6924 0018 002B     		cmp	r3, #0
 6925 001a 16D1     		bne	.L583
2944:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
 6926              		.loc 1 2944 0
 6927 001c 4FF48043 		mov	r3, #16384
 6928 0020 C4F20603 		movt	r3, 16390
 6929 0024 9B79     		ldrb	r3, [r3, #6]
 6930 0026 DBB2     		uxtb	r3, r3
 6931 0028 03F01003 		and	r3, r3, #16
 6932 002c 002B     		cmp	r3, #0
 6933 002e 0CD0     		beq	.L583
2945:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
 6934              		.loc 1 2945 0
 6935 0030 4FF48043 		mov	r3, #16384
 6936 0034 C4F20603 		movt	r3, 16390
 6937 0038 9B79     		ldrb	r3, [r3, #6]
 6938 003a DBB2     		uxtb	r3, r3
 6939 003c 03F02003 		and	r3, r3, #32
 6940 0040 002B     		cmp	r3, #0
 6941 0042 02D1     		bne	.L583
2946:../Sources/drivers/mcg/mcg.c ****     )               // check PLLS mux has selected FLL
2947:../Sources/drivers/mcg/mcg.c ****         {
2948:../Sources/drivers/mcg/mcg.c ****             return FEI; // return FEI code
 6942              		.loc 1 2948 0
 6943 0044 4FF00303 		mov	r3, #3
 6944 0048 1EE1     		b	.L584
 6945              	.L583:
2949:../Sources/drivers/mcg/mcg.c ****         }
2950:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PEE mode
2951:../Sources/drivers/mcg/mcg.c ****     else if
2952:../Sources/drivers/mcg/mcg.c ****     (
2953:../Sources/drivers/mcg/mcg.c ****         (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3)  // check CLKS mux has selcted P
 6946              		.loc 1 2953 0
 6947 004a 4FF48043 		mov	r3, #16384
 6948 004e C4F20603 		movt	r3, 16390
 6949 0052 9B79     		ldrb	r3, [r3, #6]
 6950 0054 DBB2     		uxtb	r3, r3
 6951 0056 03F00C03 		and	r3, r3, #12
 6952 005a 4FEA9303 		lsr	r3, r3, #2
2952:../Sources/drivers/mcg/mcg.c ****     (
 6953              		.loc 1 2952 0
 6954 005e 032B     		cmp	r3, #3
 6955 0060 16D1     		bne	.L585
2954:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 6956              		.loc 1 2954 0
 6957 0062 4FF48043 		mov	r3, #16384
 6958 0066 C4F20603 		movt	r3, 16390
 6959 006a 9B79     		ldrb	r3, [r3, #6]
 6960 006c DBB2     		uxtb	r3, r3
 6961 006e 03F01003 		and	r3, r3, #16
 6962 0072 002B     		cmp	r3, #0
 6963 0074 0CD1     		bne	.L585
2955:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)
 6964              		.loc 1 2955 0
 6965 0076 4FF48043 		mov	r3, #16384
 6966 007a C4F20603 		movt	r3, 16390
 6967 007e 9B79     		ldrb	r3, [r3, #6]
 6968 0080 DBB2     		uxtb	r3, r3
 6969 0082 03F02003 		and	r3, r3, #32
 6970 0086 002B     		cmp	r3, #0
 6971 0088 02D0     		beq	.L585
2956:../Sources/drivers/mcg/mcg.c ****     )           // check PLLS mux has selected PLL
2957:../Sources/drivers/mcg/mcg.c ****         {
2958:../Sources/drivers/mcg/mcg.c ****             return PEE; // return PEE code
 6972              		.loc 1 2958 0
 6973 008a 4FF00803 		mov	r3, #8
 6974 008e FBE0     		b	.L584
 6975              	.L585:
2959:../Sources/drivers/mcg/mcg.c ****         }
2960:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PBE mode
2961:../Sources/drivers/mcg/mcg.c ****     else if
2962:../Sources/drivers/mcg/mcg.c ****     (
2963:../Sources/drivers/mcg/mcg.c ****         (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)  // check CLKS mux has selcted e
 6976              		.loc 1 2963 0
 6977 0090 4FF48043 		mov	r3, #16384
 6978 0094 C4F20603 		movt	r3, 16390
 6979 0098 9B79     		ldrb	r3, [r3, #6]
 6980 009a DBB2     		uxtb	r3, r3
 6981 009c 03F00C03 		and	r3, r3, #12
 6982 00a0 4FEA9303 		lsr	r3, r3, #2
2962:../Sources/drivers/mcg/mcg.c ****     (
 6983              		.loc 1 2962 0
 6984 00a4 022B     		cmp	r3, #2
 6985 00a6 20D1     		bne	.L586
2964:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 6986              		.loc 1 2964 0
 6987 00a8 4FF48043 		mov	r3, #16384
 6988 00ac C4F20603 		movt	r3, 16390
 6989 00b0 9B79     		ldrb	r3, [r3, #6]
 6990 00b2 DBB2     		uxtb	r3, r3
 6991 00b4 03F01003 		and	r3, r3, #16
 6992 00b8 002B     		cmp	r3, #0
 6993 00ba 16D1     		bne	.L586
2965:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 6994              		.loc 1 2965 0
 6995 00bc 4FF48043 		mov	r3, #16384
 6996 00c0 C4F20603 		movt	r3, 16390
 6997 00c4 9B79     		ldrb	r3, [r3, #6]
 6998 00c6 DBB2     		uxtb	r3, r3
 6999 00c8 03F02003 		and	r3, r3, #32
 7000 00cc 002B     		cmp	r3, #0
 7001 00ce 0CD0     		beq	.L586
2966:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 7002              		.loc 1 2966 0
 7003 00d0 4FF48043 		mov	r3, #16384
 7004 00d4 C4F20603 		movt	r3, 16390
 7005 00d8 5B78     		ldrb	r3, [r3, #1]
 7006 00da DBB2     		uxtb	r3, r3
 7007 00dc 03F00203 		and	r3, r3, #2
 7008 00e0 002B     		cmp	r3, #0
 7009 00e2 02D1     		bne	.L586
2967:../Sources/drivers/mcg/mcg.c ****     )           // check MCG_C2[LP] bit is not set
2968:../Sources/drivers/mcg/mcg.c ****         {
2969:../Sources/drivers/mcg/mcg.c ****             return PBE; // return PBE code
 7010              		.loc 1 2969 0
 7011 00e4 4FF00703 		mov	r3, #7
 7012 00e8 CEE0     		b	.L584
 7013              	.L586:
2970:../Sources/drivers/mcg/mcg.c ****         }
2971:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
2972:../Sources/drivers/mcg/mcg.c ****     else if
2973:../Sources/drivers/mcg/mcg.c ****     (
2974:../Sources/drivers/mcg/mcg.c ****         (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)  // check CLKS mux has selcted e
 7014              		.loc 1 2974 0
 7015 00ea 4FF48043 		mov	r3, #16384
 7016 00ee C4F20603 		movt	r3, 16390
 7017 00f2 9B79     		ldrb	r3, [r3, #6]
 7018 00f4 DBB2     		uxtb	r3, r3
 7019 00f6 03F00C03 		and	r3, r3, #12
 7020 00fa 4FEA9303 		lsr	r3, r3, #2
2973:../Sources/drivers/mcg/mcg.c ****     (
 7021              		.loc 1 2973 0
 7022 00fe 022B     		cmp	r3, #2
 7023 0100 20D1     		bne	.L587
2975:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 7024              		.loc 1 2975 0
 7025 0102 4FF48043 		mov	r3, #16384
 7026 0106 C4F20603 		movt	r3, 16390
 7027 010a 9B79     		ldrb	r3, [r3, #6]
 7028 010c DBB2     		uxtb	r3, r3
 7029 010e 03F01003 		and	r3, r3, #16
 7030 0112 002B     		cmp	r3, #0
 7031 0114 16D1     		bne	.L587
2976:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 7032              		.loc 1 2976 0
 7033 0116 4FF48043 		mov	r3, #16384
 7034 011a C4F20603 		movt	r3, 16390
 7035 011e 9B79     		ldrb	r3, [r3, #6]
 7036 0120 DBB2     		uxtb	r3, r3
 7037 0122 03F02003 		and	r3, r3, #32
 7038 0126 002B     		cmp	r3, #0
 7039 0128 0CD1     		bne	.L587
2977:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 7040              		.loc 1 2977 0
 7041 012a 4FF48043 		mov	r3, #16384
 7042 012e C4F20603 		movt	r3, 16390
 7043 0132 5B78     		ldrb	r3, [r3, #1]
 7044 0134 DBB2     		uxtb	r3, r3
 7045 0136 03F00203 		and	r3, r3, #2
 7046 013a 002B     		cmp	r3, #0
 7047 013c 02D1     		bne	.L587
2978:../Sources/drivers/mcg/mcg.c ****     )           // check MCG_C2[LP] bit is not set
2979:../Sources/drivers/mcg/mcg.c ****         {
2980:../Sources/drivers/mcg/mcg.c ****             return FBE; // return FBE code
 7048              		.loc 1 2980 0
 7049 013e 4FF00503 		mov	r3, #5
 7050 0142 A1E0     		b	.L584
 7051              	.L587:
2981:../Sources/drivers/mcg/mcg.c ****         }
2982:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in BLPE mode
2983:../Sources/drivers/mcg/mcg.c ****     else if
2984:../Sources/drivers/mcg/mcg.c ****     (
2985:../Sources/drivers/mcg/mcg.c ****         (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)  // check CLKS mux has selcted e
 7052              		.loc 1 2985 0
 7053 0144 4FF48043 		mov	r3, #16384
 7054 0148 C4F20603 		movt	r3, 16390
 7055 014c 9B79     		ldrb	r3, [r3, #6]
 7056 014e DBB2     		uxtb	r3, r3
 7057 0150 03F00C03 		and	r3, r3, #12
 7058 0154 4FEA9303 		lsr	r3, r3, #2
2984:../Sources/drivers/mcg/mcg.c ****     (
 7059              		.loc 1 2984 0
 7060 0158 022B     		cmp	r3, #2
 7061 015a 16D1     		bne	.L588
2986:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 7062              		.loc 1 2986 0
 7063 015c 4FF48043 		mov	r3, #16384
 7064 0160 C4F20603 		movt	r3, 16390
 7065 0164 9B79     		ldrb	r3, [r3, #6]
 7066 0166 DBB2     		uxtb	r3, r3
 7067 0168 03F01003 		and	r3, r3, #16
 7068 016c 002B     		cmp	r3, #0
 7069 016e 0CD1     		bne	.L588
2987:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
 7070              		.loc 1 2987 0
 7071 0170 4FF48043 		mov	r3, #16384
 7072 0174 C4F20603 		movt	r3, 16390
 7073 0178 5B78     		ldrb	r3, [r3, #1]
 7074 017a DBB2     		uxtb	r3, r3
 7075 017c 03F00203 		and	r3, r3, #2
 7076 0180 002B     		cmp	r3, #0
 7077 0182 02D0     		beq	.L588
2988:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is set
2989:../Sources/drivers/mcg/mcg.c ****         {
2990:../Sources/drivers/mcg/mcg.c ****             return BLPE;    // return BLPE code
 7078              		.loc 1 2990 0
 7079 0184 4FF00603 		mov	r3, #6
 7080 0188 7EE0     		b	.L584
 7081              	.L588:
2991:../Sources/drivers/mcg/mcg.c ****         }
2992:../Sources/drivers/mcg/mcg.c ****     // check if in BLPI mode
2993:../Sources/drivers/mcg/mcg.c ****     else if
2994:../Sources/drivers/mcg/mcg.c ****     (
2995:../Sources/drivers/mcg/mcg.c ****         (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)  // check CLKS mux has selcted i
 7082              		.loc 1 2995 0
 7083 018a 4FF48043 		mov	r3, #16384
 7084 018e C4F20603 		movt	r3, 16390
 7085 0192 9B79     		ldrb	r3, [r3, #6]
 7086 0194 DBB2     		uxtb	r3, r3
 7087 0196 03F00C03 		and	r3, r3, #12
 7088 019a 4FEA9303 		lsr	r3, r3, #2
2994:../Sources/drivers/mcg/mcg.c ****     (
 7089              		.loc 1 2994 0
 7090 019e 012B     		cmp	r3, #1
 7091 01a0 20D1     		bne	.L589
2996:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 7092              		.loc 1 2996 0
 7093 01a2 4FF48043 		mov	r3, #16384
 7094 01a6 C4F20603 		movt	r3, 16390
 7095 01aa 9B79     		ldrb	r3, [r3, #6]
 7096 01ac DBB2     		uxtb	r3, r3
 7097 01ae 03F01003 		and	r3, r3, #16
 7098 01b2 002B     		cmp	r3, #0
 7099 01b4 16D0     		beq	.L589
2997:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 7100              		.loc 1 2997 0
 7101 01b6 4FF48043 		mov	r3, #16384
 7102 01ba C4F20603 		movt	r3, 16390
 7103 01be 9B79     		ldrb	r3, [r3, #6]
 7104 01c0 DBB2     		uxtb	r3, r3
 7105 01c2 03F02003 		and	r3, r3, #32
 7106 01c6 002B     		cmp	r3, #0
 7107 01c8 0CD1     		bne	.L589
2998:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
 7108              		.loc 1 2998 0
 7109 01ca 4FF48043 		mov	r3, #16384
 7110 01ce C4F20603 		movt	r3, 16390
 7111 01d2 5B78     		ldrb	r3, [r3, #1]
 7112 01d4 DBB2     		uxtb	r3, r3
 7113 01d6 03F00203 		and	r3, r3, #2
 7114 01da 002B     		cmp	r3, #0
 7115 01dc 02D0     		beq	.L589
2999:../Sources/drivers/mcg/mcg.c ****     )               // check LP bit is set
3000:../Sources/drivers/mcg/mcg.c ****         {
3001:../Sources/drivers/mcg/mcg.c ****             return BLPI;    // return BLPI code
 7116              		.loc 1 3001 0
 7117 01de 4FF00103 		mov	r3, #1
 7118 01e2 51E0     		b	.L584
 7119              	.L589:
3002:../Sources/drivers/mcg/mcg.c ****         }
3003:../Sources/drivers/mcg/mcg.c ****     // check if in FBI mode
3004:../Sources/drivers/mcg/mcg.c ****     else if
3005:../Sources/drivers/mcg/mcg.c ****     (
3006:../Sources/drivers/mcg/mcg.c ****         (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)  // check CLKS mux has selcted i
 7120              		.loc 1 3006 0
 7121 01e4 4FF48043 		mov	r3, #16384
 7122 01e8 C4F20603 		movt	r3, 16390
 7123 01ec 9B79     		ldrb	r3, [r3, #6]
 7124 01ee DBB2     		uxtb	r3, r3
 7125 01f0 03F00C03 		and	r3, r3, #12
 7126 01f4 4FEA9303 		lsr	r3, r3, #2
3005:../Sources/drivers/mcg/mcg.c ****     (
 7127              		.loc 1 3005 0
 7128 01f8 012B     		cmp	r3, #1
 7129 01fa 20D1     		bne	.L590
3007:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 7130              		.loc 1 3007 0
 7131 01fc 4FF48043 		mov	r3, #16384
 7132 0200 C4F20603 		movt	r3, 16390
 7133 0204 9B79     		ldrb	r3, [r3, #6]
 7134 0206 DBB2     		uxtb	r3, r3
 7135 0208 03F01003 		and	r3, r3, #16
 7136 020c 002B     		cmp	r3, #0
 7137 020e 16D0     		beq	.L590
3008:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 7138              		.loc 1 3008 0
 7139 0210 4FF48043 		mov	r3, #16384
 7140 0214 C4F20603 		movt	r3, 16390
 7141 0218 9B79     		ldrb	r3, [r3, #6]
 7142 021a DBB2     		uxtb	r3, r3
 7143 021c 03F02003 		and	r3, r3, #32
 7144 0220 002B     		cmp	r3, #0
 7145 0222 0CD1     		bne	.L590
3009:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 7146              		.loc 1 3009 0
 7147 0224 4FF48043 		mov	r3, #16384
 7148 0228 C4F20603 		movt	r3, 16390
 7149 022c 5B78     		ldrb	r3, [r3, #1]
 7150 022e DBB2     		uxtb	r3, r3
 7151 0230 03F00203 		and	r3, r3, #2
 7152 0234 002B     		cmp	r3, #0
 7153 0236 02D1     		bne	.L590
3010:../Sources/drivers/mcg/mcg.c ****     )           // check LP bit is clear
3011:../Sources/drivers/mcg/mcg.c ****         {
3012:../Sources/drivers/mcg/mcg.c ****             return FBI; // return FBI code
 7154              		.loc 1 3012 0
 7155 0238 4FF00203 		mov	r3, #2
 7156 023c 24E0     		b	.L584
 7157              	.L590:
3013:../Sources/drivers/mcg/mcg.c ****         }
3014:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FEE mode
3015:../Sources/drivers/mcg/mcg.c ****     else if
3016:../Sources/drivers/mcg/mcg.c ****     (
3017:../Sources/drivers/mcg/mcg.c ****         (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)  // check CLKS mux has selcted F
 7158              		.loc 1 3017 0
 7159 023e 4FF48043 		mov	r3, #16384
 7160 0242 C4F20603 		movt	r3, 16390
 7161 0246 9B79     		ldrb	r3, [r3, #6]
 7162 0248 DBB2     		uxtb	r3, r3
 7163 024a 03F00C03 		and	r3, r3, #12
 7164 024e 4FEA9303 		lsr	r3, r3, #2
3016:../Sources/drivers/mcg/mcg.c ****     (
 7165              		.loc 1 3016 0
 7166 0252 002B     		cmp	r3, #0
 7167 0254 16D1     		bne	.L591
3018:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 7168              		.loc 1 3018 0
 7169 0256 4FF48043 		mov	r3, #16384
 7170 025a C4F20603 		movt	r3, 16390
 7171 025e 9B79     		ldrb	r3, [r3, #6]
 7172 0260 DBB2     		uxtb	r3, r3
 7173 0262 03F01003 		and	r3, r3, #16
 7174 0266 002B     		cmp	r3, #0
 7175 0268 0CD1     		bne	.L591
3019:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
 7176              		.loc 1 3019 0
 7177 026a 4FF48043 		mov	r3, #16384
 7178 026e C4F20603 		movt	r3, 16390
 7179 0272 9B79     		ldrb	r3, [r3, #6]
 7180 0274 DBB2     		uxtb	r3, r3
 7181 0276 03F02003 		and	r3, r3, #32
 7182 027a 002B     		cmp	r3, #0
 7183 027c 02D1     		bne	.L591
3020:../Sources/drivers/mcg/mcg.c ****     )           // check PLLS mux has selected FLL
3021:../Sources/drivers/mcg/mcg.c ****         {
3022:../Sources/drivers/mcg/mcg.c ****             return FEE; // return FEE code
 7184              		.loc 1 3022 0
 7185 027e 4FF00403 		mov	r3, #4
 7186 0282 01E0     		b	.L584
 7187              	.L591:
3023:../Sources/drivers/mcg/mcg.c ****         }
3024:../Sources/drivers/mcg/mcg.c ****     else
3025:../Sources/drivers/mcg/mcg.c ****         {
3026:../Sources/drivers/mcg/mcg.c ****             return 0;   // error condition
 7188              		.loc 1 3026 0
 7189 0284 4FF00003 		mov	r3, #0
 7190              	.L584:
3027:../Sources/drivers/mcg/mcg.c ****         }
3028:../Sources/drivers/mcg/mcg.c **** }                   // what_mcg_mode
 7191              		.loc 1 3028 0
 7192 0288 1846     		mov	r0, r3
 7193 028a BD46     		mov	sp, r7
 7194 028c 80BC     		pop	{r7}
 7195 028e 7047     		bx	lr
 7196              		.cfi_endproc
 7197              	.LFE26:
 7199              		.section	.text.clk_monitor_0,"ax",%progbits
 7200              		.align	2
 7201              		.global	clk_monitor_0
 7202              		.thumb
 7203              		.thumb_func
 7205              	clk_monitor_0:
 7206              	.LFB27:
3029:../Sources/drivers/mcg/mcg.c **** 
3030:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
3031:../Sources/drivers/mcg/mcg.c **** 
3032:../Sources/drivers/mcg/mcg.c **** /* Functon name : clk_monitor_0
3033:../Sources/drivers/mcg/mcg.c ****  *
3034:../Sources/drivers/mcg/mcg.c ****  * This function simply enables or disables the OSC 0 clock monitor. This is
3035:../Sources/drivers/mcg/mcg.c ****  * achieved by setting or clearing the MCG_C6[CME] bit. It is recommended to
3036:../Sources/drivers/mcg/mcg.c ****  * enable this monitor in external clock modes (FEE, FBE, BLPE, PBE and PEE.
3037:../Sources/drivers/mcg/mcg.c ****  * It MUST be disabled in all other modes or a reset may be generated. It must
3038:../Sources/drivers/mcg/mcg.c ****  * also be disabled if it is desired to enter VLPR from BLPE mode.
3039:../Sources/drivers/mcg/mcg.c ****  *
3040:../Sources/drivers/mcg/mcg.c ****  * Parameters: en_dis - enables (= 1) or disables (= 0) the OSC 0 clock monitor
3041:../Sources/drivers/mcg/mcg.c ****  *
3042:../Sources/drivers/mcg/mcg.c ****  * Return value : none
3043:../Sources/drivers/mcg/mcg.c ****  */
3044:../Sources/drivers/mcg/mcg.c **** 
3045:../Sources/drivers/mcg/mcg.c **** void clk_monitor_0
3046:../Sources/drivers/mcg/mcg.c **** (unsigned char   en_dis)
3047:../Sources/drivers/mcg/mcg.c **** {
 7207              		.loc 1 3047 0
 7208              		.cfi_startproc
 7209              		@ args = 0, pretend = 0, frame = 8
 7210              		@ frame_needed = 1, uses_anonymous_args = 0
 7211              		@ link register save eliminated.
 7212 0000 80B4     		push	{r7}
 7213              	.LCFI80:
 7214              		.cfi_def_cfa_offset 4
 7215              		.cfi_offset 7, -4
 7216 0002 83B0     		sub	sp, sp, #12
 7217              	.LCFI81:
 7218              		.cfi_def_cfa_offset 16
 7219 0004 00AF     		add	r7, sp, #0
 7220              	.LCFI82:
 7221              		.cfi_def_cfa_register 7
 7222 0006 0346     		mov	r3, r0
 7223 0008 FB71     		strb	r3, [r7, #7]
3048:../Sources/drivers/mcg/mcg.c ****     if(en_dis)
 7224              		.loc 1 3048 0
 7225 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 7226 000c 002B     		cmp	r3, #0
 7227 000e 0ED0     		beq	.L593
3049:../Sources/drivers/mcg/mcg.c ****         {
3050:../Sources/drivers/mcg/mcg.c ****             MCG_C6 |= MCG_C6_CME0_MASK;
 7228              		.loc 1 3050 0
 7229 0010 4FF48043 		mov	r3, #16384
 7230 0014 C4F20603 		movt	r3, 16390
 7231 0018 4FF48042 		mov	r2, #16384
 7232 001c C4F20602 		movt	r2, 16390
 7233 0020 5279     		ldrb	r2, [r2, #5]
 7234 0022 D2B2     		uxtb	r2, r2
 7235 0024 42F02002 		orr	r2, r2, #32
 7236 0028 D2B2     		uxtb	r2, r2
 7237 002a 5A71     		strb	r2, [r3, #5]
 7238 002c 0DE0     		b	.L592
 7239              	.L593:
3051:../Sources/drivers/mcg/mcg.c ****         }
3052:../Sources/drivers/mcg/mcg.c ****     else
3053:../Sources/drivers/mcg/mcg.c ****         {
3054:../Sources/drivers/mcg/mcg.c ****             MCG_C6 &= ~MCG_C6_CME0_MASK;
 7240              		.loc 1 3054 0
 7241 002e 4FF48043 		mov	r3, #16384
 7242 0032 C4F20603 		movt	r3, 16390
 7243 0036 4FF48042 		mov	r2, #16384
 7244 003a C4F20602 		movt	r2, 16390
 7245 003e 5279     		ldrb	r2, [r2, #5]
 7246 0040 D2B2     		uxtb	r2, r2
 7247 0042 22F02002 		bic	r2, r2, #32
 7248 0046 D2B2     		uxtb	r2, r2
 7249 0048 5A71     		strb	r2, [r3, #5]
 7250              	.L592:
3055:../Sources/drivers/mcg/mcg.c ****         }
3056:../Sources/drivers/mcg/mcg.c **** }   // end clk_monitor_0
 7251              		.loc 1 3056 0
 7252 004a 07F10C07 		add	r7, r7, #12
 7253 004e BD46     		mov	sp, r7
 7254 0050 80BC     		pop	{r7}
 7255 0052 7047     		bx	lr
 7256              		.cfi_endproc
 7257              	.LFE27:
 7259              		.text
 7260              	.Letext0:
 7261              		.file 2 "C:/Freescale/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 7262              		.file 3 "C:/Users/emh203/Documents/GitHub/MonkeyJam/MonkeyJam/Project_Headers/MK20D5.h"
DEFINED SYMBOLS
                            *ABS*:00000000 mcg.c
                            *COM*:00000001 drs_val
                            *COM*:00000001 dmx32_val
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:21     .text.pll_init:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:26     .text.pll_init:00000000 pll_init
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:683    .text.new_pll_freq:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:688    .text.new_pll_freq:00000000 new_pll_freq
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1085   .text.pee_pbe:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1090   .text.pee_pbe:00000000 pee_pbe
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1206   .text.pbe_pee:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1211   .text.pbe_pee:00000000 pbe_pee
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1398   .text.pbe_fbe:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1403   .text.pbe_fbe:00000000 pbe_fbe
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1525   .text.fbe_pbe:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1530   .text.fbe_pbe:00000000 fbe_pbe
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1806   .text.pbe_blpe:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1811   .text.pbe_blpe:00000000 pbe_blpe
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1892   .text.blpe_pbe:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:1897   .text.blpe_pbe:00000000 blpe_pbe
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:2151   .text.blpe_fbe:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:2156   .text.blpe_fbe:00000000 blpe_fbe
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:2280   .text.fbe_blpe:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:2285   .text.fbe_blpe:00000000 fbe_blpe
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:2366   .text.fbe_fei:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:2371   .text.fbe_fei:00000000 fbe_fei
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6569   .text.fll_freq:00000000 fll_freq
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:2580   .text.fei_fbe:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:2585   .text.fei_fbe:00000000 fei_fbe
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:2994   .text.fbe_fee:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:2999   .text.fbe_fee:00000000 fbe_fee
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:3171   .text.fee_fbe:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:3176   .text.fee_fbe:00000000 fee_fbe
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:3292   .text.fbe_fbi:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:3297   .text.fbe_fbi:00000000 fbe_fbi
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:3651   .text.fbi_fbe:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:3656   .text.fbi_fbe:00000000 fbi_fbe
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:4073   .text.fbi_blpi:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:4078   .text.fbi_blpi:00000000 fbi_blpi
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:4181   .text.blpi_fbi:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:4186   .text.blpi_fbi:00000000 blpi_fbi
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:4289   .text.fbi_fee:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:4294   .text.fbi_fee:00000000 fbi_fee
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:4746   .text.fee_fbi:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:4751   .text.fee_fbi:00000000 fee_fbi
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:5089   .text.fbi_fei:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:5094   .text.fbi_fei:00000000 fbi_fei
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:5293   .text.fei_fbi:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:5298   .text.fei_fbi:00000000 fei_fbi
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:5593   .text.fei_fee:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:5598   .text.fei_fee:00000000 fei_fee
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6000   .text.fee_fei:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6005   .text.fee_fei:00000000 fee_fei
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6159   .text.atc:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6164   .text.atc:00000000 atc
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6902   .text.what_mcg_mode:00000000 what_mcg_mode
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6564   .text.fll_freq:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6622   .text.fll_freq:0000005c $d
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6628   .text.fll_freq:0000006c $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6740   .text.fll_freq:00000164 $d
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6746   .text.fll_freq:00000174 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:6897   .text.what_mcg_mode:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:7200   .text.clk_monitor_0:00000000 $t
C:\Users\emh203\AppData\Local\Temp\cc9OVZYR.s:7205   .text.clk_monitor_0:00000000 clk_monitor_0
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_i2f
__aeabi_fdiv
__aeabi_fmul
__aeabi_f2uiz
