   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"mcg.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.pll_init,"ax",%progbits
  19              		.align	2
  20              		.global	pll_init
  21              		.thumb
  22              		.thumb_func
  24              	pll_init:
  25              	.LFB0:
  26              		.file 1 "../Sources/drivers/mcg/mcg.c"
   1:../Sources/drivers/mcg/mcg.c **** /*
   2:../Sources/drivers/mcg/mcg.c ****  * File:    mcg.c
   3:../Sources/drivers/mcg/mcg.c ****  *
   4:../Sources/drivers/mcg/mcg.c ****  * MCG drivers for Freescale Kinetis L - series devices
   5:../Sources/drivers/mcg/mcg.c ****  * Notes:
   6:../Sources/drivers/mcg/mcg.c ****  * Assumes the MCG mode is in the default FEI mode out of reset
   7:../Sources/drivers/mcg/mcg.c ****  */
   8:../Sources/drivers/mcg/mcg.c **** 
   9:../Sources/drivers/mcg/mcg.c **** #include "derivative.h"
  10:../Sources/drivers/mcg/mcg.c **** #include "mcg.h"
  11:../Sources/drivers/mcg/mcg.c **** 
  12:../Sources/drivers/mcg/mcg.c **** // global variables
  13:../Sources/drivers/mcg/mcg.c **** 
  14:../Sources/drivers/mcg/mcg.c **** extern int      core_clk_khz;
  15:../Sources/drivers/mcg/mcg.c **** 
  16:../Sources/drivers/mcg/mcg.c **** char            drs_val, dmx32_val;
  17:../Sources/drivers/mcg/mcg.c **** 
  18:../Sources/drivers/mcg/mcg.c **** // prototypes
  19:../Sources/drivers/mcg/mcg.c **** 
  20:../Sources/drivers/mcg/mcg.c **** void            rtc_as_refclk(void);
  21:../Sources/drivers/mcg/mcg.c **** int             fee_fei(int slow_irc_freq);
  22:../Sources/drivers/mcg/mcg.c **** int             fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  23:../Sources/drivers/mcg/mcg.c **** int             fbe_fei(int slow_irc_freq);
  24:../Sources/drivers/mcg/mcg.c **** int             fei_fbi(int irc_freq, unsigned char irc_select);
  25:../Sources/drivers/mcg/mcg.c **** int             fbi_fei(int slow_irc_freq);
  26:../Sources/drivers/mcg/mcg.c **** int             fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  27:../Sources/drivers/mcg/mcg.c **** int             pbe_pee(int crystal_val);
  28:../Sources/drivers/mcg/mcg.c **** int             pee_pbe(int crystal_val);
  29:../Sources/drivers/mcg/mcg.c **** int             pbe_fbe(int crystal_val);
  30:../Sources/drivers/mcg/mcg.c **** int             fbe_fbi(int irc_freq, unsigned char irc_select);
  31:../Sources/drivers/mcg/mcg.c **** int             fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  32:../Sources/drivers/mcg/mcg.c **** int             fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  33:../Sources/drivers/mcg/mcg.c **** int             fbe_fee(int crystal_val);
  34:../Sources/drivers/mcg/mcg.c **** int             fee_fbe(int crystal_val);
  35:../Sources/drivers/mcg/mcg.c **** int             pbe_blpe(int crystal_val);
  36:../Sources/drivers/mcg/mcg.c **** int             blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  37:../Sources/drivers/mcg/mcg.c **** int             blpe_fbe(int crystal_val);
  38:../Sources/drivers/mcg/mcg.c **** int             fbi_blpi(int irc_freq, unsigned char irc_select);
  39:../Sources/drivers/mcg/mcg.c **** int             blpi_fbi(int irc_freq, unsigned char irc_select);
  40:../Sources/drivers/mcg/mcg.c **** int             fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  41:../Sources/drivers/mcg/mcg.c **** int             fee_fbi(int irc_freq, unsigned char irc_select);
  42:../Sources/drivers/mcg/mcg.c **** int             fbe_blpe(int crystal_val);
  43:../Sources/drivers/mcg/mcg.c **** 
  44:../Sources/drivers/mcg/mcg.c **** int             new_pll_freq(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  45:../Sources/drivers/mcg/mcg.c **** 
  46:../Sources/drivers/mcg/mcg.c **** int             fll_freq(int fll_ref);
  47:../Sources/drivers/mcg/mcg.c **** unsigned char   what_mcg_mode(void);
  48:../Sources/drivers/mcg/mcg.c **** unsigned char   atc(unsigned char irc_select, int irc_freq, int mcg_out_freq);
  49:../Sources/drivers/mcg/mcg.c **** void            clk_monitor_0(unsigned char en_dis);
  50:../Sources/drivers/mcg/mcg.c **** unsigned char   chk_for_resistor(void);
  51:../Sources/drivers/mcg/mcg.c **** 
  52:../Sources/drivers/mcg/mcg.c **** /*********************************************************************************************/
  53:../Sources/drivers/mcg/mcg.c **** 
  54:../Sources/drivers/mcg/mcg.c **** /* Functon name : pll_init
  55:../Sources/drivers/mcg/mcg.c ****  *
  56:../Sources/drivers/mcg/mcg.c ****  * Mode transition: Option to move from FEI to PEE mode or to just initialize the PLL
  57:../Sources/drivers/mcg/mcg.c ****  *
  58:../Sources/drivers/mcg/mcg.c ****  * This function initializess PLL0. Either OSC0 is selected for the
  59:../Sources/drivers/mcg/mcg.c ****  * reference clock source. The oscillators can be configured to use a crystal or take in an
  60:../Sources/drivers/mcg/mcg.c ****  * external square wave clock.
  61:../Sources/drivers/mcg/mcg.c ****  * Using the function parameter names the PLL frequency is calculated as follows:
  62:../Sources/drivers/mcg/mcg.c ****  * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
  63:../Sources/drivers/mcg/mcg.c ****  * Refer to the readme file in the mcg driver directory for examples of pll_init configurations.
  64:../Sources/drivers/mcg/mcg.c ****  * All parameters must be provided, for example crystal_val must be provided even if the
  65:../Sources/drivers/mcg/mcg.c ****  * oscillator associated with that parameter is already initialized.
  66:../Sources/drivers/mcg/mcg.c ****  * The various passed parameters are checked to ensure they are within the allowed range. If any
  67:../Sources/drivers/mcg/mcg.c ****  * of these checks fail the driver will exit and return a fail/error code. An error code will
  68:../Sources/drivers/mcg/mcg.c ****  * also be returned if any error occurs during the PLL initialization sequence. Refer to the
  69:../Sources/drivers/mcg/mcg.c ****  * readme file in the mcg driver directory for a list of all these codes.
  70:../Sources/drivers/mcg/mcg.c ****  *
  71:../Sources/drivers/mcg/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
  72:../Sources/drivers/mcg/mcg.c ****  *                           wave clock source
  73:../Sources/drivers/mcg/mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
  74:../Sources/drivers/mcg/mcg.c ****  *                           for the crystal oscillator. This has no meaning if an
  75:../Sources/drivers/mcg/mcg.c ****  *                           external clock is used.
  76:../Sources/drivers/mcg/mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
  77:../Sources/drivers/mcg/mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
  78:../Sources/drivers/mcg/mcg.c ****  *                           PLL reference clock frequency
  79:../Sources/drivers/mcg/mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
  80:../Sources/drivers/mcg/mcg.c ****  *             mcgout_select  - 0 if the PLL is just to be enabled, non-zero if the PLL is used
  81:../Sources/drivers/mcg/mcg.c ****  *                              to provide the MCGOUT clock for the system.
  82:../Sources/drivers/mcg/mcg.c ****  *
  83:../Sources/drivers/mcg/mcg.c ****  * Return value : PLL frequency (Hz) or error code
  84:../Sources/drivers/mcg/mcg.c ****  */
  85:../Sources/drivers/mcg/mcg.c **** 
  86:../Sources/drivers/mcg/mcg.c **** int pll_init
  87:../Sources/drivers/mcg/mcg.c **** (
  88:../Sources/drivers/mcg/mcg.c ****     int             crystal_val,
  89:../Sources/drivers/mcg/mcg.c ****     unsigned char   hgo_val,
  90:../Sources/drivers/mcg/mcg.c ****     unsigned char   erefs_val,
  91:../Sources/drivers/mcg/mcg.c ****     signed char     prdiv_val,
  92:../Sources/drivers/mcg/mcg.c ****     signed char     vdiv_val,
  93:../Sources/drivers/mcg/mcg.c ****     unsigned char   mcgout_select
  94:../Sources/drivers/mcg/mcg.c **** )
  95:../Sources/drivers/mcg/mcg.c **** {
  27              		.loc 1 95 0
  28              		.cfi_startproc
  29              		@ args = 8, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
  33 0000 F0B4     		push	{r4, r5, r6, r7}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 16
  36              		.cfi_offset 4, -16
  37              		.cfi_offset 5, -12
  38              		.cfi_offset 6, -8
  39              		.cfi_offset 7, -4
  96:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
  97:../Sources/drivers/mcg/mcg.c **** 
  98:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
  99:../Sources/drivers/mcg/mcg.c **** 
 100:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 101:../Sources/drivers/mcg/mcg.c **** 
 102:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 103:../Sources/drivers/mcg/mcg.c **** 
 104:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 105:../Sources/drivers/mcg/mcg.c **** 
 106:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 107:../Sources/drivers/mcg/mcg.c **** 
 108:../Sources/drivers/mcg/mcg.c ****     unsigned char   frdiv_val;
 109:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
 110:../Sources/drivers/mcg/mcg.c ****     unsigned char   prdiv, vdiv;
 111:../Sources/drivers/mcg/mcg.c ****     short           i;
 112:../Sources/drivers/mcg/mcg.c ****     int             ref_freq;
 113:../Sources/drivers/mcg/mcg.c ****     int             pll_freq;
 114:../Sources/drivers/mcg/mcg.c **** 
 115:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 116:../Sources/drivers/mcg/mcg.c **** 
 117:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 118:../Sources/drivers/mcg/mcg.c **** 
 119:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 120:../Sources/drivers/mcg/mcg.c **** 
 121:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 122:../Sources/drivers/mcg/mcg.c **** 
 123:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 124:../Sources/drivers/mcg/mcg.c **** 
 125:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 126:../Sources/drivers/mcg/mcg.c **** 
 127:../Sources/drivers/mcg/mcg.c ****     // check if in FEI mode
 128:../Sources/drivers/mcg/mcg.c **** 
 129:../Sources/drivers/mcg/mcg.c ****     if
 130:../Sources/drivers/mcg/mcg.c ****     (
 131:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
  40              		.loc 1 131 0
  41 0002 4FF48044 		mov	r4, #16384
  42 0006 C4F20604 		movt	r4, 16390
  95:../Sources/drivers/mcg/mcg.c **** {
  43              		.loc 1 95 0
  44 000a 9DF91060 		ldrsb	r6, [sp, #16]
  45              		.loc 1 131 0
  46 000e A579     		ldrb	r5, [r4, #6]	@ zero_extendqisi2
 130:../Sources/drivers/mcg/mcg.c ****     (
  47              		.loc 1 130 0
  48 0010 15F00C0F 		tst	r5, #12
  49 0014 11D1     		bne	.L22
 132:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
  50              		.loc 1 132 0
  51 0016 A579     		ldrb	r5, [r4, #6]	@ zero_extendqisi2
  52 0018 05F01005 		and	r5, r5, #16
  53 001c EDB2     		uxtb	r5, r5
  54 001e 65B1     		cbz	r5, .L22
 133:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
  55              		.loc 1 133 0
  56 0020 A479     		ldrb	r4, [r4, #6]	@ zero_extendqisi2
 131:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
  57              		.loc 1 131 0
  58 0022 04F02004 		and	r4, r4, #32
  59 0026 E4B2     		uxtb	r4, r4
  60 0028 3CB9     		cbnz	r4, .L22
 134:../Sources/drivers/mcg/mcg.c ****         )
 135:../Sources/drivers/mcg/mcg.c ****     )                       // check PLLS mux has selected FLL
 136:../Sources/drivers/mcg/mcg.c ****     {
 137:../Sources/drivers/mcg/mcg.c ****         return 0x1;         // return error code
 138:../Sources/drivers/mcg/mcg.c ****     }
 139:../Sources/drivers/mcg/mcg.c **** 
 140:../Sources/drivers/mcg/mcg.c ****     // check external frequency is less than the maximum frequency
 141:../Sources/drivers/mcg/mcg.c **** 
 142:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
  61              		.loc 1 142 0
  62 002a 4FF28004 		movw	r4, #61568
  63 002e C0F2FA24 		movt	r4, 762
  64 0032 A042     		cmp	r0, r4
  65 0034 04DD     		ble	.L78
 143:../Sources/drivers/mcg/mcg.c ****     {
 144:../Sources/drivers/mcg/mcg.c ****         return 0x21;
  66              		.loc 1 144 0
  67 0036 2120     		movs	r0, #33
  68              	.LVL1:
  69 0038 00E0     		b	.L2
  70              	.LVL2:
  71              	.L22:
 137:../Sources/drivers/mcg/mcg.c ****         return 0x1;         // return error code
  72              		.loc 1 137 0
  73 003a 0120     		movs	r0, #1
  74              	.LVL3:
  75              	.L2:
 145:../Sources/drivers/mcg/mcg.c ****     }
 146:../Sources/drivers/mcg/mcg.c **** 
 147:../Sources/drivers/mcg/mcg.c ****     // check crystal frequency is within spec. if crystal osc is being used as PLL ref
 148:../Sources/drivers/mcg/mcg.c **** 
 149:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 150:../Sources/drivers/mcg/mcg.c ****     {
 151:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 3000000) || (crystal_val > 32000000))
 152:../Sources/drivers/mcg/mcg.c ****         {
 153:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return 1 if one of the available crystal options is not available
 154:../Sources/drivers/mcg/mcg.c ****         }
 155:../Sources/drivers/mcg/mcg.c ****     }
 156:../Sources/drivers/mcg/mcg.c **** 
 157:../Sources/drivers/mcg/mcg.c ****     // make sure HGO will never be greater than 1. Could return an error instead if desired.
 158:../Sources/drivers/mcg/mcg.c **** 
 159:../Sources/drivers/mcg/mcg.c ****     if(hgo_val > 0)
 160:../Sources/drivers/mcg/mcg.c ****     {
 161:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 162:../Sources/drivers/mcg/mcg.c ****     }
 163:../Sources/drivers/mcg/mcg.c **** 
 164:../Sources/drivers/mcg/mcg.c ****     // Check PLL divider settings are within spec.
 165:../Sources/drivers/mcg/mcg.c **** 
 166:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 167:../Sources/drivers/mcg/mcg.c ****     {
 168:../Sources/drivers/mcg/mcg.c ****         return 0x41;
 169:../Sources/drivers/mcg/mcg.c ****     }
 170:../Sources/drivers/mcg/mcg.c **** 
 171:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 172:../Sources/drivers/mcg/mcg.c ****     {
 173:../Sources/drivers/mcg/mcg.c ****         return 0x42;
 174:../Sources/drivers/mcg/mcg.c ****     }
 175:../Sources/drivers/mcg/mcg.c **** 
 176:../Sources/drivers/mcg/mcg.c ****     // Check PLL reference clock frequency is within spec.
 177:../Sources/drivers/mcg/mcg.c **** 
 178:../Sources/drivers/mcg/mcg.c ****     ref_freq = crystal_val / prdiv_val;
 179:../Sources/drivers/mcg/mcg.c **** 
 180:../Sources/drivers/mcg/mcg.c ****     if((ref_freq < 2000000) || (ref_freq > 4000000))
 181:../Sources/drivers/mcg/mcg.c ****     {
 182:../Sources/drivers/mcg/mcg.c ****         return 0x43;
 183:../Sources/drivers/mcg/mcg.c ****     }
 184:../Sources/drivers/mcg/mcg.c **** 
 185:../Sources/drivers/mcg/mcg.c ****     // Check PLL output frequency is within spec.
 186:../Sources/drivers/mcg/mcg.c **** 
 187:../Sources/drivers/mcg/mcg.c ****     pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 188:../Sources/drivers/mcg/mcg.c **** 
 189:../Sources/drivers/mcg/mcg.c ****     if((pll_freq < 48000000) || (pll_freq > 100000000))
 190:../Sources/drivers/mcg/mcg.c ****     {
 191:../Sources/drivers/mcg/mcg.c ****         return 0x45;
 192:../Sources/drivers/mcg/mcg.c ****     }
 193:../Sources/drivers/mcg/mcg.c **** 
 194:../Sources/drivers/mcg/mcg.c ****     // configure the MCG_C2 register
 195:../Sources/drivers/mcg/mcg.c ****     // the RANGE value is determined by the external frequency. Since the RANGE parameter affects t
 196:../Sources/drivers/mcg/mcg.c ****     // it still needs to be set correctly even if the oscillator is not being used
 197:../Sources/drivers/mcg/mcg.c **** 
 198:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 199:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 200:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 8000000)
 201:../Sources/drivers/mcg/mcg.c ****     {
 202:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 203:../Sources/drivers/mcg/mcg.c ****     }
 204:../Sources/drivers/mcg/mcg.c ****     else
 205:../Sources/drivers/mcg/mcg.c ****     {
 206:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 207:../Sources/drivers/mcg/mcg.c ****     }
 208:../Sources/drivers/mcg/mcg.c **** 
 209:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 210:../Sources/drivers/mcg/mcg.c **** 
 211:../Sources/drivers/mcg/mcg.c ****     // determine FRDIV based on reference clock frequency
 212:../Sources/drivers/mcg/mcg.c ****     // since the external frequency has already been checked only the maximum frequency for each FR
 213:../Sources/drivers/mcg/mcg.c **** 
 214:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 215:../Sources/drivers/mcg/mcg.c ****     {
 216:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 0;
 217:../Sources/drivers/mcg/mcg.c ****     }
 218:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 219:../Sources/drivers/mcg/mcg.c ****     {
 220:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 1;
 221:../Sources/drivers/mcg/mcg.c ****     }
 222:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 223:../Sources/drivers/mcg/mcg.c ****     {
 224:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 2;
 225:../Sources/drivers/mcg/mcg.c ****     }
 226:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 227:../Sources/drivers/mcg/mcg.c ****     {
 228:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 3;
 229:../Sources/drivers/mcg/mcg.c ****     }
 230:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 231:../Sources/drivers/mcg/mcg.c ****     {
 232:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 4;
 233:../Sources/drivers/mcg/mcg.c ****     }
 234:../Sources/drivers/mcg/mcg.c ****     else
 235:../Sources/drivers/mcg/mcg.c ****     {
 236:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 5;
 237:../Sources/drivers/mcg/mcg.c ****     }
 238:../Sources/drivers/mcg/mcg.c **** 
 239:../Sources/drivers/mcg/mcg.c ****     // Select external oscillator and Reference Divider and clear IREFS to start ext osc
 240:../Sources/drivers/mcg/mcg.c ****     // If IRCLK is required it must be enabled outside of this driver, existing state will be maint
 241:../Sources/drivers/mcg/mcg.c ****     // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
 242:../Sources/drivers/mcg/mcg.c **** 
 243:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 244:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
 245:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 246:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 247:../Sources/drivers/mcg/mcg.c **** 
 248:../Sources/drivers/mcg/mcg.c ****     // if the external oscillator is used need to wait for OSCINIT to set
 249:../Sources/drivers/mcg/mcg.c **** 
 250:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 251:../Sources/drivers/mcg/mcg.c ****     {
 252:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 20000; i++)
 253:../Sources/drivers/mcg/mcg.c ****         {
 254:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
 255:../Sources/drivers/mcg/mcg.c ****         }
 256:../Sources/drivers/mcg/mcg.c **** 
 257:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is really 
 258:../Sources/drivers/mcg/mcg.c ****     }
 259:../Sources/drivers/mcg/mcg.c **** 
 260:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
 261:../Sources/drivers/mcg/mcg.c **** 
 262:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 263:../Sources/drivers/mcg/mcg.c ****     {
 264:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
 265:../Sources/drivers/mcg/mcg.c ****     }
 266:../Sources/drivers/mcg/mcg.c **** 
 267:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 268:../Sources/drivers/mcg/mcg.c **** 
 269:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
 270:../Sources/drivers/mcg/mcg.c **** 
 271:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 272:../Sources/drivers/mcg/mcg.c ****     {
 273:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CL
 274:../Sources/drivers/mcg/mcg.c ****     }
 275:../Sources/drivers/mcg/mcg.c **** 
 276:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 277:../Sources/drivers/mcg/mcg.c **** 
 278:../Sources/drivers/mcg/mcg.c ****     // Now in FBE
 279:../Sources/drivers/mcg/mcg.c ****     // It is recommended that the clock monitor is enabled when using an external clock as the cloc
 280:../Sources/drivers/mcg/mcg.c ****     // It is enabled here but can be removed if this is not required.
 281:../Sources/drivers/mcg/mcg.c **** 
 282:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 283:../Sources/drivers/mcg/mcg.c **** 
 284:../Sources/drivers/mcg/mcg.c ****     // Configure PLL
 285:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C5
 286:../Sources/drivers/mcg/mcg.c ****     // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user 
 287:../Sources/drivers/mcg/mcg.c **** 
 288:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 289:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 290:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 291:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 292:../Sources/drivers/mcg/mcg.c **** 
 293:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C6
 294:../Sources/drivers/mcg/mcg.c ****     // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 295:../Sources/drivers/mcg/mcg.c ****     // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 296:../Sources/drivers/mcg/mcg.c **** 
 297:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 298:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 299:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 300:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 301:../Sources/drivers/mcg/mcg.c **** 
 302:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to set
 303:../Sources/drivers/mcg/mcg.c **** 
 304:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 305:../Sources/drivers/mcg/mcg.c ****     {
 306:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 307:../Sources/drivers/mcg/mcg.c ****     }
 308:../Sources/drivers/mcg/mcg.c **** 
 309:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 310:../Sources/drivers/mcg/mcg.c **** 
 311:../Sources/drivers/mcg/mcg.c ****     // Wait for LOCK bit to set
 312:../Sources/drivers/mcg/mcg.c **** 
 313:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 4000; i++)
 314:../Sources/drivers/mcg/mcg.c ****     {
 315:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 316:../Sources/drivers/mcg/mcg.c ****     }
 317:../Sources/drivers/mcg/mcg.c **** 
 318:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 319:../Sources/drivers/mcg/mcg.c **** 
 320:../Sources/drivers/mcg/mcg.c ****     // Use actual PLL settings to calculate PLL frequency
 321:../Sources/drivers/mcg/mcg.c **** 
 322:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 323:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 324:../Sources/drivers/mcg/mcg.c **** 
 325:../Sources/drivers/mcg/mcg.c ****     // now in PBE
 326:../Sources/drivers/mcg/mcg.c **** 
 327:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 328:../Sources/drivers/mcg/mcg.c **** 
 329:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
 330:../Sources/drivers/mcg/mcg.c **** 
 331:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 332:../Sources/drivers/mcg/mcg.c ****     {
 333:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break;     // jump out early i
 334:../Sources/drivers/mcg/mcg.c ****     }
 335:../Sources/drivers/mcg/mcg.c **** 
 336:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B;   // check CLKST is s
 337:../Sources/drivers/mcg/mcg.c **** 
 338:../Sources/drivers/mcg/mcg.c ****     // Now in PEE
 339:../Sources/drivers/mcg/mcg.c **** 
 340:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 341:../Sources/drivers/mcg/mcg.c **** }   // pll_init
  76              		.loc 1 341 0
  77 003c F0BC     		pop	{r4, r5, r6, r7}
  78 003e 7047     		bx	lr
  79              	.LVL4:
  80              	.L78:
 149:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
  81              		.loc 1 149 0
  82 0040 5AB1     		cbz	r2, .L3
 151:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 3000000) || (crystal_val > 32000000))
  83              		.loc 1 151 0
  84 0042 A0F53715 		sub	r5, r0, #2998272
  85 0046 48F24014 		movw	r4, #33088
  86 004a A5F5D865 		sub	r5, r5, #1728
  87 004e C0F2BA14 		movt	r4, 442
  88 0052 A542     		cmp	r5, r4
  89 0054 01D9     		bls	.L3
 153:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return 1 if one of the available crystal options is not available
  90              		.loc 1 153 0
  91 0056 2220     		movs	r0, #34
  92              	.LVL5:
  93 0058 F0E7     		b	.L2
  94              	.LVL6:
  95              	.L3:
 166:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
  96              		.loc 1 166 0
  97 005a 5C1E     		subs	r4, r3, #1
  98 005c E4B2     		uxtb	r4, r4
  99 005e 182C     		cmp	r4, #24
 100 0060 01D9     		bls	.L79
 168:../Sources/drivers/mcg/mcg.c ****         return 0x41;
 101              		.loc 1 168 0
 102 0062 4120     		movs	r0, #65
 103              	.LVL7:
 104 0064 EAE7     		b	.L2
 105              	.LVL8:
 106              	.L79:
 171:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 107              		.loc 1 171 0
 108 0066 A6F11805 		sub	r5, r6, #24
 109 006a EDB2     		uxtb	r5, r5
 110 006c 1A2D     		cmp	r5, #26
 111 006e 01D9     		bls	.L80
 173:../Sources/drivers/mcg/mcg.c ****         return 0x42;
 112              		.loc 1 173 0
 113 0070 4220     		movs	r0, #66
 114              	.LVL9:
 115 0072 E3E7     		b	.L2
 116              	.LVL10:
 117              	.L80:
 178:../Sources/drivers/mcg/mcg.c ****     ref_freq = crystal_val / prdiv_val;
 118              		.loc 1 178 0
 119 0074 90FBF3F3 		sdiv	r3, r0, r3
 120              	.LVL11:
 180:../Sources/drivers/mcg/mcg.c ****     if((ref_freq < 2000000) || (ref_freq > 4000000))
 121              		.loc 1 180 0
 122 0078 A3F5F41C 		sub	ip, r3, #1998848
 123 007c 48F28047 		movw	r7, #33920
 124 0080 ACF5906C 		sub	ip, ip, #1152
 125 0084 C0F21E07 		movt	r7, 30
 126 0088 BC45     		cmp	ip, r7
 127 008a 01D9     		bls	.L81
 182:../Sources/drivers/mcg/mcg.c ****         return 0x43;
 128              		.loc 1 182 0
 129 008c 4320     		movs	r0, #67
 130              	.LVL12:
 131 008e D5E7     		b	.L2
 132              	.LVL13:
 133              	.L81:
 187:../Sources/drivers/mcg/mcg.c ****     pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 134              		.loc 1 187 0
 135 0090 06FB03F6 		mul	r6, r6, r3
 136              	.LVL14:
 189:../Sources/drivers/mcg/mcg.c ****     if((pll_freq < 48000000) || (pll_freq > 100000000))
 137              		.loc 1 189 0
 138 0094 A6F13776 		sub	r6, r6, #47972352
 139 0098 4FF4EA43 		mov	r3, #29952
 140              	.LVL15:
 141 009c A6F5D846 		sub	r6, r6, #27648
 142 00a0 C0F21933 		movt	r3, 793
 143 00a4 9E42     		cmp	r6, r3
 144 00a6 01D9     		bls	.L82
 191:../Sources/drivers/mcg/mcg.c ****         return 0x45;
 145              		.loc 1 191 0
 146 00a8 4520     		movs	r0, #69
 147              	.LVL16:
 148 00aa C7E7     		b	.L2
 149              	.LVL17:
 150              	.L82:
 198:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 151              		.loc 1 198 0
 152 00ac 4FF48043 		mov	r3, #16384
 153 00b0 C4F20603 		movt	r3, 16390
 200:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 8000000)
 154              		.loc 1 200 0
 155 00b4 4FF49057 		mov	r7, #4608
 161:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 156              		.loc 1 161 0
 157 00b8 0031     		adds	r1, r1, #0
 198:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 158              		.loc 1 198 0
 159 00ba 5E78     		ldrb	r6, [r3, #1]	@ zero_extendqisi2
 160              	.LVL18:
 200:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 8000000)
 161              		.loc 1 200 0
 162 00bc C0F27A07 		movt	r7, 122
 161:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 163              		.loc 1 161 0
 164 00c0 18BF     		it	ne
 165 00c2 0121     		movne	r1, #1
 166              	.LVL19:
 200:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 8000000)
 167              		.loc 1 200 0
 168 00c4 B842     		cmp	r0, r7
 199:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 169              		.loc 1 199 0
 170 00c6 06F0C306 		and	r6, r6, #195
 171              	.LVL20:
 200:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 8000000)
 172              		.loc 1 200 0
 173 00ca 68DC     		bgt	.L4
 202:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 174              		.loc 1 202 0
 175 00cc 46F01007 		orr	r7, r6, #16
 176 00d0 47EA8206 		orr	r6, r7, r2, lsl #2
 177              	.LVL21:
 178 00d4 F7B2     		uxtb	r7, r6
 214:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 179              		.loc 1 214 0
 180 00d6 41F2D026 		movw	r6, #4816
 202:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 181              		.loc 1 202 0
 182 00da 47EAC101 		orr	r1, r7, r1, lsl #3
 183              	.LVL22:
 214:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 184              		.loc 1 214 0
 185 00de C0F21306 		movt	r6, 19
 209:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 186              		.loc 1 209 0
 187 00e2 5970     		strb	r1, [r3, #1]
 216:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 0;
 188              		.loc 1 216 0
 189 00e4 0023     		movs	r3, #0
 214:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 190              		.loc 1 214 0
 191 00e6 B042     		cmp	r0, r6
 192 00e8 00F39780 		bgt	.L83
 193              	.LVL23:
 194              	.L5:
 243:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 195              		.loc 1 243 0
 196 00ec 4FF48041 		mov	r1, #16384
 197 00f0 C4F20601 		movt	r1, 16390
 198 00f4 0E78     		ldrb	r6, [r1, #0]	@ zero_extendqisi2
 199              	.LVL24:
 244:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
 200              		.loc 1 244 0
 201 00f6 06F00306 		and	r6, r6, #3
 202              	.LVL25:
 245:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 203              		.loc 1 245 0
 204 00fa 46F08006 		orr	r6, r6, #128
 205 00fe 46EAC303 		orr	r3, r6, r3, lsl #3
 206              	.LVL26:
 246:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 207              		.loc 1 246 0
 208 0102 0B70     		strb	r3, [r1, #0]
 250:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 209              		.loc 1 250 0
 210 0104 F2B1     		cbz	r2, .L8
 211 0106 44F62063 		movw	r3, #20000
 212              	.LVL27:
 254:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
 213              		.loc 1 254 0
 214 010a 0A46     		mov	r2, r1
 215              	.LVL28:
 216 010c 08E0     		b	.L10
 217              	.LVL29:
 218              	.L84:
 219 010e 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 220 0110 9BB2     		uxth	r3, r3
 221 0112 01F00201 		and	r1, r1, #2
 222 0116 013B     		subs	r3, r3, #1
 223 0118 C9B2     		uxtb	r1, r1
 224 011a 9BB2     		uxth	r3, r3
 225 011c 39B9     		cbnz	r1, .L9
 252:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 20000; i++)
 226              		.loc 1 252 0
 227 011e 33B1     		cbz	r3, .L9
 228              	.L10:
 254:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
 229              		.loc 1 254 0
 230 0120 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 231 0122 01F00201 		and	r1, r1, #2
 232 0126 C9B2     		uxtb	r1, r1
 233 0128 013B     		subs	r3, r3, #1
 234 012a 0029     		cmp	r1, #0
 235 012c EFD0     		beq	.L84
 236              	.L9:
 257:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is really 
 237              		.loc 1 257 0
 238 012e 4FF48042 		mov	r2, #16384
 239 0132 C4F20602 		movt	r2, 16390
 240 0136 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 241 0138 01F00203 		and	r3, r1, #2
 242 013c DAB2     		uxtb	r2, r3
 243 013e 0AB9     		cbnz	r2, .L8
 244 0140 2320     		movs	r0, #35
 245              	.LVL30:
 246 0142 7BE7     		b	.L2
 247              	.LVL31:
 248              	.L8:
 264:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
 249              		.loc 1 264 0
 250 0144 4FF48042 		mov	r2, #16384
 251 0148 C4F20602 		movt	r2, 16390
 252 014c 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 253 014e 01F01003 		and	r3, r1, #16
 254 0152 D9B2     		uxtb	r1, r3
 255 0154 C1B1     		cbz	r1, .L11
 256 0156 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 257 0158 03F01001 		and	r1, r3, #16
 258 015c C9B2     		uxtb	r1, r1
 259 015e 40F2CF73 		movw	r3, #1999
 260 0162 89B1     		cbz	r1, .L11
 261 0164 013B     		subs	r3, r3, #1
 262 0166 08E0     		b	.L49
 263              	.L85:
 264 0168 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 265 016a 9BB2     		uxth	r3, r3
 266 016c 01F01001 		and	r1, r1, #16
 267 0170 013B     		subs	r3, r3, #1
 268 0172 C9B2     		uxtb	r1, r1
 269 0174 9BB2     		uxth	r3, r3
 270 0176 39B1     		cbz	r1, .L11
 262:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 271              		.loc 1 262 0
 272 0178 33B1     		cbz	r3, .L11
 273              	.L49:
 264:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
 274              		.loc 1 264 0
 275 017a 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 276 017c 01F01001 		and	r1, r1, #16
 277 0180 C9B2     		uxtb	r1, r1
 278 0182 013B     		subs	r3, r3, #1
 279 0184 0029     		cmp	r1, #0
 280 0186 EFD1     		bne	.L85
 281              	.L11:
 267:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 282              		.loc 1 267 0
 283 0188 4FF48043 		mov	r3, #16384
 284 018c C4F20603 		movt	r3, 16390
 285 0190 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 286 0192 02F01001 		and	r1, r2, #16
 287 0196 CAB2     		uxtb	r2, r1
 288 0198 F2B1     		cbz	r2, .L86
 289 019a 1120     		movs	r0, #17
 290              	.LVL32:
 291 019c 4EE7     		b	.L2
 292              	.LVL33:
 293              	.L4:
 206:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 294              		.loc 1 206 0
 295 019e 46F02006 		orr	r6, r6, #32
 296              	.LVL34:
 297 01a2 46EA8206 		orr	r6, r6, r2, lsl #2
 298 01a6 F6B2     		uxtb	r6, r6
 299 01a8 46EAC101 		orr	r1, r6, r1, lsl #3
 300              	.LVL35:
 209:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 301              		.loc 1 209 0
 302 01ac 5970     		strb	r1, [r3, #1]
 303              	.LVL36:
 304              	.L7:
 222:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 305              		.loc 1 222 0
 306 01ae 44F64036 		movw	r6, #19264
 307 01b2 C0F24C06 		movt	r6, 76
 308 01b6 B042     		cmp	r0, r6
 309 01b8 2DDD     		ble	.L31
 226:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 310              		.loc 1 226 0
 311 01ba 49F28061 		movw	r1, #38528
 312 01be C0F29801 		movt	r1, 152
 313 01c2 8842     		cmp	r0, r1
 314 01c4 25DD     		ble	.L32
 230:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 315              		.loc 1 230 0
 316 01c6 4FF43453 		mov	r3, #11520
 317 01ca C0F23113 		movt	r3, 305
 232:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 4;
 318              		.loc 1 232 0
 319 01ce 9842     		cmp	r0, r3
 320 01d0 CCBF     		ite	gt
 321 01d2 0523     		movgt	r3, #5
 322 01d4 0423     		movle	r3, #4
 323 01d6 89E7     		b	.L5
 324              	.LVL37:
 325              	.L86:
 267:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 326              		.loc 1 267 0
 327 01d8 4FF4FA62 		mov	r2, #2000
 328 01dc 07E0     		b	.L13
 329              	.L87:
 273:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CL
 330              		.loc 1 273 0
 331 01de 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 332 01e0 C1F38101 		ubfx	r1, r1, #2, #2
 333 01e4 0229     		cmp	r1, #2
 334 01e6 09D0     		beq	.L12
 335 01e8 013A     		subs	r2, r2, #1
 336 01ea 92B2     		uxth	r2, r2
 271:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 337              		.loc 1 271 0
 338 01ec 32B1     		cbz	r2, .L12
 339              	.L13:
 273:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CL
 340              		.loc 1 273 0
 341 01ee 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 342 01f0 C1F38101 		ubfx	r1, r1, #2, #2
 343 01f4 013A     		subs	r2, r2, #1
 344 01f6 0229     		cmp	r1, #2
 345 01f8 92B2     		uxth	r2, r2
 346 01fa F0D1     		bne	.L87
 347              	.L12:
 276:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 348              		.loc 1 276 0
 349 01fc 4FF48043 		mov	r3, #16384
 350 0200 C4F20603 		movt	r3, 16390
 351 0204 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 352 0206 C1F38102 		ubfx	r2, r1, #2, #2
 353 020a 022A     		cmp	r2, #2
 354 020c 0DD0     		beq	.L88
 355 020e 1A20     		movs	r0, #26
 356              	.LVL38:
 357 0210 14E7     		b	.L2
 358              	.LVL39:
 359              	.L32:
 228:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 3;
 360              		.loc 1 228 0
 361 0212 0323     		movs	r3, #3
 362 0214 6AE7     		b	.L5
 363              	.L31:
 224:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 2;
 364              		.loc 1 224 0
 365 0216 0223     		movs	r3, #2
 366 0218 68E7     		b	.L5
 367              	.LVL40:
 368              	.L83:
 218:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 369              		.loc 1 218 0
 370 021a 42F2A053 		movw	r3, #9632
 371 021e C0F22603 		movt	r3, 38
 372 0222 9842     		cmp	r0, r3
 373 0224 C3DC     		bgt	.L7
 220:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 1;
 374              		.loc 1 220 0
 375 0226 0123     		movs	r3, #1
 376 0228 60E7     		b	.L5
 377              	.LVL41:
 378              	.L88:
 282:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 379              		.loc 1 282 0
 380 022a 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 381 022c 41F02002 		orr	r2, r1, #32
 382 0230 5A71     		strb	r2, [r3, #5]
 288:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 383              		.loc 1 288 0
 384 0232 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 385              	.LVL42:
 289:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 386              		.loc 1 289 0
 387 0234 01F0E002 		and	r2, r1, #224
 388              	.LVL43:
 290:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 389              		.loc 1 290 0
 390 0238 1443     		orrs	r4, r4, r2
 391              	.LVL44:
 291:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 392              		.loc 1 291 0
 393 023a 1C71     		strb	r4, [r3, #4]
 297:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 394              		.loc 1 297 0
 395 023c 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 396              	.LVL45:
 298:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 397              		.loc 1 298 0
 398 023e 01F0E002 		and	r2, r1, #224
 299:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 399              		.loc 1 299 0
 400 0242 42F04001 		orr	r1, r2, #64
 401              	.LVL46:
 402 0246 0D43     		orrs	r5, r5, r1
 403              	.LVL47:
 300:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 404              		.loc 1 300 0
 405 0248 5D71     		strb	r5, [r3, #5]
 406              	.LVL48:
 407 024a 4FF4FA62 		mov	r2, #2000
 408 024e 00E0     		b	.L15
 409              	.LVL49:
 410              	.L89:
 304:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 411              		.loc 1 304 0
 412 0250 3AB1     		cbz	r2, .L14
 413              	.L15:
 306:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 414              		.loc 1 306 0
 415 0252 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 416 0254 01F02001 		and	r1, r1, #32
 417 0258 013A     		subs	r2, r2, #1
 418 025a C9B2     		uxtb	r1, r1
 419 025c 92B2     		uxth	r2, r2
 420 025e 0029     		cmp	r1, #0
 421 0260 F6D0     		beq	.L89
 422              	.L14:
 309:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 423              		.loc 1 309 0
 424 0262 4FF48043 		mov	r3, #16384
 425 0266 C4F20603 		movt	r3, 16390
 426 026a 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 427 026c 01F02002 		and	r2, r1, #32
 428 0270 D1B2     		uxtb	r1, r2
 429 0272 09B9     		cbnz	r1, .L90
 430 0274 1620     		movs	r0, #22
 431              	.LVL50:
 432 0276 E1E6     		b	.L2
 433              	.LVL51:
 434              	.L90:
 435 0278 4FF47A62 		mov	r2, #4000
 436 027c 00E0     		b	.L17
 437              	.L91:
 313:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 4000; i++)
 438              		.loc 1 313 0
 439 027e 3AB1     		cbz	r2, .L16
 440              	.L17:
 315:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 441              		.loc 1 315 0
 442 0280 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 443 0282 01F04001 		and	r1, r1, #64
 444 0286 013A     		subs	r2, r2, #1
 445 0288 C9B2     		uxtb	r1, r1
 446 028a 92B2     		uxth	r2, r2
 447 028c 0029     		cmp	r1, #0
 448 028e F6D0     		beq	.L91
 449              	.L16:
 318:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 450              		.loc 1 318 0
 451 0290 4FF48043 		mov	r3, #16384
 452 0294 C4F20603 		movt	r3, 16390
 453 0298 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 454 029a 01F04002 		and	r2, r1, #64
 455 029e D1B2     		uxtb	r1, r2
 456 02a0 09B9     		cbnz	r1, .L92
 457 02a2 4420     		movs	r0, #68
 458              	.LVL52:
 459 02a4 CAE6     		b	.L2
 460              	.LVL53:
 461              	.L92:
 322:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 462              		.loc 1 322 0
 463 02a6 1C79     		ldrb	r4, [r3, #4]	@ zero_extendqisi2
 323:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 464              		.loc 1 323 0
 465 02a8 5D79     		ldrb	r5, [r3, #5]	@ zero_extendqisi2
 466              	.LVL54:
 327:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 467              		.loc 1 327 0
 468 02aa 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 323:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 469              		.loc 1 323 0
 470 02ac 05F01F01 		and	r1, r5, #31
 322:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 471              		.loc 1 322 0
 472 02b0 04F01F04 		and	r4, r4, #31
 327:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 473              		.loc 1 327 0
 474 02b4 02F03F05 		and	r5, r2, #63
 322:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 475              		.loc 1 322 0
 476 02b8 0134     		adds	r4, r4, #1
 477              	.LVL55:
 323:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 478              		.loc 1 323 0
 479 02ba 1831     		adds	r1, r1, #24
 480              	.LVL56:
 327:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 481              		.loc 1 327 0
 482 02bc 1D70     		strb	r5, [r3, #0]
 483              	.LVL57:
 484 02be 4FF4FA62 		mov	r2, #2000
 485              	.LVL58:
 486              	.L19:
 333:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break;     // jump out early i
 487              		.loc 1 333 0
 488 02c2 9D79     		ldrb	r5, [r3, #6]	@ zero_extendqisi2
 489 02c4 C5F38105 		ubfx	r5, r5, #2, #2
 490 02c8 032D     		cmp	r5, #3
 491 02ca 03D0     		beq	.L18
 492 02cc 013A     		subs	r2, r2, #1
 493 02ce 92B2     		uxth	r2, r2
 331:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 494              		.loc 1 331 0
 495 02d0 002A     		cmp	r2, #0
 496 02d2 F6D1     		bne	.L19
 497              	.L18:
 336:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B;   // check CLKST is s
 498              		.loc 1 336 0
 499 02d4 4FF48043 		mov	r3, #16384
 500 02d8 C4F20603 		movt	r3, 16390
 501 02dc 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 502 02de C2F38103 		ubfx	r3, r2, #2, #2
 503 02e2 032B     		cmp	r3, #3
 504 02e4 01D0     		beq	.L93
 505 02e6 1B20     		movs	r0, #27
 506              	.LVL59:
 507 02e8 A8E6     		b	.L2
 508              	.LVL60:
 509              	.L93:
 340:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 510              		.loc 1 340 0
 511 02ea 90FBF4F0 		sdiv	r0, r0, r4
 512              	.LVL61:
 513 02ee 01FB00F0 		mul	r0, r1, r0
 514 02f2 A3E6     		b	.L2
 515              		.cfi_endproc
 516              	.LFE0:
 518              		.section	.text.new_pll_freq,"ax",%progbits
 519              		.align	2
 520              		.global	new_pll_freq
 521              		.thumb
 522              		.thumb_func
 524              	new_pll_freq:
 525              	.LFB1:
 342:../Sources/drivers/mcg/mcg.c **** 
 343:../Sources/drivers/mcg/mcg.c **** /*********************************************************************************************/
 344:../Sources/drivers/mcg/mcg.c **** 
 345:../Sources/drivers/mcg/mcg.c **** /* Functon name : new_pll_freq
 346:../Sources/drivers/mcg/mcg.c ****  *
 347:../Sources/drivers/mcg/mcg.c ****  * Mode transition: Moves from PEE to PBE mode before changing PLL settings and moves back to PEE m
 348:../Sources/drivers/mcg/mcg.c ****  *
 349:../Sources/drivers/mcg/mcg.c ****  * This function provides a safe means of updating the PLL configurations to ensure the system
 350:../Sources/drivers/mcg/mcg.c ****  * does not lose the clock source or is over-clocked as the PLL frequency changes.
 351:../Sources/drivers/mcg/mcg.c ****  * Using the function parameter names the PLL frequency is calculated as follows:
 352:../Sources/drivers/mcg/mcg.c ****  * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
 353:../Sources/drivers/mcg/mcg.c ****  * The various passed parameters are checked to ensure they are within the allowed range. If any
 354:../Sources/drivers/mcg/mcg.c ****  * of these checks fail the driver will exit and return a fail/error code. An error code will
 355:../Sources/drivers/mcg/mcg.c ****  * also be returned if any error occurs during the PLL initialization sequence. Refer to the
 356:../Sources/drivers/mcg/mcg.c ****  * readme file in the mcg driver directory for a list of all these codes.
 357:../Sources/drivers/mcg/mcg.c ****  * This function first moves the MCG to PBE mode to use the external reference clock to provide the
 358:../Sources/drivers/mcg/mcg.c ****  * system clock. The PLL settings are then updated. Once the PLL has re-locked the MCG is moved bac
 359:../Sources/drivers/mcg/mcg.c ****  * to PEE to use the PLL as the system clock.
 360:../Sources/drivers/mcg/mcg.c ****  * Only the PLL PRDIV0 and VDIV0 fields are changed.
 361:../Sources/drivers/mcg/mcg.c ****  *
 362:../Sources/drivers/mcg/mcg.c ****  * Prerequisistes : The MCG must be in PEE mode before calling this routine. It is the responsibili
 363:../Sources/drivers/mcg/mcg.c ****  * of the calling routine to ensure the SIM_CLKDIV1 system clock dividers and any peripheral clock
 364:../Sources/drivers/mcg/mcg.c ****  * dividers are set correctly before or after calling this function to ensure the appropriate clock
 365:../Sources/drivers/mcg/mcg.c ****  * are kept within specification. You would typically change the divider values before calling this
 366:../Sources/drivers/mcg/mcg.c ****  * routine.
 367:../Sources/drivers/mcg/mcg.c ****  *
 368:../Sources/drivers/mcg/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
 369:../Sources/drivers/mcg/mcg.c ****  *                           wave clock source
 370:../Sources/drivers/mcg/mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 371:../Sources/drivers/mcg/mcg.c ****  *                           PLL reference clock frequency
 372:../Sources/drivers/mcg/mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 373:../Sources/drivers/mcg/mcg.c ****  *
 374:../Sources/drivers/mcg/mcg.c ****  * Return value : PLL frequency (Hz) or error code
 375:../Sources/drivers/mcg/mcg.c ****  */
 376:../Sources/drivers/mcg/mcg.c **** 
 377:../Sources/drivers/mcg/mcg.c **** int new_pll_freq
 378:../Sources/drivers/mcg/mcg.c **** (
 379:../Sources/drivers/mcg/mcg.c ****     int         crystal_val,
 380:../Sources/drivers/mcg/mcg.c ****     signed char prdiv_val,
 381:../Sources/drivers/mcg/mcg.c ****     signed char vdiv_val
 382:../Sources/drivers/mcg/mcg.c **** )
 383:../Sources/drivers/mcg/mcg.c **** {
 526              		.loc 1 383 0
 527              		.cfi_startproc
 528              		@ args = 0, pretend = 0, frame = 0
 529              		@ frame_needed = 0, uses_anonymous_args = 0
 530              		@ link register save eliminated.
 531              	.LVL62:
 532 0000 F0B4     		push	{r4, r5, r6, r7}
 533              	.LCFI1:
 534              		.cfi_def_cfa_offset 16
 535              		.cfi_offset 4, -16
 536              		.cfi_offset 5, -12
 537              		.cfi_offset 6, -8
 538              		.cfi_offset 7, -4
 384:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 385:../Sources/drivers/mcg/mcg.c **** 
 386:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 387:../Sources/drivers/mcg/mcg.c **** 
 388:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 389:../Sources/drivers/mcg/mcg.c **** 
 390:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 391:../Sources/drivers/mcg/mcg.c **** 
 392:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 393:../Sources/drivers/mcg/mcg.c **** 
 394:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 395:../Sources/drivers/mcg/mcg.c **** 
 396:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
 397:../Sources/drivers/mcg/mcg.c ****     unsigned char   prdiv, vdiv;
 398:../Sources/drivers/mcg/mcg.c ****     short           i;
 399:../Sources/drivers/mcg/mcg.c ****     int             ref_freq;
 400:../Sources/drivers/mcg/mcg.c ****     int             pll_freq;
 401:../Sources/drivers/mcg/mcg.c **** 
 402:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 403:../Sources/drivers/mcg/mcg.c **** 
 404:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 405:../Sources/drivers/mcg/mcg.c **** 
 406:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 407:../Sources/drivers/mcg/mcg.c **** 
 408:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 409:../Sources/drivers/mcg/mcg.c **** 
 410:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 411:../Sources/drivers/mcg/mcg.c **** 
 412:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 413:../Sources/drivers/mcg/mcg.c **** 
 414:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PEE mode
 415:../Sources/drivers/mcg/mcg.c **** 
 416:../Sources/drivers/mcg/mcg.c ****     if
 417:../Sources/drivers/mcg/mcg.c ****     (
 418:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3)    // check CLKS mux has selct
 539              		.loc 1 418 0
 540 0002 4FF48043 		mov	r3, #16384
 541 0006 C4F20603 		movt	r3, 16390
 542 000a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 543 000c C4F38104 		ubfx	r4, r4, #2, #2
 417:../Sources/drivers/mcg/mcg.c ****     (
 544              		.loc 1 417 0
 545 0010 032C     		cmp	r4, #3
 546 0012 02D0     		beq	.L128
 547              	.L106:
 419:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 420:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)
 421:../Sources/drivers/mcg/mcg.c ****         )
 422:../Sources/drivers/mcg/mcg.c ****     )               // check PLLS mux has selected PLL
 423:../Sources/drivers/mcg/mcg.c ****     {
 424:../Sources/drivers/mcg/mcg.c ****         return 0x8; // return error code
 548              		.loc 1 424 0
 549 0014 0820     		movs	r0, #8
 550              	.LVL63:
 551              	.L95:
 425:../Sources/drivers/mcg/mcg.c ****     }
 426:../Sources/drivers/mcg/mcg.c **** 
 427:../Sources/drivers/mcg/mcg.c ****     // Check PLL divider settings are within spec.
 428:../Sources/drivers/mcg/mcg.c **** 
 429:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 430:../Sources/drivers/mcg/mcg.c ****     {
 431:../Sources/drivers/mcg/mcg.c ****         return 0x41;
 432:../Sources/drivers/mcg/mcg.c ****     }
 433:../Sources/drivers/mcg/mcg.c **** 
 434:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 435:../Sources/drivers/mcg/mcg.c ****     {
 436:../Sources/drivers/mcg/mcg.c ****         return 0x42;
 437:../Sources/drivers/mcg/mcg.c ****     }
 438:../Sources/drivers/mcg/mcg.c **** 
 439:../Sources/drivers/mcg/mcg.c ****     // Check PLL reference clock frequency is within spec.
 440:../Sources/drivers/mcg/mcg.c **** 
 441:../Sources/drivers/mcg/mcg.c ****     ref_freq = crystal_val / prdiv_val;
 442:../Sources/drivers/mcg/mcg.c **** 
 443:../Sources/drivers/mcg/mcg.c ****     if((ref_freq < 2000000) || (ref_freq > 4000000))
 444:../Sources/drivers/mcg/mcg.c ****     {
 445:../Sources/drivers/mcg/mcg.c ****         return 0x43;
 446:../Sources/drivers/mcg/mcg.c ****     }
 447:../Sources/drivers/mcg/mcg.c **** 
 448:../Sources/drivers/mcg/mcg.c ****     // Check PLL output frequency is within spec.
 449:../Sources/drivers/mcg/mcg.c **** 
 450:../Sources/drivers/mcg/mcg.c ****     pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 451:../Sources/drivers/mcg/mcg.c **** 
 452:../Sources/drivers/mcg/mcg.c ****     if((pll_freq < 48000000) || (pll_freq > 100000000))
 453:../Sources/drivers/mcg/mcg.c ****     {
 454:../Sources/drivers/mcg/mcg.c ****         return 0x45;
 455:../Sources/drivers/mcg/mcg.c ****     }
 456:../Sources/drivers/mcg/mcg.c **** 
 457:../Sources/drivers/mcg/mcg.c ****     // First move to PBE mode so that the PLL frequency can be safely changed.
 458:../Sources/drivers/mcg/mcg.c ****     // As we are running from the PLL by default the PLL and external clock settings are valid
 459:../Sources/drivers/mcg/mcg.c ****     // To move to PBE from PEE simply requires the switching of the CLKS mux to select the ext cloc
 460:../Sources/drivers/mcg/mcg.c ****     // As CLKS is already 0 the CLKS value can simply be OR'ed into the register
 461:../Sources/drivers/mcg/mcg.c **** 
 462:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(2);   // switch CLKS mux to select external reference clock as MCG_OUT
 463:../Sources/drivers/mcg/mcg.c **** 
 464:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
 465:../Sources/drivers/mcg/mcg.c **** 
 466:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 467:../Sources/drivers/mcg/mcg.c ****     {
 468:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out early i
 469:../Sources/drivers/mcg/mcg.c ****     }
 470:../Sources/drivers/mcg/mcg.c **** 
 471:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 472:../Sources/drivers/mcg/mcg.c **** 
 473:../Sources/drivers/mcg/mcg.c ****     // Now in PBE mode
 474:../Sources/drivers/mcg/mcg.c ****     // System is clocked off the external clock.
 475:../Sources/drivers/mcg/mcg.c ****     // Now update the PLL settings and wait for the PLL to re-lock
 476:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C5
 477:../Sources/drivers/mcg/mcg.c **** 
 478:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 479:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 480:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 481:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 482:../Sources/drivers/mcg/mcg.c **** 
 483:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C6
 484:../Sources/drivers/mcg/mcg.c ****     // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 485:../Sources/drivers/mcg/mcg.c ****     // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 486:../Sources/drivers/mcg/mcg.c **** 
 487:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 488:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 489:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 490:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 491:../Sources/drivers/mcg/mcg.c **** 
 492:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to set
 493:../Sources/drivers/mcg/mcg.c **** 
 494:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 495:../Sources/drivers/mcg/mcg.c ****     {
 496:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 497:../Sources/drivers/mcg/mcg.c ****     }
 498:../Sources/drivers/mcg/mcg.c **** 
 499:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 500:../Sources/drivers/mcg/mcg.c **** 
 501:../Sources/drivers/mcg/mcg.c ****     // Wait for LOCK bit to set
 502:../Sources/drivers/mcg/mcg.c **** 
 503:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 4000; i++)
 504:../Sources/drivers/mcg/mcg.c ****     {
 505:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 506:../Sources/drivers/mcg/mcg.c ****     }
 507:../Sources/drivers/mcg/mcg.c **** 
 508:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 509:../Sources/drivers/mcg/mcg.c **** 
 510:../Sources/drivers/mcg/mcg.c ****     // Change CLKS mux to now select the PLL output
 511:../Sources/drivers/mcg/mcg.c **** 
 512:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 513:../Sources/drivers/mcg/mcg.c **** 
 514:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
 515:../Sources/drivers/mcg/mcg.c **** 
 516:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 517:../Sources/drivers/mcg/mcg.c ****     {
 518:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break;     // jump out early i
 519:../Sources/drivers/mcg/mcg.c ****     }
 520:../Sources/drivers/mcg/mcg.c **** 
 521:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B;   // check CLKST is s
 522:../Sources/drivers/mcg/mcg.c **** 
 523:../Sources/drivers/mcg/mcg.c ****     // Now in PEE
 524:../Sources/drivers/mcg/mcg.c ****     // Use actual PLL settings to calculate PLL frequency
 525:../Sources/drivers/mcg/mcg.c **** 
 526:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 527:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 528:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 529:../Sources/drivers/mcg/mcg.c **** }   // new_pll_freq
 552              		.loc 1 529 0
 553 0016 F0BC     		pop	{r4, r5, r6, r7}
 554 0018 7047     		bx	lr
 555              	.LVL64:
 556              	.L128:
 419:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 557              		.loc 1 419 0
 558 001a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 559 001c 04F01004 		and	r4, r4, #16
 560 0020 E4B2     		uxtb	r4, r4
 561 0022 002C     		cmp	r4, #0
 562 0024 F6D1     		bne	.L106
 420:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)
 563              		.loc 1 420 0
 564 0026 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 418:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3)    // check CLKS mux has selct
 565              		.loc 1 418 0
 566 0028 04F02004 		and	r4, r4, #32
 567 002c E4B2     		uxtb	r4, r4
 568 002e 002C     		cmp	r4, #0
 569 0030 F0D0     		beq	.L106
 429:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 570              		.loc 1 429 0
 571 0032 4C1E     		subs	r4, r1, #1
 572 0034 E4B2     		uxtb	r4, r4
 573 0036 182C     		cmp	r4, #24
 574 0038 01D9     		bls	.L129
 431:../Sources/drivers/mcg/mcg.c ****         return 0x41;
 575              		.loc 1 431 0
 576 003a 4120     		movs	r0, #65
 577              	.LVL65:
 578 003c EBE7     		b	.L95
 579              	.LVL66:
 580              	.L129:
 434:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 581              		.loc 1 434 0
 582 003e A2F11805 		sub	r5, r2, #24
 583 0042 EDB2     		uxtb	r5, r5
 584 0044 1A2D     		cmp	r5, #26
 585 0046 01D9     		bls	.L130
 436:../Sources/drivers/mcg/mcg.c ****         return 0x42;
 586              		.loc 1 436 0
 587 0048 4220     		movs	r0, #66
 588              	.LVL67:
 589 004a E4E7     		b	.L95
 590              	.LVL68:
 591              	.L130:
 441:../Sources/drivers/mcg/mcg.c ****     ref_freq = crystal_val / prdiv_val;
 592              		.loc 1 441 0
 593 004c 90FBF1F1 		sdiv	r1, r0, r1
 594              	.LVL69:
 443:../Sources/drivers/mcg/mcg.c ****     if((ref_freq < 2000000) || (ref_freq > 4000000))
 595              		.loc 1 443 0
 596 0050 A1F5F417 		sub	r7, r1, #1998848
 597 0054 48F28046 		movw	r6, #33920
 598 0058 A7F59067 		sub	r7, r7, #1152
 599 005c C0F21E06 		movt	r6, 30
 600 0060 B742     		cmp	r7, r6
 601 0062 01D9     		bls	.L131
 445:../Sources/drivers/mcg/mcg.c ****         return 0x43;
 602              		.loc 1 445 0
 603 0064 4320     		movs	r0, #67
 604              	.LVL70:
 605 0066 D6E7     		b	.L95
 606              	.LVL71:
 607              	.L131:
 450:../Sources/drivers/mcg/mcg.c ****     pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 608              		.loc 1 450 0
 609 0068 02FB01F1 		mul	r1, r2, r1
 610              	.LVL72:
 452:../Sources/drivers/mcg/mcg.c ****     if((pll_freq < 48000000) || (pll_freq > 100000000))
 611              		.loc 1 452 0
 612 006c A1F13771 		sub	r1, r1, #47972352
 613 0070 4FF4EA42 		mov	r2, #29952
 614              	.LVL73:
 615 0074 A1F5D841 		sub	r1, r1, #27648
 616 0078 C0F21932 		movt	r2, 793
 617 007c 9142     		cmp	r1, r2
 618 007e 01D9     		bls	.L132
 454:../Sources/drivers/mcg/mcg.c ****         return 0x45;
 619              		.loc 1 454 0
 620 0080 4520     		movs	r0, #69
 621              	.LVL74:
 622 0082 C8E7     		b	.L95
 623              	.LVL75:
 624              	.L132:
 462:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(2);   // switch CLKS mux to select external reference clock as MCG_OUT
 625              		.loc 1 462 0
 626 0084 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 627 0086 42F08001 		orr	r1, r2, #128
 628 008a 1970     		strb	r1, [r3, #0]
 629              	.LVL76:
 630 008c 4FF4FA62 		mov	r2, #2000
 631 0090 07E0     		b	.L97
 632              	.LVL77:
 633              	.L133:
 468:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out early i
 634              		.loc 1 468 0
 635 0092 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 636 0094 C1F38101 		ubfx	r1, r1, #2, #2
 637 0098 0229     		cmp	r1, #2
 638 009a 09D0     		beq	.L96
 639 009c 013A     		subs	r2, r2, #1
 640 009e 92B2     		uxth	r2, r2
 466:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 641              		.loc 1 466 0
 642 00a0 32B1     		cbz	r2, .L96
 643              	.L97:
 468:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out early i
 644              		.loc 1 468 0
 645 00a2 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 646 00a4 C1F38101 		ubfx	r1, r1, #2, #2
 647 00a8 013A     		subs	r2, r2, #1
 648 00aa 0229     		cmp	r1, #2
 649 00ac 92B2     		uxth	r2, r2
 650 00ae F0D1     		bne	.L133
 651              	.L96:
 471:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 652              		.loc 1 471 0
 653 00b0 4FF48043 		mov	r3, #16384
 654 00b4 C4F20603 		movt	r3, 16390
 655 00b8 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 656 00ba C1F38102 		ubfx	r2, r1, #2, #2
 657 00be 022A     		cmp	r2, #2
 658 00c0 01D0     		beq	.L134
 659 00c2 1A20     		movs	r0, #26
 660              	.LVL78:
 661 00c4 A7E7     		b	.L95
 662              	.LVL79:
 663              	.L134:
 478:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 664              		.loc 1 478 0
 665 00c6 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 666              	.LVL80:
 479:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 667              		.loc 1 479 0
 668 00c8 01F0E002 		and	r2, r1, #224
 669              	.LVL81:
 480:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 670              		.loc 1 480 0
 671 00cc 1443     		orrs	r4, r4, r2
 672              	.LVL82:
 481:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 673              		.loc 1 481 0
 674 00ce 1C71     		strb	r4, [r3, #4]
 487:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 675              		.loc 1 487 0
 676 00d0 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 677              	.LVL83:
 488:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 678              		.loc 1 488 0
 679 00d2 01F0E002 		and	r2, r1, #224
 489:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 680              		.loc 1 489 0
 681 00d6 42F04001 		orr	r1, r2, #64
 682              	.LVL84:
 683 00da 0D43     		orrs	r5, r5, r1
 684              	.LVL85:
 490:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 685              		.loc 1 490 0
 686 00dc 5D71     		strb	r5, [r3, #5]
 687              	.LVL86:
 688 00de 4FF4FA62 		mov	r2, #2000
 689 00e2 00E0     		b	.L99
 690              	.LVL87:
 691              	.L135:
 494:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 692              		.loc 1 494 0
 693 00e4 3AB1     		cbz	r2, .L98
 694              	.L99:
 496:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 695              		.loc 1 496 0
 696 00e6 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 697 00e8 01F02001 		and	r1, r1, #32
 698 00ec 013A     		subs	r2, r2, #1
 699 00ee C9B2     		uxtb	r1, r1
 700 00f0 92B2     		uxth	r2, r2
 701 00f2 0029     		cmp	r1, #0
 702 00f4 F6D0     		beq	.L135
 703              	.L98:
 499:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 704              		.loc 1 499 0
 705 00f6 4FF48043 		mov	r3, #16384
 706 00fa C4F20603 		movt	r3, 16390
 707 00fe 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 708 0100 01F02002 		and	r2, r1, #32
 709 0104 D1B2     		uxtb	r1, r2
 710 0106 09B9     		cbnz	r1, .L136
 711 0108 1620     		movs	r0, #22
 712              	.LVL88:
 713 010a 84E7     		b	.L95
 714              	.LVL89:
 715              	.L136:
 716 010c 4FF47A62 		mov	r2, #4000
 717 0110 00E0     		b	.L101
 718              	.L137:
 503:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 4000; i++)
 719              		.loc 1 503 0
 720 0112 3AB1     		cbz	r2, .L100
 721              	.L101:
 505:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 722              		.loc 1 505 0
 723 0114 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 724 0116 01F04001 		and	r1, r1, #64
 725 011a 013A     		subs	r2, r2, #1
 726 011c C9B2     		uxtb	r1, r1
 727 011e 92B2     		uxth	r2, r2
 728 0120 0029     		cmp	r1, #0
 729 0122 F6D0     		beq	.L137
 730              	.L100:
 508:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 731              		.loc 1 508 0
 732 0124 4FF48043 		mov	r3, #16384
 733 0128 C4F20603 		movt	r3, 16390
 734 012c 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 735 012e 01F04002 		and	r2, r1, #64
 736 0132 D1B2     		uxtb	r1, r2
 737 0134 09B9     		cbnz	r1, .L138
 738 0136 4420     		movs	r0, #68
 739              	.LVL90:
 740 0138 6DE7     		b	.L95
 741              	.LVL91:
 742              	.L138:
 512:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 743              		.loc 1 512 0
 744 013a 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 745 013c 02F03F01 		and	r1, r2, #63
 746 0140 1970     		strb	r1, [r3, #0]
 747              	.LVL92:
 748 0142 4FF4FA62 		mov	r2, #2000
 749 0146 02E0     		b	.L103
 750              	.LVL93:
 751              	.L139:
 752 0148 013A     		subs	r2, r2, #1
 753 014a 92B2     		uxth	r2, r2
 516:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 754              		.loc 1 516 0
 755 014c 22B1     		cbz	r2, .L102
 756              	.L103:
 518:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break;     // jump out early i
 757              		.loc 1 518 0
 758 014e 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 759 0150 C1F38101 		ubfx	r1, r1, #2, #2
 760 0154 0329     		cmp	r1, #3
 761 0156 F7D1     		bne	.L139
 762              	.L102:
 521:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B;   // check CLKST is s
 763              		.loc 1 521 0
 764 0158 4FF48043 		mov	r3, #16384
 765 015c C4F20603 		movt	r3, 16390
 766 0160 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 767 0162 C1F38102 		ubfx	r2, r1, #2, #2
 768 0166 032A     		cmp	r2, #3
 769 0168 01D0     		beq	.L140
 770 016a 1B20     		movs	r0, #27
 771              	.LVL94:
 772 016c 53E7     		b	.L95
 773              	.LVL95:
 774              	.L140:
 526:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 775              		.loc 1 526 0
 776 016e 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 777              	.LVL96:
 527:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 778              		.loc 1 527 0
 779 0170 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 780              	.LVL97:
 526:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 781              		.loc 1 526 0
 782 0172 01F01F02 		and	r2, r1, #31
 528:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 783              		.loc 1 528 0
 784 0176 511C     		adds	r1, r2, #1
 785              	.LVL98:
 527:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 786              		.loc 1 527 0
 787 0178 03F01F03 		and	r3, r3, #31
 788              	.LVL99:
 528:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 789              		.loc 1 528 0
 790 017c 90FBF1F0 		sdiv	r0, r0, r1
 791              	.LVL100:
 792 0180 1833     		adds	r3, r3, #24
 793 0182 03FB00F0 		mul	r0, r3, r0
 794 0186 46E7     		b	.L95
 795              		.cfi_endproc
 796              	.LFE1:
 798              		.section	.text.pee_pbe,"ax",%progbits
 799              		.align	2
 800              		.global	pee_pbe
 801              		.thumb
 802              		.thumb_func
 804              	pee_pbe:
 805              	.LFB2:
 530:../Sources/drivers/mcg/mcg.c **** 
 531:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
 532:../Sources/drivers/mcg/mcg.c **** 
 533:../Sources/drivers/mcg/mcg.c **** int pee_pbe
 534:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
 535:../Sources/drivers/mcg/mcg.c **** {
 806              		.loc 1 535 0
 807              		.cfi_startproc
 808              		@ args = 0, pretend = 0, frame = 0
 809              		@ frame_needed = 0, uses_anonymous_args = 0
 810              		@ link register save eliminated.
 811              	.LVL101:
 536:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 537:../Sources/drivers/mcg/mcg.c **** 
 538:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 539:../Sources/drivers/mcg/mcg.c **** 
 540:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 541:../Sources/drivers/mcg/mcg.c **** 
 542:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 543:../Sources/drivers/mcg/mcg.c **** 
 544:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 545:../Sources/drivers/mcg/mcg.c **** 
 546:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 547:../Sources/drivers/mcg/mcg.c **** 
 548:../Sources/drivers/mcg/mcg.c ****     short   i;
 549:../Sources/drivers/mcg/mcg.c **** 
 550:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 551:../Sources/drivers/mcg/mcg.c **** 
 552:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 553:../Sources/drivers/mcg/mcg.c **** 
 554:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 555:../Sources/drivers/mcg/mcg.c **** 
 556:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 557:../Sources/drivers/mcg/mcg.c **** 
 558:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 559:../Sources/drivers/mcg/mcg.c **** 
 560:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 561:../Sources/drivers/mcg/mcg.c **** 
 562:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PEE mode
 563:../Sources/drivers/mcg/mcg.c **** 
 564:../Sources/drivers/mcg/mcg.c ****     if
 565:../Sources/drivers/mcg/mcg.c ****     (
 566:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3)    // check CLKS mux has selct
 812              		.loc 1 566 0
 813 0000 4FF48043 		mov	r3, #16384
 814 0004 C4F20603 		movt	r3, 16390
 815 0008 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 816 000a C2F38101 		ubfx	r1, r2, #2, #2
 565:../Sources/drivers/mcg/mcg.c ****     (
 817              		.loc 1 565 0
 818 000e 0329     		cmp	r1, #3
 819 0010 01D0     		beq	.L157
 820              	.L147:
 567:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 568:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)
 569:../Sources/drivers/mcg/mcg.c ****         )
 570:../Sources/drivers/mcg/mcg.c ****     )               // check PLLS mux has selected PLL
 571:../Sources/drivers/mcg/mcg.c ****     {
 572:../Sources/drivers/mcg/mcg.c ****         return 0x8; // return error code
 821              		.loc 1 572 0
 822 0012 0820     		movs	r0, #8
 823              	.LVL102:
 573:../Sources/drivers/mcg/mcg.c ****     }
 574:../Sources/drivers/mcg/mcg.c **** 
 575:../Sources/drivers/mcg/mcg.c ****     // As we are running from the PLL by default the PLL and external clock settings are valid
 576:../Sources/drivers/mcg/mcg.c ****     // To move to PBE from PEE simply requires the switching of the CLKS mux to select the ext cloc
 577:../Sources/drivers/mcg/mcg.c ****     // As CLKS is already 0 the CLKS value can simply be OR'ed into the register
 578:../Sources/drivers/mcg/mcg.c **** 
 579:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(2);   // switch CLKS mux to select external reference clock as MCG_OUT
 580:../Sources/drivers/mcg/mcg.c **** 
 581:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
 582:../Sources/drivers/mcg/mcg.c **** 
 583:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 584:../Sources/drivers/mcg/mcg.c ****     {
 585:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out early i
 586:../Sources/drivers/mcg/mcg.c ****     }
 587:../Sources/drivers/mcg/mcg.c **** 
 588:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 589:../Sources/drivers/mcg/mcg.c **** 
 590:../Sources/drivers/mcg/mcg.c ****     // Now in PBE mode
 591:../Sources/drivers/mcg/mcg.c **** 
 592:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 593:../Sources/drivers/mcg/mcg.c **** }                       // pee_pbe
 824              		.loc 1 593 0
 825 0014 7047     		bx	lr
 826              	.LVL103:
 827              	.L157:
 567:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 828              		.loc 1 567 0
 829 0016 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 830 0018 02F01001 		and	r1, r2, #16
 831 001c CAB2     		uxtb	r2, r1
 832 001e 002A     		cmp	r2, #0
 833 0020 F7D1     		bne	.L147
 568:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)
 834              		.loc 1 568 0
 835 0022 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 566:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3)    // check CLKS mux has selct
 836              		.loc 1 566 0
 837 0024 01F02002 		and	r2, r1, #32
 838 0028 D1B2     		uxtb	r1, r2
 839 002a 0029     		cmp	r1, #0
 840 002c F1D0     		beq	.L147
 579:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(2);   // switch CLKS mux to select external reference clock as MCG_OUT
 841              		.loc 1 579 0
 842 002e 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 843 0030 42F08001 		orr	r1, r2, #128
 844 0034 1970     		strb	r1, [r3, #0]
 845              	.LVL104:
 846 0036 4FF4FA62 		mov	r2, #2000
 847 003a 07E0     		b	.L144
 848              	.LVL105:
 849              	.L158:
 585:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out early i
 850              		.loc 1 585 0
 851 003c 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 852 003e C1F38101 		ubfx	r1, r1, #2, #2
 853 0042 0229     		cmp	r1, #2
 854 0044 09D0     		beq	.L143
 855 0046 013A     		subs	r2, r2, #1
 856 0048 92B2     		uxth	r2, r2
 583:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 857              		.loc 1 583 0
 858 004a 32B1     		cbz	r2, .L143
 859              	.L144:
 585:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out early i
 860              		.loc 1 585 0
 861 004c 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 862 004e C1F38101 		ubfx	r1, r1, #2, #2
 863 0052 013A     		subs	r2, r2, #1
 864 0054 0229     		cmp	r1, #2
 865 0056 92B2     		uxth	r2, r2
 866 0058 F0D1     		bne	.L158
 867              	.L143:
 588:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 868              		.loc 1 588 0
 869 005a 4FF48043 		mov	r3, #16384
 870 005e C4F20603 		movt	r3, 16390
 871 0062 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 872 0064 C1F38102 		ubfx	r2, r1, #2, #2
 873 0068 022A     		cmp	r2, #2
 874 006a 18BF     		it	ne
 875 006c 1A20     		movne	r0, #26
 876              	.LVL106:
 877 006e 7047     		bx	lr
 878              		.cfi_endproc
 879              	.LFE2:
 881              		.section	.text.pbe_pee,"ax",%progbits
 882              		.align	2
 883              		.global	pbe_pee
 884              		.thumb
 885              		.thumb_func
 887              	pbe_pee:
 888              	.LFB3:
 594:../Sources/drivers/mcg/mcg.c **** 
 595:../Sources/drivers/mcg/mcg.c **** /* */
 596:../Sources/drivers/mcg/mcg.c **** 
 597:../Sources/drivers/mcg/mcg.c **** int pbe_pee
 598:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
 599:../Sources/drivers/mcg/mcg.c **** {
 889              		.loc 1 599 0
 890              		.cfi_startproc
 891              		@ args = 0, pretend = 0, frame = 0
 892              		@ frame_needed = 0, uses_anonymous_args = 0
 893              		@ link register save eliminated.
 894              	.LVL107:
 895 0000 30B4     		push	{r4, r5}
 896              	.LCFI2:
 897              		.cfi_def_cfa_offset 8
 898              		.cfi_offset 4, -8
 899              		.cfi_offset 5, -4
 600:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 601:../Sources/drivers/mcg/mcg.c **** 
 602:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 603:../Sources/drivers/mcg/mcg.c **** 
 604:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 605:../Sources/drivers/mcg/mcg.c **** 
 606:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 607:../Sources/drivers/mcg/mcg.c **** 
 608:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 609:../Sources/drivers/mcg/mcg.c **** 
 610:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 611:../Sources/drivers/mcg/mcg.c **** 
 612:../Sources/drivers/mcg/mcg.c ****     unsigned char   prdiv, vdiv;
 613:../Sources/drivers/mcg/mcg.c ****     short           i;
 614:../Sources/drivers/mcg/mcg.c **** 
 615:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 616:../Sources/drivers/mcg/mcg.c **** 
 617:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 618:../Sources/drivers/mcg/mcg.c **** 
 619:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 620:../Sources/drivers/mcg/mcg.c **** 
 621:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 622:../Sources/drivers/mcg/mcg.c **** 
 623:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 624:../Sources/drivers/mcg/mcg.c **** 
 625:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~*/
 626:../Sources/drivers/mcg/mcg.c **** 
 627:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PBE mode
 628:../Sources/drivers/mcg/mcg.c **** 
 629:../Sources/drivers/mcg/mcg.c ****     if
 630:../Sources/drivers/mcg/mcg.c ****     (
 631:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 900              		.loc 1 631 0
 901 0002 4FF48043 		mov	r3, #16384
 902 0006 C4F20603 		movt	r3, 16390
 903 000a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 904 000c C2F38101 		ubfx	r1, r2, #2, #2
 630:../Sources/drivers/mcg/mcg.c ****     (
 905              		.loc 1 630 0
 906 0010 0229     		cmp	r1, #2
 907 0012 02D0     		beq	.L181
 908              	.L168:
 632:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 633:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 634:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 635:../Sources/drivers/mcg/mcg.c ****         )
 636:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
 637:../Sources/drivers/mcg/mcg.c ****     {
 638:../Sources/drivers/mcg/mcg.c ****         return 0x7; // return error code
 909              		.loc 1 638 0
 910 0014 0720     		movs	r0, #7
 911              	.LVL108:
 912              	.L160:
 639:../Sources/drivers/mcg/mcg.c ****     }
 640:../Sources/drivers/mcg/mcg.c **** 
 641:../Sources/drivers/mcg/mcg.c ****     // As the PLL settings have already been checked when PBE mode was enterred they are not checke
 642:../Sources/drivers/mcg/mcg.c ****     // Check the PLL state before transitioning to PEE mode
 643:../Sources/drivers/mcg/mcg.c ****     // Check LOCK bit is set before transitioning MCG to PLL output (already checked in fbe_pbe but
 644:../Sources/drivers/mcg/mcg.c ****     // to re-check before switch to use PLL)
 645:../Sources/drivers/mcg/mcg.c **** 
 646:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 647:../Sources/drivers/mcg/mcg.c ****     {
 648:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 649:../Sources/drivers/mcg/mcg.c ****     }
 650:../Sources/drivers/mcg/mcg.c **** 
 651:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 652:../Sources/drivers/mcg/mcg.c **** 
 653:../Sources/drivers/mcg/mcg.c ****     // Use actual PLL settings to calculate PLL frequency
 654:../Sources/drivers/mcg/mcg.c **** 
 655:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 656:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 657:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 658:../Sources/drivers/mcg/mcg.c **** 
 659:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
 660:../Sources/drivers/mcg/mcg.c **** 
 661:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 662:../Sources/drivers/mcg/mcg.c ****     {
 663:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break;     // jump out early i
 664:../Sources/drivers/mcg/mcg.c ****     }
 665:../Sources/drivers/mcg/mcg.c **** 
 666:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B;   // check CLKST is s
 667:../Sources/drivers/mcg/mcg.c **** 
 668:../Sources/drivers/mcg/mcg.c ****     // Now in PEE
 669:../Sources/drivers/mcg/mcg.c **** 
 670:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 671:../Sources/drivers/mcg/mcg.c **** }   // pbe_pee
 913              		.loc 1 671 0
 914 0016 30BC     		pop	{r4, r5}
 915 0018 7047     		bx	lr
 916              	.LVL109:
 917              	.L181:
 632:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 918              		.loc 1 632 0
 919 001a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 920 001c 02F01001 		and	r1, r2, #16
 921 0020 CAB2     		uxtb	r2, r1
 922 0022 002A     		cmp	r2, #0
 923 0024 F6D1     		bne	.L168
 633:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 924              		.loc 1 633 0
 925 0026 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 926 0028 01F02002 		and	r2, r1, #32
 927 002c D1B2     		uxtb	r1, r2
 928 002e 0029     		cmp	r1, #0
 929 0030 F0D0     		beq	.L168
 634:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 930              		.loc 1 634 0
 931 0032 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 631:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 932              		.loc 1 631 0
 933 0034 02F00201 		and	r1, r2, #2
 934 0038 CAB2     		uxtb	r2, r1
 935 003a 002A     		cmp	r2, #0
 936 003c EAD1     		bne	.L168
 937 003e 4FF4FA62 		mov	r2, #2000
 938 0042 08E0     		b	.L162
 939              	.LVL110:
 940              	.L182:
 648:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 941              		.loc 1 648 0
 942 0044 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 943 0046 92B2     		uxth	r2, r2
 944 0048 01F04001 		and	r1, r1, #64
 945 004c 013A     		subs	r2, r2, #1
 946 004e C9B2     		uxtb	r1, r1
 947 0050 92B2     		uxth	r2, r2
 948 0052 39B9     		cbnz	r1, .L161
 646:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 949              		.loc 1 646 0
 950 0054 32B1     		cbz	r2, .L161
 951              	.L162:
 648:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 952              		.loc 1 648 0
 953 0056 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 954 0058 01F04001 		and	r1, r1, #64
 955 005c C9B2     		uxtb	r1, r1
 956 005e 013A     		subs	r2, r2, #1
 957 0060 0029     		cmp	r1, #0
 958 0062 EFD0     		beq	.L182
 959              	.L161:
 651:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 960              		.loc 1 651 0
 961 0064 4FF48042 		mov	r2, #16384
 962 0068 C4F20602 		movt	r2, 16390
 963 006c 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 964 006e 03F04001 		and	r1, r3, #64
 965 0072 CBB2     		uxtb	r3, r1
 966 0074 0BB9     		cbnz	r3, .L183
 967 0076 4420     		movs	r0, #68
 968              	.LVL111:
 969 0078 CDE7     		b	.L160
 970              	.LVL112:
 971              	.L183:
 655:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 972              		.loc 1 655 0
 973 007a 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 656:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 974              		.loc 1 656 0
 975 007c 5579     		ldrb	r5, [r2, #5]	@ zero_extendqisi2
 657:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;                    // clear CLKS to switch CLKS mux to select PLL 
 976              		.loc 1 657 0
 977 007e 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 978 0080 01F03F03 		and	r3, r1, #63
 979              	.LVL113:
 980 0084 1370     		strb	r3, [r2, #0]
 981              	.LVL114:
 982 0086 4FF4FA63 		mov	r3, #2000
 983 008a 07E0     		b	.L164
 984              	.LVL115:
 985              	.L184:
 663:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break;     // jump out early i
 986              		.loc 1 663 0
 987 008c 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 988 008e C1F38101 		ubfx	r1, r1, #2, #2
 989 0092 0329     		cmp	r1, #3
 990 0094 09D0     		beq	.L163
 991 0096 013B     		subs	r3, r3, #1
 992 0098 9BB2     		uxth	r3, r3
 661:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 993              		.loc 1 661 0
 994 009a 33B1     		cbz	r3, .L163
 995              	.L164:
 663:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break;     // jump out early i
 996              		.loc 1 663 0
 997 009c 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 998 009e C1F38101 		ubfx	r1, r1, #2, #2
 999 00a2 013B     		subs	r3, r3, #1
 1000 00a4 0329     		cmp	r1, #3
 1001 00a6 9BB2     		uxth	r3, r3
 1002 00a8 F0D1     		bne	.L184
 1003              	.L163:
 666:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B;   // check CLKST is s
 1004              		.loc 1 666 0
 1005 00aa 4FF48042 		mov	r2, #16384
 1006 00ae C4F20602 		movt	r2, 16390
 1007 00b2 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1008 00b4 C1F38103 		ubfx	r3, r1, #2, #2
 1009 00b8 032B     		cmp	r3, #3
 1010 00ba 01D0     		beq	.L185
 1011 00bc 1B20     		movs	r0, #27
 1012              	.LVL116:
 1013 00be AAE7     		b	.L160
 1014              	.LVL117:
 1015              	.L185:
 655:../Sources/drivers/mcg/mcg.c ****     prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 1016              		.loc 1 655 0
 1017 00c0 04F01F02 		and	r2, r4, #31
 670:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 1018              		.loc 1 670 0
 1019 00c4 511C     		adds	r1, r2, #1
 656:../Sources/drivers/mcg/mcg.c ****     vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 1020              		.loc 1 656 0
 1021 00c6 05F01F03 		and	r3, r5, #31
 670:../Sources/drivers/mcg/mcg.c ****     return((crystal_val / prdiv) * vdiv);   //MCGOUT equals PLL output frequency
 1022              		.loc 1 670 0
 1023 00ca 90FBF1F0 		sdiv	r0, r0, r1
 1024              	.LVL118:
 1025 00ce 1833     		adds	r3, r3, #24
 1026 00d0 03FB00F0 		mul	r0, r3, r0
 1027 00d4 9FE7     		b	.L160
 1028              		.cfi_endproc
 1029              	.LFE3:
 1031 00d6 00BF     		.section	.text.pbe_fbe,"ax",%progbits
 1032              		.align	2
 1033              		.global	pbe_fbe
 1034              		.thumb
 1035              		.thumb_func
 1037              	pbe_fbe:
 1038              	.LFB4:
 672:../Sources/drivers/mcg/mcg.c **** 
 673:../Sources/drivers/mcg/mcg.c **** /* */
 674:../Sources/drivers/mcg/mcg.c **** 
 675:../Sources/drivers/mcg/mcg.c **** int pbe_fbe
 676:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
 677:../Sources/drivers/mcg/mcg.c **** {
 1039              		.loc 1 677 0
 1040              		.cfi_startproc
 1041              		@ args = 0, pretend = 0, frame = 0
 1042              		@ frame_needed = 0, uses_anonymous_args = 0
 1043              		@ link register save eliminated.
 1044              	.LVL119:
 678:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 679:../Sources/drivers/mcg/mcg.c **** 
 680:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 681:../Sources/drivers/mcg/mcg.c **** 
 682:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 683:../Sources/drivers/mcg/mcg.c **** 
 684:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 685:../Sources/drivers/mcg/mcg.c **** 
 686:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 687:../Sources/drivers/mcg/mcg.c **** 
 688:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 689:../Sources/drivers/mcg/mcg.c **** 
 690:../Sources/drivers/mcg/mcg.c ****     short   i;
 691:../Sources/drivers/mcg/mcg.c **** 
 692:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 693:../Sources/drivers/mcg/mcg.c **** 
 694:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 695:../Sources/drivers/mcg/mcg.c **** 
 696:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 697:../Sources/drivers/mcg/mcg.c **** 
 698:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 699:../Sources/drivers/mcg/mcg.c **** 
 700:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 701:../Sources/drivers/mcg/mcg.c **** 
 702:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
 703:../Sources/drivers/mcg/mcg.c **** 
 704:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PBE mode
 705:../Sources/drivers/mcg/mcg.c **** 
 706:../Sources/drivers/mcg/mcg.c ****     if
 707:../Sources/drivers/mcg/mcg.c ****     (
 708:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1045              		.loc 1 708 0
 1046 0000 4FF48043 		mov	r3, #16384
 1047 0004 C4F20603 		movt	r3, 16390
 1048 0008 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1049 000a C2F38101 		ubfx	r1, r2, #2, #2
 707:../Sources/drivers/mcg/mcg.c ****     (
 1050              		.loc 1 707 0
 1051 000e 0229     		cmp	r1, #2
 1052 0010 01D0     		beq	.L203
 1053              	.L193:
 709:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 710:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 711:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 712:../Sources/drivers/mcg/mcg.c ****         )
 713:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
 714:../Sources/drivers/mcg/mcg.c ****     {
 715:../Sources/drivers/mcg/mcg.c ****         return 0x7; // return error code
 1054              		.loc 1 715 0
 1055 0012 0720     		movs	r0, #7
 1056              	.LVL120:
 716:../Sources/drivers/mcg/mcg.c ****     }
 717:../Sources/drivers/mcg/mcg.c **** 
 718:../Sources/drivers/mcg/mcg.c ****     // As we are running from the ext clock, by default the external clock settings are valid
 719:../Sources/drivers/mcg/mcg.c ****     // To move to FBE from PBE simply requires the switching of the PLLS mux to disable the PLL
 720:../Sources/drivers/mcg/mcg.c **** 
 721:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_PLLS_MASK;                // clear PLLS to disable PLL, still clocked from ex
 722:../Sources/drivers/mcg/mcg.c **** 
 723:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to set
 724:../Sources/drivers/mcg/mcg.c **** 
 725:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 726:../Sources/drivers/mcg/mcg.c ****     {
 727:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_PLLST_MASK)) break;  // jump out early if PLLST clears before loop finis
 728:../Sources/drivers/mcg/mcg.c ****     }
 729:../Sources/drivers/mcg/mcg.c **** 
 730:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_PLLST_MASK) return 0x15;   // check bit is really clear and return with error 
 731:../Sources/drivers/mcg/mcg.c **** 
 732:../Sources/drivers/mcg/mcg.c ****     // Now in FBE mode
 733:../Sources/drivers/mcg/mcg.c **** 
 734:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 735:../Sources/drivers/mcg/mcg.c **** }                       // pbe_fbe
 1057              		.loc 1 735 0
 1058 0014 7047     		bx	lr
 1059              	.LVL121:
 1060              	.L203:
 709:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1061              		.loc 1 709 0
 1062 0016 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1063 0018 02F01001 		and	r1, r2, #16
 1064 001c CAB2     		uxtb	r2, r1
 1065 001e 002A     		cmp	r2, #0
 1066 0020 F7D1     		bne	.L193
 710:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 1067              		.loc 1 710 0
 1068 0022 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1069 0024 01F02002 		and	r2, r1, #32
 1070 0028 D1B2     		uxtb	r1, r2
 1071 002a 0029     		cmp	r1, #0
 1072 002c F1D0     		beq	.L193
 711:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 1073              		.loc 1 711 0
 1074 002e 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 708:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1075              		.loc 1 708 0
 1076 0030 02F00201 		and	r1, r2, #2
 1077 0034 CAB2     		uxtb	r2, r1
 1078 0036 002A     		cmp	r2, #0
 1079 0038 EBD1     		bne	.L193
 721:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_PLLS_MASK;                // clear PLLS to disable PLL, still clocked from ex
 1080              		.loc 1 721 0
 1081 003a 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 1082 003c 01F0BF02 		and	r2, r1, #191
 1083 0040 5A71     		strb	r2, [r3, #5]
 1084              	.LVL122:
 1085 0042 4FF4FA62 		mov	r2, #2000
 1086 0046 08E0     		b	.L189
 1087              	.LVL123:
 1088              	.L204:
 727:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_PLLST_MASK)) break;  // jump out early if PLLST clears before loop finis
 1089              		.loc 1 727 0
 1090 0048 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1091 004a 92B2     		uxth	r2, r2
 1092 004c 01F02001 		and	r1, r1, #32
 1093 0050 013A     		subs	r2, r2, #1
 1094 0052 C9B2     		uxtb	r1, r1
 1095 0054 92B2     		uxth	r2, r2
 1096 0056 39B1     		cbz	r1, .L188
 725:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1097              		.loc 1 725 0
 1098 0058 32B1     		cbz	r2, .L188
 1099              	.L189:
 727:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_PLLST_MASK)) break;  // jump out early if PLLST clears before loop finis
 1100              		.loc 1 727 0
 1101 005a 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1102 005c 01F02001 		and	r1, r1, #32
 1103 0060 C9B2     		uxtb	r1, r1
 1104 0062 013A     		subs	r2, r2, #1
 1105 0064 0029     		cmp	r1, #0
 1106 0066 EFD1     		bne	.L204
 1107              	.L188:
 730:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_PLLST_MASK) return 0x15;   // check bit is really clear and return with error 
 1108              		.loc 1 730 0
 1109 0068 4FF48043 		mov	r3, #16384
 1110 006c C4F20603 		movt	r3, 16390
 1111 0070 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1112 0072 01F02002 		and	r2, r1, #32
 1113 0076 D3B2     		uxtb	r3, r2
 1114 0078 002B     		cmp	r3, #0
 1115 007a 18BF     		it	ne
 1116 007c 1520     		movne	r0, #21
 1117              	.LVL124:
 1118 007e 7047     		bx	lr
 1119              		.cfi_endproc
 1120              	.LFE4:
 1122              		.section	.text.fbe_pbe,"ax",%progbits
 1123              		.align	2
 1124              		.global	fbe_pbe
 1125              		.thumb
 1126              		.thumb_func
 1128              	fbe_pbe:
 1129              	.LFB5:
 736:../Sources/drivers/mcg/mcg.c **** 
 737:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
 738:../Sources/drivers/mcg/mcg.c **** 
 739:../Sources/drivers/mcg/mcg.c **** /* Functon name : fbe_pbe
 740:../Sources/drivers/mcg/mcg.c ****  *
 741:../Sources/drivers/mcg/mcg.c ****  * Mode transition: FBE to PBE mode
 742:../Sources/drivers/mcg/mcg.c ****  *
 743:../Sources/drivers/mcg/mcg.c ****  * This function transitions the MCG from FBE mode to PBE mode.
 744:../Sources/drivers/mcg/mcg.c ****  * This function presently only supports OSC0 and PLL0. Support for OSC1 and PLL1 will be added soo
 745:../Sources/drivers/mcg/mcg.c ****  * The function requires the desired OSC and PLL be passed in to it for compatibility with the
 746:../Sources/drivers/mcg/mcg.c ****  * future support of OSC/PLL selection
 747:../Sources/drivers/mcg/mcg.c ****  *
 748:../Sources/drivers/mcg/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
 749:../Sources/drivers/mcg/mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 750:../Sources/drivers/mcg/mcg.c ****  *                           PLL reference clock frequency
 751:../Sources/drivers/mcg/mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 752:../Sources/drivers/mcg/mcg.c ****  *
 753:../Sources/drivers/mcg/mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
 754:../Sources/drivers/mcg/mcg.c ****  */
 755:../Sources/drivers/mcg/mcg.c **** 
 756:../Sources/drivers/mcg/mcg.c **** int fbe_pbe
 757:../Sources/drivers/mcg/mcg.c **** (
 758:../Sources/drivers/mcg/mcg.c ****     int         crystal_val,
 759:../Sources/drivers/mcg/mcg.c ****     signed char prdiv_val,
 760:../Sources/drivers/mcg/mcg.c ****     signed char vdiv_val
 761:../Sources/drivers/mcg/mcg.c **** )
 762:../Sources/drivers/mcg/mcg.c **** {
 1130              		.loc 1 762 0
 1131              		.cfi_startproc
 1132              		@ args = 0, pretend = 0, frame = 0
 1133              		@ frame_needed = 0, uses_anonymous_args = 0
 1134              		@ link register save eliminated.
 1135              	.LVL125:
 1136 0000 F0B4     		push	{r4, r5, r6, r7}
 1137              	.LCFI3:
 1138              		.cfi_def_cfa_offset 16
 1139              		.cfi_offset 4, -16
 1140              		.cfi_offset 5, -12
 1141              		.cfi_offset 6, -8
 1142              		.cfi_offset 7, -4
 763:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 764:../Sources/drivers/mcg/mcg.c **** 
 765:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 766:../Sources/drivers/mcg/mcg.c **** 
 767:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 768:../Sources/drivers/mcg/mcg.c **** 
 769:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 770:../Sources/drivers/mcg/mcg.c **** 
 771:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 772:../Sources/drivers/mcg/mcg.c **** 
 773:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 774:../Sources/drivers/mcg/mcg.c **** 
 775:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
 776:../Sources/drivers/mcg/mcg.c ****     short           i;
 777:../Sources/drivers/mcg/mcg.c ****     int             pll_freq;
 778:../Sources/drivers/mcg/mcg.c **** 
 779:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 780:../Sources/drivers/mcg/mcg.c **** 
 781:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 782:../Sources/drivers/mcg/mcg.c **** 
 783:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 784:../Sources/drivers/mcg/mcg.c **** 
 785:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 786:../Sources/drivers/mcg/mcg.c **** 
 787:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 788:../Sources/drivers/mcg/mcg.c **** 
 789:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 790:../Sources/drivers/mcg/mcg.c **** 
 791:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
 792:../Sources/drivers/mcg/mcg.c **** 
 793:../Sources/drivers/mcg/mcg.c ****     if
 794:../Sources/drivers/mcg/mcg.c ****     (
 795:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1143              		.loc 1 795 0
 1144 0002 4FF48043 		mov	r3, #16384
 1145 0006 C4F20603 		movt	r3, 16390
 1146 000a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 1147 000c C4F38104 		ubfx	r4, r4, #2, #2
 794:../Sources/drivers/mcg/mcg.c ****     (
 1148              		.loc 1 794 0
 1149 0010 022C     		cmp	r4, #2
 1150 0012 02D0     		beq	.L224
 1151              	.L214:
 796:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 797:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 798:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 799:../Sources/drivers/mcg/mcg.c ****         )
 800:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
 801:../Sources/drivers/mcg/mcg.c ****     {
 802:../Sources/drivers/mcg/mcg.c ****         return 0x4; // return error code
 1152              		.loc 1 802 0
 1153 0014 0420     		movs	r0, #4
 1154              	.LVL126:
 1155              	.L206:
 803:../Sources/drivers/mcg/mcg.c ****     }
 804:../Sources/drivers/mcg/mcg.c **** 
 805:../Sources/drivers/mcg/mcg.c ****     // As the external frequency has already been checked when FBE mode was enterred it is not chec
 806:../Sources/drivers/mcg/mcg.c ****     // Check PLL divider settings are within spec.
 807:../Sources/drivers/mcg/mcg.c **** 
 808:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 809:../Sources/drivers/mcg/mcg.c ****     {
 810:../Sources/drivers/mcg/mcg.c ****         return 0x41;
 811:../Sources/drivers/mcg/mcg.c ****     }
 812:../Sources/drivers/mcg/mcg.c **** 
 813:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 814:../Sources/drivers/mcg/mcg.c ****     {
 815:../Sources/drivers/mcg/mcg.c ****         return 0x42;
 816:../Sources/drivers/mcg/mcg.c ****     }
 817:../Sources/drivers/mcg/mcg.c **** 
 818:../Sources/drivers/mcg/mcg.c ****     // Check PLL reference clock frequency is within spec.
 819:../Sources/drivers/mcg/mcg.c **** 
 820:../Sources/drivers/mcg/mcg.c ****     if(((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000))
 821:../Sources/drivers/mcg/mcg.c ****     {
 822:../Sources/drivers/mcg/mcg.c ****         return 0x43;
 823:../Sources/drivers/mcg/mcg.c ****     }
 824:../Sources/drivers/mcg/mcg.c **** 
 825:../Sources/drivers/mcg/mcg.c ****     // Check PLL output frequency is within spec.
 826:../Sources/drivers/mcg/mcg.c **** 
 827:../Sources/drivers/mcg/mcg.c ****     pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 828:../Sources/drivers/mcg/mcg.c **** 
 829:../Sources/drivers/mcg/mcg.c ****     if((pll_freq < 48000000) || (pll_freq > 100000000))
 830:../Sources/drivers/mcg/mcg.c ****     {
 831:../Sources/drivers/mcg/mcg.c ****         return 0x45;
 832:../Sources/drivers/mcg/mcg.c ****     }
 833:../Sources/drivers/mcg/mcg.c **** 
 834:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C5
 835:../Sources/drivers/mcg/mcg.c ****     // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user 
 836:../Sources/drivers/mcg/mcg.c **** 
 837:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 838:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 839:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 840:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 841:../Sources/drivers/mcg/mcg.c **** 
 842:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C6
 843:../Sources/drivers/mcg/mcg.c ****     // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 844:../Sources/drivers/mcg/mcg.c ****     // The clock monitor is not enabled here as it has likely been enabled previously and so the va
 845:../Sources/drivers/mcg/mcg.c ****     // is not altered here.
 846:../Sources/drivers/mcg/mcg.c ****     // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 847:../Sources/drivers/mcg/mcg.c **** 
 848:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 849:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 850:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 851:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 852:../Sources/drivers/mcg/mcg.c **** 
 853:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to set
 854:../Sources/drivers/mcg/mcg.c **** 
 855:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 856:../Sources/drivers/mcg/mcg.c ****     {
 857:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 858:../Sources/drivers/mcg/mcg.c ****     }
 859:../Sources/drivers/mcg/mcg.c **** 
 860:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 861:../Sources/drivers/mcg/mcg.c **** 
 862:../Sources/drivers/mcg/mcg.c ****     // Wait for LOCK bit to set
 863:../Sources/drivers/mcg/mcg.c **** 
 864:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 865:../Sources/drivers/mcg/mcg.c ****     {
 866:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 867:../Sources/drivers/mcg/mcg.c ****     }
 868:../Sources/drivers/mcg/mcg.c **** 
 869:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 870:../Sources/drivers/mcg/mcg.c **** 
 871:../Sources/drivers/mcg/mcg.c ****     // now in PBE
 872:../Sources/drivers/mcg/mcg.c **** 
 873:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 874:../Sources/drivers/mcg/mcg.c **** }                       // fbe_pbe
 1156              		.loc 1 874 0
 1157 0016 F0BC     		pop	{r4, r5, r6, r7}
 1158 0018 7047     		bx	lr
 1159              	.LVL127:
 1160              	.L224:
 796:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1161              		.loc 1 796 0
 1162 001a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 1163 001c 04F01004 		and	r4, r4, #16
 1164 0020 E4B2     		uxtb	r4, r4
 1165 0022 002C     		cmp	r4, #0
 1166 0024 F6D1     		bne	.L214
 797:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 1167              		.loc 1 797 0
 1168 0026 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 1169 0028 04F02004 		and	r4, r4, #32
 1170 002c E4B2     		uxtb	r4, r4
 1171 002e 002C     		cmp	r4, #0
 1172 0030 F0D1     		bne	.L214
 798:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 1173              		.loc 1 798 0
 1174 0032 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 795:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1175              		.loc 1 795 0
 1176 0034 04F00204 		and	r4, r4, #2
 1177 0038 E4B2     		uxtb	r4, r4
 1178 003a 002C     		cmp	r4, #0
 1179 003c EAD1     		bne	.L214
 808:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 1180              		.loc 1 808 0
 1181 003e 4C1E     		subs	r4, r1, #1
 1182 0040 E4B2     		uxtb	r4, r4
 1183 0042 182C     		cmp	r4, #24
 1184 0044 01D9     		bls	.L225
 810:../Sources/drivers/mcg/mcg.c ****         return 0x41;
 1185              		.loc 1 810 0
 1186 0046 4120     		movs	r0, #65
 1187              	.LVL128:
 1188 0048 E5E7     		b	.L206
 1189              	.LVL129:
 1190              	.L225:
 813:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 1191              		.loc 1 813 0
 1192 004a A2F11805 		sub	r5, r2, #24
 1193 004e EDB2     		uxtb	r5, r5
 1194 0050 1A2D     		cmp	r5, #26
 1195 0052 01D9     		bls	.L226
 815:../Sources/drivers/mcg/mcg.c ****         return 0x42;
 1196              		.loc 1 815 0
 1197 0054 4220     		movs	r0, #66
 1198              	.LVL130:
 1199 0056 DEE7     		b	.L206
 1200              	.LVL131:
 1201              	.L226:
 820:../Sources/drivers/mcg/mcg.c ****     if(((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000))
 1202              		.loc 1 820 0
 1203 0058 90FBF1F1 		sdiv	r1, r0, r1
 1204              	.LVL132:
 1205 005c A1F5F417 		sub	r7, r1, #1998848
 1206 0060 48F28046 		movw	r6, #33920
 1207 0064 A7F59067 		sub	r7, r7, #1152
 1208 0068 C0F21E06 		movt	r6, 30
 1209 006c B742     		cmp	r7, r6
 1210 006e 01D9     		bls	.L227
 822:../Sources/drivers/mcg/mcg.c ****         return 0x43;
 1211              		.loc 1 822 0
 1212 0070 4320     		movs	r0, #67
 1213              	.LVL133:
 1214 0072 D0E7     		b	.L206
 1215              	.LVL134:
 1216              	.L227:
 827:../Sources/drivers/mcg/mcg.c ****     pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 1217              		.loc 1 827 0
 1218 0074 02FB01F1 		mul	r1, r2, r1
 1219              	.LVL135:
 829:../Sources/drivers/mcg/mcg.c ****     if((pll_freq < 48000000) || (pll_freq > 100000000))
 1220              		.loc 1 829 0
 1221 0078 A1F13771 		sub	r1, r1, #47972352
 1222 007c 4FF4EA42 		mov	r2, #29952
 1223              	.LVL136:
 1224 0080 A1F5D841 		sub	r1, r1, #27648
 1225 0084 C0F21932 		movt	r2, 793
 1226 0088 9142     		cmp	r1, r2
 1227 008a 01D9     		bls	.L228
 831:../Sources/drivers/mcg/mcg.c ****         return 0x45;
 1228              		.loc 1 831 0
 1229 008c 4520     		movs	r0, #69
 1230              	.LVL137:
 1231 008e C2E7     		b	.L206
 1232              	.LVL138:
 1233              	.L228:
 837:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 1234              		.loc 1 837 0
 1235 0090 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1236              	.LVL139:
 838:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 1237              		.loc 1 838 0
 1238 0092 02F0E001 		and	r1, r2, #224
 1239              	.LVL140:
 839:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 1240              		.loc 1 839 0
 1241 0096 0C43     		orrs	r4, r4, r1
 1242              	.LVL141:
 840:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 1243              		.loc 1 840 0
 1244 0098 1C71     		strb	r4, [r3, #4]
 848:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 1245              		.loc 1 848 0
 1246 009a 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 1247              	.LVL142:
 849:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 1248              		.loc 1 849 0
 1249 009c 02F0E001 		and	r1, r2, #224
 850:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1250              		.loc 1 850 0
 1251 00a0 41F04002 		orr	r2, r1, #64
 1252              	.LVL143:
 1253 00a4 1543     		orrs	r5, r5, r2
 1254              	.LVL144:
 851:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 1255              		.loc 1 851 0
 1256 00a6 5D71     		strb	r5, [r3, #5]
 1257              	.LVL145:
 1258 00a8 4FF4FA62 		mov	r2, #2000
 1259 00ac 08E0     		b	.L208
 1260              	.LVL146:
 1261              	.L229:
 857:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1262              		.loc 1 857 0
 1263 00ae 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1264 00b0 92B2     		uxth	r2, r2
 1265 00b2 01F02001 		and	r1, r1, #32
 1266 00b6 013A     		subs	r2, r2, #1
 1267 00b8 C9B2     		uxtb	r1, r1
 1268 00ba 92B2     		uxth	r2, r2
 1269 00bc 39B9     		cbnz	r1, .L207
 855:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1270              		.loc 1 855 0
 1271 00be 32B1     		cbz	r2, .L207
 1272              	.L208:
 857:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1273              		.loc 1 857 0
 1274 00c0 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1275 00c2 01F02001 		and	r1, r1, #32
 1276 00c6 C9B2     		uxtb	r1, r1
 1277 00c8 013A     		subs	r2, r2, #1
 1278 00ca 0029     		cmp	r1, #0
 1279 00cc EFD0     		beq	.L229
 1280              	.L207:
 860:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 1281              		.loc 1 860 0
 1282 00ce 4FF48043 		mov	r3, #16384
 1283 00d2 C4F20603 		movt	r3, 16390
 1284 00d6 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1285 00d8 01F02002 		and	r2, r1, #32
 1286 00dc D1B2     		uxtb	r1, r2
 1287 00de 09B9     		cbnz	r1, .L230
 1288 00e0 1620     		movs	r0, #22
 1289              	.LVL147:
 1290 00e2 98E7     		b	.L206
 1291              	.LVL148:
 1292              	.L230:
 1293 00e4 4FF4FA62 		mov	r2, #2000
 1294 00e8 00E0     		b	.L210
 1295              	.L231:
 864:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1296              		.loc 1 864 0
 1297 00ea 3AB1     		cbz	r2, .L209
 1298              	.L210:
 866:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 1299              		.loc 1 866 0
 1300 00ec 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1301 00ee 01F04001 		and	r1, r1, #64
 1302 00f2 013A     		subs	r2, r2, #1
 1303 00f4 C9B2     		uxtb	r1, r1
 1304 00f6 92B2     		uxth	r2, r2
 1305 00f8 0029     		cmp	r1, #0
 1306 00fa F6D0     		beq	.L231
 1307              	.L209:
 869:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 1308              		.loc 1 869 0
 1309 00fc 4FF48043 		mov	r3, #16384
 1310 0100 C4F20603 		movt	r3, 16390
 1311 0104 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1312 0106 01F04002 		and	r2, r1, #64
 1313 010a D3B2     		uxtb	r3, r2
 1314 010c 002B     		cmp	r3, #0
 1315 010e 08BF     		it	eq
 1316 0110 4420     		moveq	r0, #68
 1317              	.LVL149:
 1318 0112 80E7     		b	.L206
 1319              		.cfi_endproc
 1320              	.LFE5:
 1322              		.section	.text.pbe_blpe,"ax",%progbits
 1323              		.align	2
 1324              		.global	pbe_blpe
 1325              		.thumb
 1326              		.thumb_func
 1328              	pbe_blpe:
 1329              	.LFB6:
 875:../Sources/drivers/mcg/mcg.c **** 
 876:../Sources/drivers/mcg/mcg.c **** /* */
 877:../Sources/drivers/mcg/mcg.c **** 
 878:../Sources/drivers/mcg/mcg.c **** int pbe_blpe
 879:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
 880:../Sources/drivers/mcg/mcg.c **** {
 1330              		.loc 1 880 0
 1331              		.cfi_startproc
 1332              		@ args = 0, pretend = 0, frame = 0
 1333              		@ frame_needed = 0, uses_anonymous_args = 0
 1334              		@ link register save eliminated.
 1335              	.LVL150:
 881:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PBE mode
 882:../Sources/drivers/mcg/mcg.c **** 
 883:../Sources/drivers/mcg/mcg.c ****     if
 884:../Sources/drivers/mcg/mcg.c ****     (
 885:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1336              		.loc 1 885 0
 1337 0000 4FF48043 		mov	r3, #16384
 1338 0004 C4F20603 		movt	r3, 16390
 1339 0008 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1340 000a C2F38101 		ubfx	r1, r2, #2, #2
 884:../Sources/drivers/mcg/mcg.c ****     (
 1341              		.loc 1 884 0
 1342 000e 0229     		cmp	r1, #2
 1343 0010 01D0     		beq	.L238
 1344              	.L237:
 886:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 887:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 888:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 889:../Sources/drivers/mcg/mcg.c ****         )
 890:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
 891:../Sources/drivers/mcg/mcg.c ****     {
 892:../Sources/drivers/mcg/mcg.c ****         return 0x7; // return error code
 1345              		.loc 1 892 0
 1346 0012 0720     		movs	r0, #7
 1347              	.LVL151:
 893:../Sources/drivers/mcg/mcg.c ****     }
 894:../Sources/drivers/mcg/mcg.c **** 
 895:../Sources/drivers/mcg/mcg.c ****     // To enter BLPE mode the LP bit must be set, disabling the PLL
 896:../Sources/drivers/mcg/mcg.c **** 
 897:../Sources/drivers/mcg/mcg.c ****     MCG_C2 |= MCG_C2_LP_MASK;
 898:../Sources/drivers/mcg/mcg.c **** 
 899:../Sources/drivers/mcg/mcg.c ****     // Now in BLPE mode
 900:../Sources/drivers/mcg/mcg.c **** 
 901:../Sources/drivers/mcg/mcg.c ****     return crystal_val;
 902:../Sources/drivers/mcg/mcg.c **** }                   // pbe_blpe
 1348              		.loc 1 902 0
 1349 0014 7047     		bx	lr
 1350              	.LVL152:
 1351              	.L238:
 886:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1352              		.loc 1 886 0
 1353 0016 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1354 0018 02F01001 		and	r1, r2, #16
 1355 001c CAB2     		uxtb	r2, r1
 1356 001e 002A     		cmp	r2, #0
 1357 0020 F7D1     		bne	.L237
 887:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 1358              		.loc 1 887 0
 1359 0022 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1360 0024 01F02002 		and	r2, r1, #32
 1361 0028 D1B2     		uxtb	r1, r2
 1362 002a 0029     		cmp	r1, #0
 1363 002c F1D0     		beq	.L237
 888:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 1364              		.loc 1 888 0
 1365 002e 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 885:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1366              		.loc 1 885 0
 1367 0030 02F00201 		and	r1, r2, #2
 1368 0034 CAB2     		uxtb	r2, r1
 1369 0036 002A     		cmp	r2, #0
 1370 0038 EBD1     		bne	.L237
 897:../Sources/drivers/mcg/mcg.c ****     MCG_C2 |= MCG_C2_LP_MASK;
 1371              		.loc 1 897 0
 1372 003a 5978     		ldrb	r1, [r3, #1]	@ zero_extendqisi2
 1373 003c 41F00202 		orr	r2, r1, #2
 1374 0040 5A70     		strb	r2, [r3, #1]
 901:../Sources/drivers/mcg/mcg.c ****     return crystal_val;
 1375              		.loc 1 901 0
 1376 0042 7047     		bx	lr
 1377              		.cfi_endproc
 1378              	.LFE6:
 1380              		.section	.text.blpe_pbe,"ax",%progbits
 1381              		.align	2
 1382              		.global	blpe_pbe
 1383              		.thumb
 1384              		.thumb_func
 1386              	blpe_pbe:
 1387              	.LFB7:
 903:../Sources/drivers/mcg/mcg.c **** 
 904:../Sources/drivers/mcg/mcg.c **** // ************************************************************************************************
 905:../Sources/drivers/mcg/mcg.c **** // Since PBE mode can be enterred via FBE -> BLPE modes, it cannot be assumed that the PLL has been
 906:../Sources/drivers/mcg/mcg.c **** // previously configured correctly. That is why this general purpose driver has the PLL settings as
 907:../Sources/drivers/mcg/mcg.c **** // passed parameters.
 908:../Sources/drivers/mcg/mcg.c **** 
 909:../Sources/drivers/mcg/mcg.c **** // ************************************************************************************************
 910:../Sources/drivers/mcg/mcg.c **** 
 911:../Sources/drivers/mcg/mcg.c **** int blpe_pbe
 912:../Sources/drivers/mcg/mcg.c **** (
 913:../Sources/drivers/mcg/mcg.c ****     int         crystal_val,
 914:../Sources/drivers/mcg/mcg.c ****     signed char prdiv_val,
 915:../Sources/drivers/mcg/mcg.c ****     signed char vdiv_val
 916:../Sources/drivers/mcg/mcg.c **** )
 917:../Sources/drivers/mcg/mcg.c **** {
 1388              		.loc 1 917 0
 1389              		.cfi_startproc
 1390              		@ args = 0, pretend = 0, frame = 0
 1391              		@ frame_needed = 0, uses_anonymous_args = 0
 1392              		@ link register save eliminated.
 1393              	.LVL153:
 1394 0000 30B4     		push	{r4, r5}
 1395              	.LCFI4:
 1396              		.cfi_def_cfa_offset 8
 1397              		.cfi_offset 4, -8
 1398              		.cfi_offset 5, -4
 918:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 919:../Sources/drivers/mcg/mcg.c **** 
 920:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 921:../Sources/drivers/mcg/mcg.c **** 
 922:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 923:../Sources/drivers/mcg/mcg.c **** 
 924:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 925:../Sources/drivers/mcg/mcg.c **** 
 926:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 927:../Sources/drivers/mcg/mcg.c **** 
 928:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 929:../Sources/drivers/mcg/mcg.c **** 
 930:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
 931:../Sources/drivers/mcg/mcg.c ****     short           i;
 932:../Sources/drivers/mcg/mcg.c **** 
 933:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 934:../Sources/drivers/mcg/mcg.c **** 
 935:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 936:../Sources/drivers/mcg/mcg.c **** 
 937:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 938:../Sources/drivers/mcg/mcg.c **** 
 939:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 940:../Sources/drivers/mcg/mcg.c **** 
 941:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 942:../Sources/drivers/mcg/mcg.c **** 
 943:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
 944:../Sources/drivers/mcg/mcg.c **** 
 945:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in BLPE mode
 946:../Sources/drivers/mcg/mcg.c **** 
 947:../Sources/drivers/mcg/mcg.c ****     if
 948:../Sources/drivers/mcg/mcg.c ****     (
 949:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1399              		.loc 1 949 0
 1400 0002 4FF48043 		mov	r3, #16384
 1401 0006 C4F20603 		movt	r3, 16390
 1402 000a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 1403 000c C4F38104 		ubfx	r4, r4, #2, #2
 948:../Sources/drivers/mcg/mcg.c ****     (
 1404              		.loc 1 948 0
 1405 0010 022C     		cmp	r4, #2
 1406 0012 02D0     		beq	.L258
 1407              	.L247:
 950:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 951:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
 952:../Sources/drivers/mcg/mcg.c ****         )
 953:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is set
 954:../Sources/drivers/mcg/mcg.c ****     {
 955:../Sources/drivers/mcg/mcg.c ****         return 0x6; // return error code
 1408              		.loc 1 955 0
 1409 0014 0620     		movs	r0, #6
 1410              	.LVL154:
 1411              	.L240:
 956:../Sources/drivers/mcg/mcg.c ****     }
 957:../Sources/drivers/mcg/mcg.c **** 
 958:../Sources/drivers/mcg/mcg.c ****     // As the external frequency has already been checked when FBE mode was enterred it is not chec
 959:../Sources/drivers/mcg/mcg.c ****     // Check PLL divider settings are within spec.
 960:../Sources/drivers/mcg/mcg.c **** 
 961:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 962:../Sources/drivers/mcg/mcg.c ****     {
 963:../Sources/drivers/mcg/mcg.c ****         return 0x41;
 964:../Sources/drivers/mcg/mcg.c ****     }
 965:../Sources/drivers/mcg/mcg.c **** 
 966:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 967:../Sources/drivers/mcg/mcg.c ****     {
 968:../Sources/drivers/mcg/mcg.c ****         return 0x42;
 969:../Sources/drivers/mcg/mcg.c ****     }
 970:../Sources/drivers/mcg/mcg.c **** 
 971:../Sources/drivers/mcg/mcg.c ****     // Check PLL reference clock frequency is within spec.
 972:../Sources/drivers/mcg/mcg.c **** 
 973:../Sources/drivers/mcg/mcg.c ****     if(((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000))
 974:../Sources/drivers/mcg/mcg.c ****     {
 975:../Sources/drivers/mcg/mcg.c ****         return 0x43;
 976:../Sources/drivers/mcg/mcg.c ****     }
 977:../Sources/drivers/mcg/mcg.c **** 
 978:../Sources/drivers/mcg/mcg.c ****     // If PRDIV, VDIV and the PLL ref clock are in spec. then the PLL frequency is within spec.
 979:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C5
 980:../Sources/drivers/mcg/mcg.c ****     // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user 
 981:../Sources/drivers/mcg/mcg.c **** 
 982:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 983:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 984:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 985:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 986:../Sources/drivers/mcg/mcg.c **** 
 987:../Sources/drivers/mcg/mcg.c ****     // Configure MCG_C6
 988:../Sources/drivers/mcg/mcg.c ****     // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 989:../Sources/drivers/mcg/mcg.c ****     // The clock monitor is not enabled here as it has likely been enabled previously and so the va
 990:../Sources/drivers/mcg/mcg.c ****     // is not altered here.
 991:../Sources/drivers/mcg/mcg.c ****     // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 992:../Sources/drivers/mcg/mcg.c **** 
 993:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 994:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 995:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 996:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 997:../Sources/drivers/mcg/mcg.c **** 
 998:../Sources/drivers/mcg/mcg.c ****     // Now that PLL is configured, LP is cleared to enable the PLL
 999:../Sources/drivers/mcg/mcg.c **** 
1000:../Sources/drivers/mcg/mcg.c ****     MCG_C2 &= ~MCG_C2_LP_MASK;
1001:../Sources/drivers/mcg/mcg.c **** 
1002:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to set
1003:../Sources/drivers/mcg/mcg.c **** 
1004:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1005:../Sources/drivers/mcg/mcg.c ****     {
1006:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
1007:../Sources/drivers/mcg/mcg.c ****     }
1008:../Sources/drivers/mcg/mcg.c **** 
1009:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
1010:../Sources/drivers/mcg/mcg.c **** 
1011:../Sources/drivers/mcg/mcg.c ****     // Wait for LOCK bit to set
1012:../Sources/drivers/mcg/mcg.c **** 
1013:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1014:../Sources/drivers/mcg/mcg.c ****     {
1015:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
1016:../Sources/drivers/mcg/mcg.c ****     }
1017:../Sources/drivers/mcg/mcg.c **** 
1018:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
1019:../Sources/drivers/mcg/mcg.c **** 
1020:../Sources/drivers/mcg/mcg.c ****     // now in PBE
1021:../Sources/drivers/mcg/mcg.c **** 
1022:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
1023:../Sources/drivers/mcg/mcg.c **** }                       // blpe_pbe
 1412              		.loc 1 1023 0
 1413 0016 30BC     		pop	{r4, r5}
 1414 0018 7047     		bx	lr
 1415              	.LVL155:
 1416              	.L258:
 950:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1417              		.loc 1 950 0
 1418 001a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 1419 001c 04F01004 		and	r4, r4, #16
 1420 0020 E4B2     		uxtb	r4, r4
 1421 0022 002C     		cmp	r4, #0
 1422 0024 F6D1     		bne	.L247
 951:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
 1423              		.loc 1 951 0
 1424 0026 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 949:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1425              		.loc 1 949 0
 1426 0028 04F00204 		and	r4, r4, #2
 1427 002c E4B2     		uxtb	r4, r4
 1428 002e 002C     		cmp	r4, #0
 1429 0030 F0D0     		beq	.L247
 961:../Sources/drivers/mcg/mcg.c ****     if((prdiv_val < 1) || (prdiv_val > 25))
 1430              		.loc 1 961 0
 1431 0032 4C1E     		subs	r4, r1, #1
 1432 0034 E4B2     		uxtb	r4, r4
 1433 0036 182C     		cmp	r4, #24
 1434 0038 01D9     		bls	.L259
 963:../Sources/drivers/mcg/mcg.c ****         return 0x41;
 1435              		.loc 1 963 0
 1436 003a 4120     		movs	r0, #65
 1437              	.LVL156:
 1438 003c EBE7     		b	.L240
 1439              	.LVL157:
 1440              	.L259:
 966:../Sources/drivers/mcg/mcg.c ****     if((vdiv_val < 24) || (vdiv_val > 50))
 1441              		.loc 1 966 0
 1442 003e 183A     		subs	r2, r2, #24
 1443              	.LVL158:
 1444 0040 D2B2     		uxtb	r2, r2
 1445 0042 1A2A     		cmp	r2, #26
 1446 0044 01D9     		bls	.L260
 968:../Sources/drivers/mcg/mcg.c ****         return 0x42;
 1447              		.loc 1 968 0
 1448 0046 4220     		movs	r0, #66
 1449              	.LVL159:
 1450 0048 E5E7     		b	.L240
 1451              	.LVL160:
 1452              	.L260:
 973:../Sources/drivers/mcg/mcg.c ****     if(((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000))
 1453              		.loc 1 973 0
 1454 004a 90FBF1F1 		sdiv	r1, r0, r1
 1455              	.LVL161:
 1456 004e A1F5F415 		sub	r5, r1, #1998848
 1457 0052 48F28041 		movw	r1, #33920
 1458 0056 A5F59065 		sub	r5, r5, #1152
 1459 005a C0F21E01 		movt	r1, 30
 1460 005e 8D42     		cmp	r5, r1
 1461 0060 01D9     		bls	.L261
 975:../Sources/drivers/mcg/mcg.c ****         return 0x43;
 1462              		.loc 1 975 0
 1463 0062 4320     		movs	r0, #67
 1464              	.LVL162:
 1465 0064 D7E7     		b	.L240
 1466              	.LVL163:
 1467              	.L261:
 982:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C5;
 1468              		.loc 1 982 0
 1469 0066 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 1470              	.LVL164:
 983:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C5_PRDIV0_MASK;
 1471              		.loc 1 983 0
 1472 0068 01F0E001 		and	r1, r1, #224
 1473              	.LVL165:
 984:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);   //set PLL ref divider
 1474              		.loc 1 984 0
 1475 006c 0C43     		orrs	r4, r4, r1
 1476              	.LVL166:
 985:../Sources/drivers/mcg/mcg.c ****     MCG_C5 = temp_reg;
 1477              		.loc 1 985 0
 1478 006e 1C71     		strb	r4, [r3, #4]
 993:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C6;              // store present C6 value
 1479              		.loc 1 993 0
 1480 0070 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 1481              	.LVL167:
 994:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 1482              		.loc 1 994 0
 1483 0072 01F0E001 		and	r1, r1, #224
 1484              	.LVL168:
 995:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1485              		.loc 1 995 0
 1486 0076 41F04001 		orr	r1, r1, #64
 1487 007a 0A43     		orrs	r2, r2, r1
 1488              	.LVL169:
 996:../Sources/drivers/mcg/mcg.c ****     MCG_C6 = temp_reg;                      // update MCG_C6
 1489              		.loc 1 996 0
 1490 007c 5A71     		strb	r2, [r3, #5]
1000:../Sources/drivers/mcg/mcg.c ****     MCG_C2 &= ~MCG_C2_LP_MASK;
 1491              		.loc 1 1000 0
 1492 007e 5978     		ldrb	r1, [r3, #1]	@ zero_extendqisi2
 1493 0080 01F0FD02 		and	r2, r1, #253
 1494              	.LVL170:
 1495 0084 5A70     		strb	r2, [r3, #1]
 1496              	.LVL171:
 1497 0086 4FF4FA62 		mov	r2, #2000
 1498 008a 08E0     		b	.L242
 1499              	.LVL172:
 1500              	.L262:
1006:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1501              		.loc 1 1006 0
 1502 008c 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1503 008e 92B2     		uxth	r2, r2
 1504 0090 01F02001 		and	r1, r1, #32
 1505 0094 013A     		subs	r2, r2, #1
 1506 0096 C9B2     		uxtb	r1, r1
 1507 0098 92B2     		uxth	r2, r2
 1508 009a 39B9     		cbnz	r1, .L241
1004:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1509              		.loc 1 1004 0
 1510 009c 32B1     		cbz	r2, .L241
 1511              	.L242:
1006:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1512              		.loc 1 1006 0
 1513 009e 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1514 00a0 01F02001 		and	r1, r1, #32
 1515 00a4 C9B2     		uxtb	r1, r1
 1516 00a6 013A     		subs	r2, r2, #1
 1517 00a8 0029     		cmp	r1, #0
 1518 00aa EFD0     		beq	.L262
 1519              	.L241:
1009:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_PLLST_MASK)) return 0x16;    // check bit is really set and return with erro
 1520              		.loc 1 1009 0
 1521 00ac 4FF48042 		mov	r2, #16384
 1522 00b0 C4F20602 		movt	r2, 16390
 1523 00b4 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 1524 00b6 03F02001 		and	r1, r3, #32
 1525 00ba CBB2     		uxtb	r3, r1
 1526 00bc 0BB9     		cbnz	r3, .L263
 1527 00be 1620     		movs	r0, #22
 1528              	.LVL173:
 1529 00c0 A9E7     		b	.L240
 1530              	.LVL174:
 1531              	.L263:
 1532 00c2 4FF4FA63 		mov	r3, #2000
 1533 00c6 08E0     		b	.L244
 1534              	.L264:
1015:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 1535              		.loc 1 1015 0
 1536 00c8 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1537 00ca 9BB2     		uxth	r3, r3
 1538 00cc 01F04001 		and	r1, r1, #64
 1539 00d0 013B     		subs	r3, r3, #1
 1540 00d2 C9B2     		uxtb	r1, r1
 1541 00d4 9BB2     		uxth	r3, r3
 1542 00d6 39B9     		cbnz	r1, .L243
1013:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1543              		.loc 1 1013 0
 1544 00d8 33B1     		cbz	r3, .L243
 1545              	.L244:
1015:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_LOCK0_MASK) break;         // jump out early if LOCK sets before loop fini
 1546              		.loc 1 1015 0
 1547 00da 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1548 00dc 01F04001 		and	r1, r1, #64
 1549 00e0 C9B2     		uxtb	r1, r1
 1550 00e2 013B     		subs	r3, r3, #1
 1551 00e4 0029     		cmp	r1, #0
 1552 00e6 EFD0     		beq	.L264
 1553              	.L243:
1018:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44;    // check bit is really set and return with erro
 1554              		.loc 1 1018 0
 1555 00e8 4FF48042 		mov	r2, #16384
 1556 00ec C4F20602 		movt	r2, 16390
 1557 00f0 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1558 00f2 01F04003 		and	r3, r1, #64
 1559 00f6 DAB2     		uxtb	r2, r3
 1560 00f8 002A     		cmp	r2, #0
 1561 00fa 08BF     		it	eq
 1562 00fc 4420     		moveq	r0, #68
 1563              	.LVL175:
 1564 00fe 8AE7     		b	.L240
 1565              		.cfi_endproc
 1566              	.LFE7:
 1568              		.section	.text.blpe_fbe,"ax",%progbits
 1569              		.align	2
 1570              		.global	blpe_fbe
 1571              		.thumb
 1572              		.thumb_func
 1574              	blpe_fbe:
 1575              	.LFB8:
1024:../Sources/drivers/mcg/mcg.c **** 
1025:../Sources/drivers/mcg/mcg.c **** /* */
1026:../Sources/drivers/mcg/mcg.c **** 
1027:../Sources/drivers/mcg/mcg.c **** int blpe_fbe
1028:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
1029:../Sources/drivers/mcg/mcg.c **** {
 1576              		.loc 1 1029 0
 1577              		.cfi_startproc
 1578              		@ args = 0, pretend = 0, frame = 0
 1579              		@ frame_needed = 0, uses_anonymous_args = 0
 1580              		@ link register save eliminated.
 1581              	.LVL176:
1030:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1031:../Sources/drivers/mcg/mcg.c **** 
1032:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1033:../Sources/drivers/mcg/mcg.c **** 
1034:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1035:../Sources/drivers/mcg/mcg.c **** 
1036:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1037:../Sources/drivers/mcg/mcg.c **** 
1038:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1039:../Sources/drivers/mcg/mcg.c **** 
1040:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1041:../Sources/drivers/mcg/mcg.c **** 
1042:../Sources/drivers/mcg/mcg.c ****     short   i;
1043:../Sources/drivers/mcg/mcg.c **** 
1044:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1045:../Sources/drivers/mcg/mcg.c **** 
1046:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1047:../Sources/drivers/mcg/mcg.c **** 
1048:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1049:../Sources/drivers/mcg/mcg.c **** 
1050:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1051:../Sources/drivers/mcg/mcg.c **** 
1052:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1053:../Sources/drivers/mcg/mcg.c **** 
1054:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1055:../Sources/drivers/mcg/mcg.c **** 
1056:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in BLPE mode
1057:../Sources/drivers/mcg/mcg.c **** 
1058:../Sources/drivers/mcg/mcg.c ****     if
1059:../Sources/drivers/mcg/mcg.c ****     (
1060:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1582              		.loc 1 1060 0
 1583 0000 4FF48043 		mov	r3, #16384
 1584 0004 C4F20603 		movt	r3, 16390
 1585 0008 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1586 000a C2F38101 		ubfx	r1, r2, #2, #2
1059:../Sources/drivers/mcg/mcg.c ****     (
 1587              		.loc 1 1059 0
 1588 000e 0229     		cmp	r1, #2
 1589 0010 01D0     		beq	.L281
 1590              	.L271:
1061:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
1062:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
1063:../Sources/drivers/mcg/mcg.c ****         )
1064:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is set
1065:../Sources/drivers/mcg/mcg.c ****     {
1066:../Sources/drivers/mcg/mcg.c ****         return 0x6; // return error code
 1591              		.loc 1 1066 0
 1592 0012 0620     		movs	r0, #6
 1593              	.LVL177:
1067:../Sources/drivers/mcg/mcg.c ****     }
1068:../Sources/drivers/mcg/mcg.c **** 
1069:../Sources/drivers/mcg/mcg.c ****     // To move from BLPE to FBE the PLLS mux be set to select the FLL output and the LP bit must be
1070:../Sources/drivers/mcg/mcg.c **** 
1071:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_PLLS_MASK;                // clear PLLS to select the FLL
1072:../Sources/drivers/mcg/mcg.c ****     MCG_C2 &= ~MCG_C2_LP_MASK;                  // clear LP bit
1073:../Sources/drivers/mcg/mcg.c **** 
1074:../Sources/drivers/mcg/mcg.c ****     // wait for PLLST status bit to clear
1075:../Sources/drivers/mcg/mcg.c **** 
1076:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1077:../Sources/drivers/mcg/mcg.c ****     {
1078:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_PLLST_MASK)) break;  // jump out early if PLLST clears before loop finis
1079:../Sources/drivers/mcg/mcg.c ****     }
1080:../Sources/drivers/mcg/mcg.c **** 
1081:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_PLLST_MASK) return 0x15;   // check bit is really clear and return with error 
1082:../Sources/drivers/mcg/mcg.c **** 
1083:../Sources/drivers/mcg/mcg.c ****     // now in FBE mode
1084:../Sources/drivers/mcg/mcg.c **** 
1085:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
1086:../Sources/drivers/mcg/mcg.c **** }                       // blpe_fbe
 1594              		.loc 1 1086 0
 1595 0014 7047     		bx	lr
 1596              	.LVL178:
 1597              	.L281:
1061:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1598              		.loc 1 1061 0
 1599 0016 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1600 0018 02F01001 		and	r1, r2, #16
 1601 001c CAB2     		uxtb	r2, r1
 1602 001e 002A     		cmp	r2, #0
 1603 0020 F7D1     		bne	.L271
1062:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
 1604              		.loc 1 1062 0
 1605 0022 5978     		ldrb	r1, [r3, #1]	@ zero_extendqisi2
1060:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1606              		.loc 1 1060 0
 1607 0024 01F00202 		and	r2, r1, #2
 1608 0028 D1B2     		uxtb	r1, r2
 1609 002a 0029     		cmp	r1, #0
 1610 002c F1D0     		beq	.L271
1071:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_PLLS_MASK;                // clear PLLS to select the FLL
 1611              		.loc 1 1071 0
 1612 002e 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 1613 0030 02F0BF01 		and	r1, r2, #191
 1614 0034 5971     		strb	r1, [r3, #5]
1072:../Sources/drivers/mcg/mcg.c ****     MCG_C2 &= ~MCG_C2_LP_MASK;                  // clear LP bit
 1615              		.loc 1 1072 0
 1616 0036 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 1617 0038 02F0FD01 		and	r1, r2, #253
 1618 003c 5970     		strb	r1, [r3, #1]
 1619              	.LVL179:
 1620 003e 4FF4FA62 		mov	r2, #2000
 1621 0042 08E0     		b	.L268
 1622              	.LVL180:
 1623              	.L282:
1078:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_PLLST_MASK)) break;  // jump out early if PLLST clears before loop finis
 1624              		.loc 1 1078 0
 1625 0044 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1626 0046 92B2     		uxth	r2, r2
 1627 0048 01F02001 		and	r1, r1, #32
 1628 004c 013A     		subs	r2, r2, #1
 1629 004e C9B2     		uxtb	r1, r1
 1630 0050 92B2     		uxth	r2, r2
 1631 0052 39B1     		cbz	r1, .L267
1076:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1632              		.loc 1 1076 0
 1633 0054 32B1     		cbz	r2, .L267
 1634              	.L268:
1078:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_PLLST_MASK)) break;  // jump out early if PLLST clears before loop finis
 1635              		.loc 1 1078 0
 1636 0056 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1637 0058 01F02001 		and	r1, r1, #32
 1638 005c C9B2     		uxtb	r1, r1
 1639 005e 013A     		subs	r2, r2, #1
 1640 0060 0029     		cmp	r1, #0
 1641 0062 EFD1     		bne	.L282
 1642              	.L267:
1081:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_PLLST_MASK) return 0x15;   // check bit is really clear and return with error 
 1643              		.loc 1 1081 0
 1644 0064 4FF48043 		mov	r3, #16384
 1645 0068 C4F20603 		movt	r3, 16390
 1646 006c 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1647 006e 01F02002 		and	r2, r1, #32
 1648 0072 D3B2     		uxtb	r3, r2
 1649 0074 002B     		cmp	r3, #0
 1650 0076 18BF     		it	ne
 1651 0078 1520     		movne	r0, #21
 1652              	.LVL181:
 1653 007a 7047     		bx	lr
 1654              		.cfi_endproc
 1655              	.LFE8:
 1657              		.section	.text.fbe_blpe,"ax",%progbits
 1658              		.align	2
 1659              		.global	fbe_blpe
 1660              		.thumb
 1661              		.thumb_func
 1663              	fbe_blpe:
 1664              	.LFB9:
1087:../Sources/drivers/mcg/mcg.c **** 
1088:../Sources/drivers/mcg/mcg.c **** /* */
1089:../Sources/drivers/mcg/mcg.c **** 
1090:../Sources/drivers/mcg/mcg.c **** int fbe_blpe
1091:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
1092:../Sources/drivers/mcg/mcg.c **** {
 1665              		.loc 1 1092 0
 1666              		.cfi_startproc
 1667              		@ args = 0, pretend = 0, frame = 0
 1668              		@ frame_needed = 0, uses_anonymous_args = 0
 1669              		@ link register save eliminated.
 1670              	.LVL182:
1093:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
1094:../Sources/drivers/mcg/mcg.c **** 
1095:../Sources/drivers/mcg/mcg.c ****     if
1096:../Sources/drivers/mcg/mcg.c ****     (
1097:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1671              		.loc 1 1097 0
 1672 0000 4FF48043 		mov	r3, #16384
 1673 0004 C4F20603 		movt	r3, 16390
 1674 0008 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1675 000a C2F38101 		ubfx	r1, r2, #2, #2
1096:../Sources/drivers/mcg/mcg.c ****     (
 1676              		.loc 1 1096 0
 1677 000e 0229     		cmp	r1, #2
 1678 0010 01D0     		beq	.L289
 1679              	.L288:
1098:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
1099:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
1100:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
1101:../Sources/drivers/mcg/mcg.c ****         )
1102:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
1103:../Sources/drivers/mcg/mcg.c ****     {
1104:../Sources/drivers/mcg/mcg.c ****         return 0x4; // return error code
 1680              		.loc 1 1104 0
 1681 0012 0420     		movs	r0, #4
 1682              	.LVL183:
1105:../Sources/drivers/mcg/mcg.c ****     }
1106:../Sources/drivers/mcg/mcg.c **** 
1107:../Sources/drivers/mcg/mcg.c ****     // To move from FBE to BLPE the LP bit must be set
1108:../Sources/drivers/mcg/mcg.c **** 
1109:../Sources/drivers/mcg/mcg.c ****     MCG_C2 |= MCG_C2_LP_MASK;   // set LP bit
1110:../Sources/drivers/mcg/mcg.c **** 
1111:../Sources/drivers/mcg/mcg.c ****     // now in FBE mode
1112:../Sources/drivers/mcg/mcg.c **** 
1113:../Sources/drivers/mcg/mcg.c ****     return crystal_val;         // MCGOUT frequency equals external clock frequency
1114:../Sources/drivers/mcg/mcg.c **** }   // fbe_blpe
 1683              		.loc 1 1114 0
 1684 0014 7047     		bx	lr
 1685              	.LVL184:
 1686              	.L289:
1098:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 1687              		.loc 1 1098 0
 1688 0016 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1689 0018 02F01001 		and	r1, r2, #16
 1690 001c CAB2     		uxtb	r2, r1
 1691 001e 002A     		cmp	r2, #0
 1692 0020 F7D1     		bne	.L288
1099:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 1693              		.loc 1 1099 0
 1694 0022 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 1695 0024 01F02002 		and	r2, r1, #32
 1696 0028 D1B2     		uxtb	r1, r2
 1697 002a 0029     		cmp	r1, #0
 1698 002c F1D1     		bne	.L288
1100:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 1699              		.loc 1 1100 0
 1700 002e 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
1097:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 1701              		.loc 1 1097 0
 1702 0030 02F00201 		and	r1, r2, #2
 1703 0034 CAB2     		uxtb	r2, r1
 1704 0036 002A     		cmp	r2, #0
 1705 0038 EBD1     		bne	.L288
1109:../Sources/drivers/mcg/mcg.c ****     MCG_C2 |= MCG_C2_LP_MASK;   // set LP bit
 1706              		.loc 1 1109 0
 1707 003a 5978     		ldrb	r1, [r3, #1]	@ zero_extendqisi2
 1708 003c 41F00202 		orr	r2, r1, #2
 1709 0040 5A70     		strb	r2, [r3, #1]
1113:../Sources/drivers/mcg/mcg.c ****     return crystal_val;         // MCGOUT frequency equals external clock frequency
 1710              		.loc 1 1113 0
 1711 0042 7047     		bx	lr
 1712              		.cfi_endproc
 1713              	.LFE9:
 1715              		.section	.text.fei_fbe,"ax",%progbits
 1716              		.align	2
 1717              		.global	fei_fbe
 1718              		.thumb
 1719              		.thumb_func
 1721              	fei_fbe:
 1722              	.LFB11:
1115:../Sources/drivers/mcg/mcg.c **** 
1116:../Sources/drivers/mcg/mcg.c **** /* */
1117:../Sources/drivers/mcg/mcg.c **** 
1118:../Sources/drivers/mcg/mcg.c **** int fbe_fei
1119:../Sources/drivers/mcg/mcg.c **** (int slow_irc_freq)
1120:../Sources/drivers/mcg/mcg.c **** {
1121:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1122:../Sources/drivers/mcg/mcg.c **** 
1123:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1124:../Sources/drivers/mcg/mcg.c **** 
1125:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1126:../Sources/drivers/mcg/mcg.c **** 
1127:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1128:../Sources/drivers/mcg/mcg.c **** 
1129:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1130:../Sources/drivers/mcg/mcg.c **** 
1131:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1132:../Sources/drivers/mcg/mcg.c **** 
1133:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
1134:../Sources/drivers/mcg/mcg.c ****     short           i;
1135:../Sources/drivers/mcg/mcg.c ****     int             mcg_out;
1136:../Sources/drivers/mcg/mcg.c **** 
1137:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1138:../Sources/drivers/mcg/mcg.c **** 
1139:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1140:../Sources/drivers/mcg/mcg.c **** 
1141:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1142:../Sources/drivers/mcg/mcg.c **** 
1143:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1144:../Sources/drivers/mcg/mcg.c **** 
1145:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1146:../Sources/drivers/mcg/mcg.c **** 
1147:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
1148:../Sources/drivers/mcg/mcg.c **** 
1149:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
1150:../Sources/drivers/mcg/mcg.c **** 
1151:../Sources/drivers/mcg/mcg.c ****     if
1152:../Sources/drivers/mcg/mcg.c ****     (
1153:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
1154:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
1155:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
1156:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
1157:../Sources/drivers/mcg/mcg.c ****         )
1158:../Sources/drivers/mcg/mcg.c ****     )                   // check MCG_C2[LP] bit is not set
1159:../Sources/drivers/mcg/mcg.c ****     {
1160:../Sources/drivers/mcg/mcg.c ****         return 0x4;     // return error code
1161:../Sources/drivers/mcg/mcg.c ****     }
1162:../Sources/drivers/mcg/mcg.c **** 
1163:../Sources/drivers/mcg/mcg.c ****     // Check IRC frequency is within spec.
1164:../Sources/drivers/mcg/mcg.c **** 
1165:../Sources/drivers/mcg/mcg.c ****     if((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
1166:../Sources/drivers/mcg/mcg.c ****     {
1167:../Sources/drivers/mcg/mcg.c ****         return 0x31;
1168:../Sources/drivers/mcg/mcg.c ****     }
1169:../Sources/drivers/mcg/mcg.c **** 
1170:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
1171:../Sources/drivers/mcg/mcg.c **** 
1172:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(slow_irc_freq);
1173:../Sources/drivers/mcg/mcg.c **** 
1174:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
1175:../Sources/drivers/mcg/mcg.c ****     {
1176:../Sources/drivers/mcg/mcg.c ****         return mcg_out; // If error code returned, return the code to calling function
1177:../Sources/drivers/mcg/mcg.c ****     }
1178:../Sources/drivers/mcg/mcg.c **** 
1179:../Sources/drivers/mcg/mcg.c ****     // Need to make sure the clockmonitor is disabled before moving to an "internal" clock mode
1180:../Sources/drivers/mcg/mcg.c **** 
1181:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;                    //This assumes OSC0 is used as the external clo
1182:../Sources/drivers/mcg/mcg.c **** 
1183:../Sources/drivers/mcg/mcg.c ****     // Move to FEI by setting CLKS to 0 and enabling the slow IRC as the FLL reference clock
1184:../Sources/drivers/mcg/mcg.c **** 
1185:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
1186:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                  // clear CLKS to select FLL output
1187:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_IREFS_MASK;                  // select internal reference clock
1188:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;                              // update MCG_C1
1189:../Sources/drivers/mcg/mcg.c **** 
1190:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to set
1191:../Sources/drivers/mcg/mcg.c **** 
1192:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1193:../Sources/drivers/mcg/mcg.c ****     {
1194:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
1195:../Sources/drivers/mcg/mcg.c ****     }
1196:../Sources/drivers/mcg/mcg.c **** 
1197:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
1198:../Sources/drivers/mcg/mcg.c **** 
1199:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
1200:../Sources/drivers/mcg/mcg.c **** 
1201:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1202:../Sources/drivers/mcg/mcg.c ****     {
1203:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out early i
1204:../Sources/drivers/mcg/mcg.c ****     }
1205:../Sources/drivers/mcg/mcg.c **** 
1206:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check EXT CLK is
1207:../Sources/drivers/mcg/mcg.c **** 
1208:../Sources/drivers/mcg/mcg.c ****     // Now in FEI mode
1209:../Sources/drivers/mcg/mcg.c **** 
1210:../Sources/drivers/mcg/mcg.c ****     return mcg_out;
1211:../Sources/drivers/mcg/mcg.c **** }   // fbe_fei
1212:../Sources/drivers/mcg/mcg.c **** 
1213:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
1214:../Sources/drivers/mcg/mcg.c **** 
1215:../Sources/drivers/mcg/mcg.c **** /* Functon name : fei_fbe
1216:../Sources/drivers/mcg/mcg.c ****  *
1217:../Sources/drivers/mcg/mcg.c ****  * Mode transition: FEI to FBE mode
1218:../Sources/drivers/mcg/mcg.c ****  *
1219:../Sources/drivers/mcg/mcg.c ****  * This function transitions the MCG from FEI mode to FBE mode. This is
1220:../Sources/drivers/mcg/mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to
1221:../Sources/drivers/mcg/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1222:../Sources/drivers/mcg/mcg.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
1223:../Sources/drivers/mcg/mcg.c ****  *
1224:../Sources/drivers/mcg/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
1225:../Sources/drivers/mcg/mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
1226:../Sources/drivers/mcg/mcg.c ****  *                           for the crystal oscillator. This has no meaning if an
1227:../Sources/drivers/mcg/mcg.c ****  *                           external clock is used.
1228:../Sources/drivers/mcg/mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
1229:../Sources/drivers/mcg/mcg.c ****  *
1230:../Sources/drivers/mcg/mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
1231:../Sources/drivers/mcg/mcg.c ****  */
1232:../Sources/drivers/mcg/mcg.c **** 
1233:../Sources/drivers/mcg/mcg.c **** int fei_fbe
1234:../Sources/drivers/mcg/mcg.c **** (
1235:../Sources/drivers/mcg/mcg.c ****     int             crystal_val,
1236:../Sources/drivers/mcg/mcg.c ****     unsigned char   hgo_val,
1237:../Sources/drivers/mcg/mcg.c ****     unsigned char   erefs_val
1238:../Sources/drivers/mcg/mcg.c **** )
1239:../Sources/drivers/mcg/mcg.c **** {
 1723              		.loc 1 1239 0
 1724              		.cfi_startproc
 1725              		@ args = 0, pretend = 0, frame = 0
 1726              		@ frame_needed = 0, uses_anonymous_args = 0
 1727              		@ link register save eliminated.
 1728              	.LVL185:
 1729 0000 30B4     		push	{r4, r5}
 1730              	.LCFI5:
 1731              		.cfi_def_cfa_offset 8
 1732              		.cfi_offset 4, -8
 1733              		.cfi_offset 5, -4
1240:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1241:../Sources/drivers/mcg/mcg.c **** 
1242:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1243:../Sources/drivers/mcg/mcg.c **** 
1244:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1245:../Sources/drivers/mcg/mcg.c **** 
1246:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1247:../Sources/drivers/mcg/mcg.c **** 
1248:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1249:../Sources/drivers/mcg/mcg.c **** 
1250:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1251:../Sources/drivers/mcg/mcg.c **** 
1252:../Sources/drivers/mcg/mcg.c ****     unsigned char   frdiv_val;
1253:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
1254:../Sources/drivers/mcg/mcg.c ****     short           i;
1255:../Sources/drivers/mcg/mcg.c **** 
1256:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1257:../Sources/drivers/mcg/mcg.c **** 
1258:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1259:../Sources/drivers/mcg/mcg.c **** 
1260:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1261:../Sources/drivers/mcg/mcg.c **** 
1262:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1263:../Sources/drivers/mcg/mcg.c **** 
1264:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1265:../Sources/drivers/mcg/mcg.c **** 
1266:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1267:../Sources/drivers/mcg/mcg.c **** 
1268:../Sources/drivers/mcg/mcg.c ****     // check if in FEI mode
1269:../Sources/drivers/mcg/mcg.c **** 
1270:../Sources/drivers/mcg/mcg.c ****     if
1271:../Sources/drivers/mcg/mcg.c ****     (
1272:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 1734              		.loc 1 1272 0
 1735 0002 4FF48043 		mov	r3, #16384
 1736 0006 C4F20603 		movt	r3, 16390
 1737 000a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
1271:../Sources/drivers/mcg/mcg.c ****     (
 1738              		.loc 1 1271 0
 1739 000c 14F00C0F 		tst	r4, #12
 1740 0010 11D1     		bne	.L305
1273:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
 1741              		.loc 1 1273 0
 1742 0012 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 1743 0014 04F01004 		and	r4, r4, #16
 1744 0018 E4B2     		uxtb	r4, r4
 1745 001a 64B1     		cbz	r4, .L305
1274:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
 1746              		.loc 1 1274 0
 1747 001c 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
1272:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 1748              		.loc 1 1272 0
 1749 001e 03F02003 		and	r3, r3, #32
 1750 0022 DBB2     		uxtb	r3, r3
 1751 0024 3BB9     		cbnz	r3, .L305
1275:../Sources/drivers/mcg/mcg.c ****         )
1276:../Sources/drivers/mcg/mcg.c ****     )                       // check PLLS mux has selected FLL
1277:../Sources/drivers/mcg/mcg.c ****     {
1278:../Sources/drivers/mcg/mcg.c ****         return 0x1;         // return error code
1279:../Sources/drivers/mcg/mcg.c ****     }
1280:../Sources/drivers/mcg/mcg.c **** 
1281:../Sources/drivers/mcg/mcg.c ****     // check external frequency is less than the maximum frequency
1282:../Sources/drivers/mcg/mcg.c **** 
1283:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
 1752              		.loc 1 1283 0
 1753 0026 4FF28003 		movw	r3, #61568
 1754 002a C0F2FA23 		movt	r3, 762
 1755 002e 9842     		cmp	r0, r3
 1756 0030 04DD     		ble	.L349
1284:../Sources/drivers/mcg/mcg.c ****     {
1285:../Sources/drivers/mcg/mcg.c ****         return 0x21;
 1757              		.loc 1 1285 0
 1758 0032 2120     		movs	r0, #33
 1759              	.LVL186:
 1760 0034 00E0     		b	.L291
 1761              	.LVL187:
 1762              	.L305:
1278:../Sources/drivers/mcg/mcg.c ****         return 0x1;         // return error code
 1763              		.loc 1 1278 0
 1764 0036 0120     		movs	r0, #1
 1765              	.LVL188:
 1766              	.L291:
1286:../Sources/drivers/mcg/mcg.c ****     }
1287:../Sources/drivers/mcg/mcg.c **** 
1288:../Sources/drivers/mcg/mcg.c ****     // check crystal frequency is within spec. if crystal osc is being used
1289:../Sources/drivers/mcg/mcg.c **** 
1290:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
1291:../Sources/drivers/mcg/mcg.c ****     {
1292:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
1293:../Sources/drivers/mcg/mcg.c ****         {
1294:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return error if one of the available crystal options is not availabl
1295:../Sources/drivers/mcg/mcg.c ****         }
1296:../Sources/drivers/mcg/mcg.c ****     }
1297:../Sources/drivers/mcg/mcg.c **** 
1298:../Sources/drivers/mcg/mcg.c ****     // make sure HGO will never be greater than 1. Could return an error instead if desired.
1299:../Sources/drivers/mcg/mcg.c **** 
1300:../Sources/drivers/mcg/mcg.c ****     if(hgo_val > 0)
1301:../Sources/drivers/mcg/mcg.c ****     {
1302:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
1303:../Sources/drivers/mcg/mcg.c ****     }
1304:../Sources/drivers/mcg/mcg.c **** 
1305:../Sources/drivers/mcg/mcg.c ****     // configure the MCG_C2 register
1306:../Sources/drivers/mcg/mcg.c ****     // the RANGE value is determined by the external frequency. Since the RANGE parameter affects t
1307:../Sources/drivers/mcg/mcg.c ****     // it still needs to be set correctly even if the oscillator is not being used
1308:../Sources/drivers/mcg/mcg.c **** 
1309:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
1310:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
1311:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
1312:../Sources/drivers/mcg/mcg.c ****     {
1313:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
1314:../Sources/drivers/mcg/mcg.c ****     }
1315:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
1316:../Sources/drivers/mcg/mcg.c ****     {
1317:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
1318:../Sources/drivers/mcg/mcg.c ****     }
1319:../Sources/drivers/mcg/mcg.c ****     else
1320:../Sources/drivers/mcg/mcg.c ****     {
1321:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
1322:../Sources/drivers/mcg/mcg.c ****     }
1323:../Sources/drivers/mcg/mcg.c **** 
1324:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
1325:../Sources/drivers/mcg/mcg.c **** 
1326:../Sources/drivers/mcg/mcg.c ****     // determine FRDIV based on reference clock frequency
1327:../Sources/drivers/mcg/mcg.c ****     // since the external frequency has already been checked only the maximum frequency for each FR
1328:../Sources/drivers/mcg/mcg.c **** 
1329:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
1330:../Sources/drivers/mcg/mcg.c ****     {
1331:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 0;
1332:../Sources/drivers/mcg/mcg.c ****     }
1333:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
1334:../Sources/drivers/mcg/mcg.c ****     {
1335:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 1;
1336:../Sources/drivers/mcg/mcg.c ****     }
1337:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
1338:../Sources/drivers/mcg/mcg.c ****     {
1339:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 2;
1340:../Sources/drivers/mcg/mcg.c ****     }
1341:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
1342:../Sources/drivers/mcg/mcg.c ****     {
1343:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 3;
1344:../Sources/drivers/mcg/mcg.c ****     }
1345:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
1346:../Sources/drivers/mcg/mcg.c ****     {
1347:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 4;
1348:../Sources/drivers/mcg/mcg.c ****     }
1349:../Sources/drivers/mcg/mcg.c ****     else
1350:../Sources/drivers/mcg/mcg.c ****     {
1351:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 5;
1352:../Sources/drivers/mcg/mcg.c ****     }
1353:../Sources/drivers/mcg/mcg.c **** 
1354:../Sources/drivers/mcg/mcg.c ****     // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1355:../Sources/drivers/mcg/mcg.c ****     // If IRCLK is required it must be enabled outside of this driver, existing state will be maint
1356:../Sources/drivers/mcg/mcg.c ****     // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1357:../Sources/drivers/mcg/mcg.c **** 
1358:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
1359:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
1360:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
1361:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
1362:../Sources/drivers/mcg/mcg.c **** 
1363:../Sources/drivers/mcg/mcg.c ****     // if the external oscillator is used need to wait for OSCINIT to set
1364:../Sources/drivers/mcg/mcg.c **** 
1365:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
1366:../Sources/drivers/mcg/mcg.c ****     {
1367:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 10000; i++)
1368:../Sources/drivers/mcg/mcg.c ****         {
1369:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
1370:../Sources/drivers/mcg/mcg.c ****         }
1371:../Sources/drivers/mcg/mcg.c **** 
1372:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is really 
1373:../Sources/drivers/mcg/mcg.c ****     }
1374:../Sources/drivers/mcg/mcg.c **** 
1375:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
1376:../Sources/drivers/mcg/mcg.c **** 
1377:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1378:../Sources/drivers/mcg/mcg.c ****     {
1379:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
1380:../Sources/drivers/mcg/mcg.c ****     }
1381:../Sources/drivers/mcg/mcg.c **** 
1382:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
1383:../Sources/drivers/mcg/mcg.c **** 
1384:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
1385:../Sources/drivers/mcg/mcg.c **** 
1386:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1387:../Sources/drivers/mcg/mcg.c ****     {
1388:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CL
1389:../Sources/drivers/mcg/mcg.c ****     }
1390:../Sources/drivers/mcg/mcg.c **** 
1391:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
1392:../Sources/drivers/mcg/mcg.c **** 
1393:../Sources/drivers/mcg/mcg.c ****     // Now in FBE
1394:../Sources/drivers/mcg/mcg.c ****     // It is recommended that the clock monitor is enabled when using an external clock as the cloc
1395:../Sources/drivers/mcg/mcg.c ****     // It is enabled here but can be removed if this is not required.
1396:../Sources/drivers/mcg/mcg.c **** 
1397:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
1398:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
1399:../Sources/drivers/mcg/mcg.c **** }                       // fei_fbe
 1767              		.loc 1 1399 0
 1768 0038 30BC     		pop	{r4, r5}
 1769 003a 7047     		bx	lr
 1770              	.LVL189:
 1771              	.L349:
1290:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 1772              		.loc 1 1290 0
 1773 003c 002A     		cmp	r2, #0
 1774 003e 40D1     		bne	.L350
 1775              	.L292:
1309:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 1776              		.loc 1 1309 0
 1777 0040 4FF48043 		mov	r3, #16384
 1778 0044 C4F20603 		movt	r3, 16390
1302:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 1779              		.loc 1 1302 0
 1780 0048 0031     		adds	r1, r1, #0
 1781              	.LVL190:
1309:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 1782              		.loc 1 1309 0
 1783 004a 5D78     		ldrb	r5, [r3, #1]	@ zero_extendqisi2
1311:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 1784              		.loc 1 1311 0
 1785 004c 49F64044 		movw	r4, #40000
1302:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 1786              		.loc 1 1302 0
 1787 0050 18BF     		it	ne
 1788 0052 0121     		movne	r1, #1
 1789              	.LVL191:
1311:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 1790              		.loc 1 1311 0
 1791 0054 A042     		cmp	r0, r4
1310:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 1792              		.loc 1 1310 0
 1793 0056 05F0C305 		and	r5, r5, #195
 1794              	.LVL192:
1311:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 1795              		.loc 1 1311 0
 1796 005a 76DC     		bgt	.L293
1313:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 1797              		.loc 1 1313 0
 1798 005c 45EA8205 		orr	r5, r5, r2, lsl #2
 1799              	.LVL193:
 1800 0060 EDB2     		uxtb	r5, r5
 1801 0062 45EAC104 		orr	r4, r5, r1, lsl #3
 1802              	.LVL194:
1324:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 1803              		.loc 1 1324 0
 1804 0066 5C70     		strb	r4, [r3, #1]
 1805 0068 0024     		movs	r4, #0
 1806              	.LVL195:
 1807              	.L294:
1358:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 1808              		.loc 1 1358 0
 1809 006a 4FF48041 		mov	r1, #16384
 1810 006e C4F20601 		movt	r1, 16390
 1811 0072 0B78     		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 1812              	.LVL196:
1359:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
 1813              		.loc 1 1359 0
 1814 0074 03F00303 		and	r3, r3, #3
 1815              	.LVL197:
1360:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 1816              		.loc 1 1360 0
 1817 0078 43F08003 		orr	r3, r3, #128
 1818 007c 2343     		orrs	r3, r3, r4
 1819              	.LVL198:
1361:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 1820              		.loc 1 1361 0
 1821 007e 0B70     		strb	r3, [r1, #0]
1365:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 1822              		.loc 1 1365 0
 1823 0080 002A     		cmp	r2, #0
 1824 0082 35D0     		beq	.L297
 1825 0084 42F21073 		movw	r3, #10000
 1826              	.LVL199:
1369:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
 1827              		.loc 1 1369 0
 1828 0088 0A46     		mov	r2, r1
 1829              	.LVL200:
 1830 008a 08E0     		b	.L299
 1831              	.LVL201:
 1832              	.L351:
 1833 008c 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1834 008e 9BB2     		uxth	r3, r3
 1835 0090 01F00201 		and	r1, r1, #2
 1836 0094 013B     		subs	r3, r3, #1
 1837 0096 C9B2     		uxtb	r1, r1
 1838 0098 9BB2     		uxth	r3, r3
 1839 009a 39B9     		cbnz	r1, .L298
1367:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 10000; i++)
 1840              		.loc 1 1367 0
 1841 009c 33B1     		cbz	r3, .L298
 1842              	.L299:
1369:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
 1843              		.loc 1 1369 0
 1844 009e 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1845 00a0 01F00201 		and	r1, r1, #2
 1846 00a4 C9B2     		uxtb	r1, r1
 1847 00a6 013B     		subs	r3, r3, #1
 1848 00a8 0029     		cmp	r1, #0
 1849 00aa EFD0     		beq	.L351
 1850              	.L298:
1372:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is really 
 1851              		.loc 1 1372 0
 1852 00ac 4FF48042 		mov	r2, #16384
 1853 00b0 C4F20602 		movt	r2, 16390
 1854 00b4 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1855 00b6 01F00203 		and	r3, r1, #2
 1856 00ba DAB2     		uxtb	r2, r3
 1857 00bc C2B9     		cbnz	r2, .L297
 1858 00be 2320     		movs	r0, #35
 1859              	.LVL202:
 1860 00c0 BAE7     		b	.L291
 1861              	.LVL203:
 1862              	.L350:
1292:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
 1863              		.loc 1 1292 0
 1864 00c2 47F22F53 		movw	r3, #29999
 1865 00c6 9842     		cmp	r0, r3
 1866 00c8 01DC     		bgt	.L352
 1867              	.L309:
1294:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return error if one of the available crystal options is not availabl
 1868              		.loc 1 1294 0
 1869 00ca 2220     		movs	r0, #34
 1870              	.LVL204:
 1871 00cc B4E7     		b	.L291
 1872              	.LVL205:
 1873              	.L352:
1292:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
 1874              		.loc 1 1292 0
 1875 00ce A0F51C44 		sub	r4, r0, #39936
 1876 00d2 42F67E23 		movw	r3, #10878
 1877 00d6 413C     		subs	r4, r4, #65
 1878 00d8 C0F22D03 		movt	r3, 45
 1879 00dc 9C42     		cmp	r4, r3
 1880 00de F4D9     		bls	.L309
 1881 00e0 4FF49043 		mov	r3, #18432
 1882 00e4 C0F2E813 		movt	r3, 488
 1883 00e8 9842     		cmp	r0, r3
 1884 00ea A9DD     		ble	.L292
1294:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return error if one of the available crystal options is not availabl
 1885              		.loc 1 1294 0
 1886 00ec 2220     		movs	r0, #34
 1887              	.LVL206:
 1888 00ee A3E7     		b	.L291
 1889              	.LVL207:
 1890              	.L297:
1379:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
 1891              		.loc 1 1379 0
 1892 00f0 4FF48042 		mov	r2, #16384
 1893 00f4 C4F20602 		movt	r2, 16390
 1894 00f8 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1895 00fa 01F01003 		and	r3, r1, #16
 1896 00fe D9B2     		uxtb	r1, r3
 1897 0100 B9B1     		cbz	r1, .L300
 1898 0102 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 1899 0104 03F01001 		and	r1, r3, #16
 1900 0108 CBB2     		uxtb	r3, r1
 1901 010a 93B1     		cbz	r3, .L300
 1902 010c 40F2CE73 		movw	r3, #1998
 1903 0110 08E0     		b	.L325
 1904              	.L353:
 1905 0112 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1906 0114 9BB2     		uxth	r3, r3
 1907 0116 01F01001 		and	r1, r1, #16
 1908 011a 013B     		subs	r3, r3, #1
 1909 011c C9B2     		uxtb	r1, r1
 1910 011e 9BB2     		uxth	r3, r3
 1911 0120 39B1     		cbz	r1, .L300
1377:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 1912              		.loc 1 1377 0
 1913 0122 33B1     		cbz	r3, .L300
 1914              	.L325:
1379:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
 1915              		.loc 1 1379 0
 1916 0124 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1917 0126 01F01001 		and	r1, r1, #16
 1918 012a C9B2     		uxtb	r1, r1
 1919 012c 013B     		subs	r3, r3, #1
 1920 012e 0029     		cmp	r1, #0
 1921 0130 EFD1     		bne	.L353
 1922              	.L300:
1382:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 1923              		.loc 1 1382 0
 1924 0132 4FF48042 		mov	r2, #16384
 1925 0136 C4F20602 		movt	r2, 16390
 1926 013a 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 1927 013c 01F01003 		and	r3, r1, #16
 1928 0140 D9B2     		uxtb	r1, r3
 1929 0142 0029     		cmp	r1, #0
 1930 0144 3BD0     		beq	.L354
 1931 0146 1120     		movs	r0, #17
 1932              	.LVL208:
 1933 0148 76E7     		b	.L291
 1934              	.LVL209:
 1935              	.L293:
1315:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
 1936              		.loc 1 1315 0
 1937 014a 4FF49054 		mov	r4, #4608
 1938 014e C0F27A04 		movt	r4, 122
 1939 0152 A042     		cmp	r0, r4
 1940 0154 28DC     		bgt	.L295
1317:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 1941              		.loc 1 1317 0
 1942 0156 45F01005 		orr	r5, r5, #16
 1943              	.LVL210:
 1944 015a 45EA8204 		orr	r4, r5, r2, lsl #2
 1945 015e E5B2     		uxtb	r5, r4
1329:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 1946              		.loc 1 1329 0
 1947 0160 41F2D024 		movw	r4, #4816
 1948 0164 C0F21304 		movt	r4, 19
1317:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 1949              		.loc 1 1317 0
 1950 0168 45EAC101 		orr	r1, r5, r1, lsl #3
 1951              	.LVL211:
1329:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 1952              		.loc 1 1329 0
 1953 016c A042     		cmp	r0, r4
1324:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 1954              		.loc 1 1324 0
 1955 016e 5970     		strb	r1, [r3, #1]
1329:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 1956              		.loc 1 1329 0
 1957 0170 4BDD     		ble	.L355
 1958              	.LVL212:
 1959              	.L296:
1333:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 1960              		.loc 1 1333 0
 1961 0172 42F2A053 		movw	r3, #9632
 1962 0176 C0F22603 		movt	r3, 38
 1963 017a 9842     		cmp	r0, r3
 1964 017c 1DDD     		ble	.L311
1337:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 1965              		.loc 1 1337 0
 1966 017e 44F64034 		movw	r4, #19264
 1967 0182 C0F24C04 		movt	r4, 76
 1968 0186 A042     		cmp	r0, r4
 1969 0188 36DD     		ble	.L312
1341:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 1970              		.loc 1 1341 0
 1971 018a 49F28061 		movw	r1, #38528
 1972 018e C0F29801 		movt	r1, 152
 1973 0192 8842     		cmp	r0, r1
 1974 0194 32DD     		ble	.L313
1345:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 1975              		.loc 1 1345 0
 1976 0196 4FF43453 		mov	r3, #11520
 1977 019a C0F23113 		movt	r3, 305
 1978 019e 9842     		cmp	r0, r3
 1979 01a0 CCBF     		ite	gt
 1980 01a2 2824     		movgt	r4, #40
 1981 01a4 2024     		movle	r4, #32
 1982 01a6 60E7     		b	.L294
 1983              	.LVL213:
 1984              	.L295:
1321:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 1985              		.loc 1 1321 0
 1986 01a8 45F02004 		orr	r4, r5, #32
 1987 01ac 44EA8204 		orr	r4, r4, r2, lsl #2
 1988 01b0 E4B2     		uxtb	r4, r4
 1989 01b2 44EAC101 		orr	r1, r4, r1, lsl #3
 1990              	.LVL214:
1324:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 1991              		.loc 1 1324 0
 1992 01b6 5970     		strb	r1, [r3, #1]
 1993 01b8 DBE7     		b	.L296
 1994              	.LVL215:
 1995              	.L311:
1333:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 1996              		.loc 1 1333 0
 1997 01ba 0824     		movs	r4, #8
 1998 01bc 55E7     		b	.L294
 1999              	.LVL216:
 2000              	.L354:
1382:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 2001              		.loc 1 1382 0
 2002 01be 4FF4FA63 		mov	r3, #2000
 2003 01c2 07E0     		b	.L302
 2004              	.L356:
1388:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CL
 2005              		.loc 1 1388 0
 2006 01c4 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2007 01c6 C1F38101 		ubfx	r1, r1, #2, #2
 2008 01ca 0229     		cmp	r1, #2
 2009 01cc 09D0     		beq	.L301
 2010 01ce 013B     		subs	r3, r3, #1
 2011 01d0 9BB2     		uxth	r3, r3
1386:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2012              		.loc 1 1386 0
 2013 01d2 33B1     		cbz	r3, .L301
 2014              	.L302:
1388:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CL
 2015              		.loc 1 1388 0
 2016 01d4 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2017 01d6 C1F38101 		ubfx	r1, r1, #2, #2
 2018 01da 013B     		subs	r3, r3, #1
 2019 01dc 0229     		cmp	r1, #2
 2020 01de 9BB2     		uxth	r3, r3
 2021 01e0 F0D1     		bne	.L356
 2022              	.L301:
1391:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 2023              		.loc 1 1391 0
 2024 01e2 4FF48041 		mov	r1, #16384
 2025 01e6 C4F20601 		movt	r1, 16390
 2026 01ea 8A79     		ldrb	r2, [r1, #6]	@ zero_extendqisi2
 2027 01ec C2F38103 		ubfx	r3, r2, #2, #2
 2028 01f0 022B     		cmp	r3, #2
 2029 01f2 05D0     		beq	.L357
 2030 01f4 1A20     		movs	r0, #26
 2031              	.LVL217:
 2032 01f6 1FE7     		b	.L291
 2033              	.LVL218:
 2034              	.L312:
1337:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 2035              		.loc 1 1337 0
 2036 01f8 1024     		movs	r4, #16
 2037 01fa 36E7     		b	.L294
 2038              	.L313:
1341:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 2039              		.loc 1 1341 0
 2040 01fc 1824     		movs	r4, #24
 2041 01fe 34E7     		b	.L294
 2042              	.LVL219:
 2043              	.L357:
1397:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 2044              		.loc 1 1397 0
 2045 0200 4A79     		ldrb	r2, [r1, #5]	@ zero_extendqisi2
 2046 0202 42F02003 		orr	r3, r2, #32
 2047 0206 4B71     		strb	r3, [r1, #5]
1398:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 2048              		.loc 1 1398 0
 2049 0208 16E7     		b	.L291
 2050              	.LVL220:
 2051              	.L355:
1329:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 2052              		.loc 1 1329 0
 2053 020a 0024     		movs	r4, #0
 2054 020c 2DE7     		b	.L294
 2055              		.cfi_endproc
 2056              	.LFE11:
 2058 020e 00BF     		.section	.text.fee_fbe,"ax",%progbits
 2059              		.align	2
 2060              		.global	fee_fbe
 2061              		.thumb
 2062              		.thumb_func
 2064              	fee_fbe:
 2065              	.LFB13:
1400:../Sources/drivers/mcg/mcg.c **** 
1401:../Sources/drivers/mcg/mcg.c **** /* */
1402:../Sources/drivers/mcg/mcg.c **** 
1403:../Sources/drivers/mcg/mcg.c **** int fbe_fee
1404:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
1405:../Sources/drivers/mcg/mcg.c **** {
1406:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1407:../Sources/drivers/mcg/mcg.c **** 
1408:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1409:../Sources/drivers/mcg/mcg.c **** 
1410:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1411:../Sources/drivers/mcg/mcg.c **** 
1412:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1413:../Sources/drivers/mcg/mcg.c **** 
1414:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1415:../Sources/drivers/mcg/mcg.c **** 
1416:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1417:../Sources/drivers/mcg/mcg.c **** 
1418:../Sources/drivers/mcg/mcg.c ****     short   i, fll_ref_freq;
1419:../Sources/drivers/mcg/mcg.c ****     int     mcg_out;
1420:../Sources/drivers/mcg/mcg.c **** 
1421:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1422:../Sources/drivers/mcg/mcg.c **** 
1423:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1424:../Sources/drivers/mcg/mcg.c **** 
1425:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1426:../Sources/drivers/mcg/mcg.c **** 
1427:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1428:../Sources/drivers/mcg/mcg.c **** 
1429:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1430:../Sources/drivers/mcg/mcg.c **** 
1431:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~*/
1432:../Sources/drivers/mcg/mcg.c **** 
1433:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
1434:../Sources/drivers/mcg/mcg.c **** 
1435:../Sources/drivers/mcg/mcg.c ****     if
1436:../Sources/drivers/mcg/mcg.c ****     (
1437:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
1438:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
1439:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
1440:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
1441:../Sources/drivers/mcg/mcg.c ****         )
1442:../Sources/drivers/mcg/mcg.c ****     )               // check MCG_C2[LP] bit is not set
1443:../Sources/drivers/mcg/mcg.c ****     {
1444:../Sources/drivers/mcg/mcg.c ****         return 0x4; // return error code
1445:../Sources/drivers/mcg/mcg.c ****     }
1446:../Sources/drivers/mcg/mcg.c **** 
1447:../Sources/drivers/mcg/mcg.c ****     // The FLL ref clk divide value depends on FRDIV and the RANGE value
1448:../Sources/drivers/mcg/mcg.c **** 
1449:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
1450:../Sources/drivers/mcg/mcg.c ****     {
1451:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)))
1452:../Sources/drivers/mcg/mcg.c ****     }
1453:../Sources/drivers/mcg/mcg.c ****     else
1454:../Sources/drivers/mcg/mcg.c ****     {
1455:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIF
1456:../Sources/drivers/mcg/mcg.c ****     }
1457:../Sources/drivers/mcg/mcg.c **** 
1458:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
1459:../Sources/drivers/mcg/mcg.c **** 
1460:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
1461:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
1462:../Sources/drivers/mcg/mcg.c ****     {
1463:../Sources/drivers/mcg/mcg.c ****         return mcg_out;                 // If error code returned, return the code to calling funct
1464:../Sources/drivers/mcg/mcg.c ****     }
1465:../Sources/drivers/mcg/mcg.c **** 
1466:../Sources/drivers/mcg/mcg.c ****     // Clear CLKS field to switch CLKS mux to select FLL output
1467:../Sources/drivers/mcg/mcg.c **** 
1468:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;        // clear CLKS to select FLL output
1469:../Sources/drivers/mcg/mcg.c **** 
1470:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is FLL
1471:../Sources/drivers/mcg/mcg.c **** 
1472:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1473:../Sources/drivers/mcg/mcg.c ****     {
1474:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out early i
1475:../Sources/drivers/mcg/mcg.c ****     }
1476:../Sources/drivers/mcg/mcg.c **** 
1477:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check FLL is rea
1478:../Sources/drivers/mcg/mcg.c **** 
1479:../Sources/drivers/mcg/mcg.c ****     // Now in FEE mode
1480:../Sources/drivers/mcg/mcg.c **** 
1481:../Sources/drivers/mcg/mcg.c ****     return mcg_out;
1482:../Sources/drivers/mcg/mcg.c **** }   // fbe_fee
1483:../Sources/drivers/mcg/mcg.c **** 
1484:../Sources/drivers/mcg/mcg.c **** /* */
1485:../Sources/drivers/mcg/mcg.c **** 
1486:../Sources/drivers/mcg/mcg.c **** int fee_fbe
1487:../Sources/drivers/mcg/mcg.c **** (int crystal_val)
1488:../Sources/drivers/mcg/mcg.c **** {
 2066              		.loc 1 1488 0
 2067              		.cfi_startproc
 2068              		@ args = 0, pretend = 0, frame = 0
 2069              		@ frame_needed = 0, uses_anonymous_args = 0
 2070              		@ link register save eliminated.
 2071              	.LVL221:
1489:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1490:../Sources/drivers/mcg/mcg.c **** 
1491:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1492:../Sources/drivers/mcg/mcg.c **** 
1493:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1494:../Sources/drivers/mcg/mcg.c **** 
1495:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1496:../Sources/drivers/mcg/mcg.c **** 
1497:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1498:../Sources/drivers/mcg/mcg.c **** 
1499:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1500:../Sources/drivers/mcg/mcg.c **** 
1501:../Sources/drivers/mcg/mcg.c ****     short   i;
1502:../Sources/drivers/mcg/mcg.c **** 
1503:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1504:../Sources/drivers/mcg/mcg.c **** 
1505:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1506:../Sources/drivers/mcg/mcg.c **** 
1507:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1508:../Sources/drivers/mcg/mcg.c **** 
1509:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1510:../Sources/drivers/mcg/mcg.c **** 
1511:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1512:../Sources/drivers/mcg/mcg.c **** 
1513:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~*/
1514:../Sources/drivers/mcg/mcg.c **** 
1515:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FEE mode
1516:../Sources/drivers/mcg/mcg.c **** 
1517:../Sources/drivers/mcg/mcg.c ****     if
1518:../Sources/drivers/mcg/mcg.c ****     (
1519:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 2072              		.loc 1 1519 0
 2073 0000 4FF48043 		mov	r3, #16384
 2074 0004 C4F20603 		movt	r3, 16390
 2075 0008 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
1518:../Sources/drivers/mcg/mcg.c ****     (
 2076              		.loc 1 1518 0
 2077 000a 12F00C0F 		tst	r2, #12
 2078 000e 01D0     		beq	.L374
 2079              	.L364:
1520:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
1521:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
1522:../Sources/drivers/mcg/mcg.c ****         )
1523:../Sources/drivers/mcg/mcg.c ****     )               // check PLLS mux has selected FLL
1524:../Sources/drivers/mcg/mcg.c ****     {
1525:../Sources/drivers/mcg/mcg.c ****         return 0x2; // return error code
 2080              		.loc 1 1525 0
 2081 0010 0220     		movs	r0, #2
 2082              	.LVL222:
1526:../Sources/drivers/mcg/mcg.c ****     }
1527:../Sources/drivers/mcg/mcg.c **** 
1528:../Sources/drivers/mcg/mcg.c ****     // Set CLKS field to 2 to switch CLKS mux to select ext ref clock
1529:../Sources/drivers/mcg/mcg.c ****     // MCG is current in FEE mode so CLKS field = 0 so can just OR in new value
1530:../Sources/drivers/mcg/mcg.c **** 
1531:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(2);   // set CLKS to select ext ref clock
1532:../Sources/drivers/mcg/mcg.c ****     
1533:../Sources/drivers/mcg/mcg.c ****                                     /// Wait for clock status bits to show clock source is ext ref 
1534:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1535:../Sources/drivers/mcg/mcg.c ****     {
1536:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out early i
1537:../Sources/drivers/mcg/mcg.c ****     }
1538:../Sources/drivers/mcg/mcg.c **** 
1539:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
1540:../Sources/drivers/mcg/mcg.c **** 
1541:../Sources/drivers/mcg/mcg.c ****     // Now in FBE mode
1542:../Sources/drivers/mcg/mcg.c **** 
1543:../Sources/drivers/mcg/mcg.c ****     return crystal_val;
1544:../Sources/drivers/mcg/mcg.c **** }   // fee_fbe
 2083              		.loc 1 1544 0
 2084 0012 7047     		bx	lr
 2085              	.LVL223:
 2086              	.L374:
1520:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 2087              		.loc 1 1520 0
 2088 0014 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 2089 0016 01F01002 		and	r2, r1, #16
 2090 001a D1B2     		uxtb	r1, r2
 2091 001c 0029     		cmp	r1, #0
 2092 001e F7D1     		bne	.L364
1521:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
 2093              		.loc 1 1521 0
 2094 0020 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
1519:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 2095              		.loc 1 1519 0
 2096 0022 02F02001 		and	r1, r2, #32
 2097 0026 CAB2     		uxtb	r2, r1
 2098 0028 002A     		cmp	r2, #0
 2099 002a F1D1     		bne	.L364
1531:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(2);   // set CLKS to select ext ref clock
 2100              		.loc 1 1531 0
 2101 002c 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 2102 002e 41F08002 		orr	r2, r1, #128
 2103 0032 1A70     		strb	r2, [r3, #0]
 2104              	.LVL224:
 2105 0034 4FF4FA62 		mov	r2, #2000
 2106 0038 07E0     		b	.L361
 2107              	.LVL225:
 2108              	.L375:
1536:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out early i
 2109              		.loc 1 1536 0
 2110 003a 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 2111 003c C1F38101 		ubfx	r1, r1, #2, #2
 2112 0040 0229     		cmp	r1, #2
 2113 0042 09D0     		beq	.L360
 2114 0044 013A     		subs	r2, r2, #1
 2115 0046 92B2     		uxth	r2, r2
1534:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2116              		.loc 1 1534 0
 2117 0048 32B1     		cbz	r2, .L360
 2118              	.L361:
1536:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break;     // jump out early i
 2119              		.loc 1 1536 0
 2120 004a 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 2121 004c C1F38101 		ubfx	r1, r1, #2, #2
 2122 0050 013A     		subs	r2, r2, #1
 2123 0052 0229     		cmp	r1, #2
 2124 0054 92B2     		uxth	r2, r2
 2125 0056 F0D1     		bne	.L375
 2126              	.L360:
1539:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 2127              		.loc 1 1539 0
 2128 0058 4FF48043 		mov	r3, #16384
 2129 005c C4F20603 		movt	r3, 16390
 2130 0060 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 2131 0062 C1F38102 		ubfx	r2, r1, #2, #2
 2132 0066 022A     		cmp	r2, #2
 2133 0068 18BF     		it	ne
 2134 006a 1A20     		movne	r0, #26
 2135              	.LVL226:
 2136 006c 7047     		bx	lr
 2137              		.cfi_endproc
 2138              	.LFE13:
 2140 006e 00BF     		.section	.text.fbe_fbi,"ax",%progbits
 2141              		.align	2
 2142              		.global	fbe_fbi
 2143              		.thumb
 2144              		.thumb_func
 2146              	fbe_fbi:
 2147              	.LFB14:
1545:../Sources/drivers/mcg/mcg.c **** 
1546:../Sources/drivers/mcg/mcg.c **** /* */
1547:../Sources/drivers/mcg/mcg.c **** 
1548:../Sources/drivers/mcg/mcg.c **** int fbe_fbi
1549:../Sources/drivers/mcg/mcg.c **** (
1550:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
1551:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select
1552:../Sources/drivers/mcg/mcg.c **** )
1553:../Sources/drivers/mcg/mcg.c **** {
 2148              		.loc 1 1553 0
 2149              		.cfi_startproc
 2150              		@ args = 0, pretend = 0, frame = 0
 2151              		@ frame_needed = 0, uses_anonymous_args = 0
 2152              		@ link register save eliminated.
 2153              	.LVL227:
 2154 0000 10B4     		push	{r4}
 2155              	.LCFI6:
 2156              		.cfi_def_cfa_offset 4
 2157              		.cfi_offset 4, -4
1554:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1555:../Sources/drivers/mcg/mcg.c **** 
1556:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1557:../Sources/drivers/mcg/mcg.c **** 
1558:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1559:../Sources/drivers/mcg/mcg.c **** 
1560:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1561:../Sources/drivers/mcg/mcg.c **** 
1562:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1563:../Sources/drivers/mcg/mcg.c **** 
1564:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1565:../Sources/drivers/mcg/mcg.c **** 
1566:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
1567:../Sources/drivers/mcg/mcg.c ****     unsigned char   fcrdiv_val;
1568:../Sources/drivers/mcg/mcg.c ****     short           i;
1569:../Sources/drivers/mcg/mcg.c **** 
1570:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1571:../Sources/drivers/mcg/mcg.c **** 
1572:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1573:../Sources/drivers/mcg/mcg.c **** 
1574:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1575:../Sources/drivers/mcg/mcg.c **** 
1576:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1577:../Sources/drivers/mcg/mcg.c **** 
1578:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1579:../Sources/drivers/mcg/mcg.c **** 
1580:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1581:../Sources/drivers/mcg/mcg.c **** 
1582:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
1583:../Sources/drivers/mcg/mcg.c **** 
1584:../Sources/drivers/mcg/mcg.c ****     if
1585:../Sources/drivers/mcg/mcg.c ****     (
1586:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 2158              		.loc 1 1586 0
 2159 0002 4FF48043 		mov	r3, #16384
 2160 0006 C4F20603 		movt	r3, 16390
 2161 000a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2162 000c C2F38102 		ubfx	r2, r2, #2, #2
1585:../Sources/drivers/mcg/mcg.c ****     (
 2163              		.loc 1 1585 0
 2164 0010 022A     		cmp	r2, #2
 2165 0012 02D0     		beq	.L423
 2166              	.L392:
1587:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
1588:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
1589:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
1590:../Sources/drivers/mcg/mcg.c ****         )
1591:../Sources/drivers/mcg/mcg.c ****     )                       // check MCG_C2[LP] bit is not set
1592:../Sources/drivers/mcg/mcg.c ****     {
1593:../Sources/drivers/mcg/mcg.c ****         return 0x4;         // return error code
 2167              		.loc 1 1593 0
 2168 0014 0420     		movs	r0, #4
 2169              	.LVL228:
 2170              	.L377:
1594:../Sources/drivers/mcg/mcg.c ****     }
1595:../Sources/drivers/mcg/mcg.c **** 
1596:../Sources/drivers/mcg/mcg.c ****     // Check that the irc frequency matches the selected IRC
1597:../Sources/drivers/mcg/mcg.c **** 
1598:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
1599:../Sources/drivers/mcg/mcg.c ****     {
1600:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 31250) || (irc_freq > 39063))
1601:../Sources/drivers/mcg/mcg.c ****         {
1602:../Sources/drivers/mcg/mcg.c ****             return 0x31;
1603:../Sources/drivers/mcg/mcg.c ****         }
1604:../Sources/drivers/mcg/mcg.c ****     }
1605:../Sources/drivers/mcg/mcg.c ****     else
1606:../Sources/drivers/mcg/mcg.c ****     {
1607:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 3000000) || (irc_freq > 5000000))
1608:../Sources/drivers/mcg/mcg.c ****         {
1609:../Sources/drivers/mcg/mcg.c ****             return 0x32;    // Fast IRC freq
1610:../Sources/drivers/mcg/mcg.c ****         }
1611:../Sources/drivers/mcg/mcg.c ****     }
1612:../Sources/drivers/mcg/mcg.c **** 
1613:../Sources/drivers/mcg/mcg.c ****     // Select the required IRC
1614:../Sources/drivers/mcg/mcg.c **** 
1615:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
1616:../Sources/drivers/mcg/mcg.c ****     {
1617:../Sources/drivers/mcg/mcg.c ****         MCG_C2 |= MCG_C2_IRCS_MASK;                     // select fast IRC by setting IRCS
1618:../Sources/drivers/mcg/mcg.c ****     }
1619:../Sources/drivers/mcg/mcg.c ****     else
1620:../Sources/drivers/mcg/mcg.c ****     {
1621:../Sources/drivers/mcg/mcg.c ****         MCG_C2 &= ~MCG_C2_IRCS_MASK;                    // select slow IRC by clearing IRCS
1622:../Sources/drivers/mcg/mcg.c ****     }
1623:../Sources/drivers/mcg/mcg.c **** 
1624:../Sources/drivers/mcg/mcg.c ****     // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
1625:../Sources/drivers/mcg/mcg.c **** 
1626:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
1627:../Sources/drivers/mcg/mcg.c **** 
1628:../Sources/drivers/mcg/mcg.c ****     // Select the IRC as the CLKS mux selection
1629:../Sources/drivers/mcg/mcg.c **** 
1630:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
1631:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                      // clear CLKS bits
1632:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK);   // select IRC as MCGOUT and enable IREFS
1633:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;  // update MCG_C1
1634:../Sources/drivers/mcg/mcg.c **** 
1635:../Sources/drivers/mcg/mcg.c ****     // wait until internal reference switches to requested irc.
1636:../Sources/drivers/mcg/mcg.c **** 
1637:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
1638:../Sources/drivers/mcg/mcg.c ****     {
1639:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
1640:../Sources/drivers/mcg/mcg.c ****         {
1641:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears before lo
1642:../Sources/drivers/mcg/mcg.c ****         }
1643:../Sources/drivers/mcg/mcg.c **** 
1644:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IRCST_MASK) return 0x13;       // check bit is really clear and return wit
1645:../Sources/drivers/mcg/mcg.c ****     }
1646:../Sources/drivers/mcg/mcg.c ****     else
1647:../Sources/drivers/mcg/mcg.c ****     {
1648:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
1649:../Sources/drivers/mcg/mcg.c ****         {
1650:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets before loop
1651:../Sources/drivers/mcg/mcg.c ****         }
1652:../Sources/drivers/mcg/mcg.c **** 
1653:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IRCST_MASK)) return 0x14;    // check bit is really set and return with 
1654:../Sources/drivers/mcg/mcg.c ****     }
1655:../Sources/drivers/mcg/mcg.c **** 
1656:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
1657:../Sources/drivers/mcg/mcg.c **** 
1658:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1659:../Sources/drivers/mcg/mcg.c ****     {
1660:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;     // jump out early i
1661:../Sources/drivers/mcg/mcg.c ****     }
1662:../Sources/drivers/mcg/mcg.c **** 
1663:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19;   // check IRC is rea
1664:../Sources/drivers/mcg/mcg.c **** 
1665:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to set
1666:../Sources/drivers/mcg/mcg.c **** 
1667:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1668:../Sources/drivers/mcg/mcg.c ****     {
1669:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
1670:../Sources/drivers/mcg/mcg.c ****     }
1671:../Sources/drivers/mcg/mcg.c **** 
1672:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
1673:../Sources/drivers/mcg/mcg.c **** 
1674:../Sources/drivers/mcg/mcg.c ****     // Now in FBI mode
1675:../Sources/drivers/mcg/mcg.c **** 
1676:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
1677:../Sources/drivers/mcg/mcg.c ****     {
1678:../Sources/drivers/mcg/mcg.c ****         fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate th
1679:../Sources/drivers/mcg/mcg.c ****         return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided by FC
1680:../Sources/drivers/mcg/mcg.c ****     }
1681:../Sources/drivers/mcg/mcg.c ****     else
1682:../Sources/drivers/mcg/mcg.c ****     {
1683:../Sources/drivers/mcg/mcg.c ****         return irc_freq;                // MCGOUT frequency equals slow IRC frequency
1684:../Sources/drivers/mcg/mcg.c ****     }
1685:../Sources/drivers/mcg/mcg.c **** }   //fbe_fbi
 2171              		.loc 1 1685 0
 2172 0016 10BC     		pop	{r4}
 2173 0018 7047     		bx	lr
 2174              	.LVL229:
 2175              	.L423:
1587:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 2176              		.loc 1 1587 0
 2177 001a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2178 001c 02F01002 		and	r2, r2, #16
 2179 0020 D2B2     		uxtb	r2, r2
 2180 0022 002A     		cmp	r2, #0
 2181 0024 F6D1     		bne	.L392
1588:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 2182              		.loc 1 1588 0
 2183 0026 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2184 0028 02F02002 		and	r2, r2, #32
 2185 002c D2B2     		uxtb	r2, r2
 2186 002e 002A     		cmp	r2, #0
 2187 0030 F0D1     		bne	.L392
1589:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 2188              		.loc 1 1589 0
 2189 0032 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
1586:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 2190              		.loc 1 1586 0
 2191 0034 02F00202 		and	r2, r2, #2
 2192 0038 D2B2     		uxtb	r2, r2
 2193 003a 002A     		cmp	r2, #0
 2194 003c EAD1     		bne	.L392
1598:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
 2195              		.loc 1 1598 0
 2196 003e 41B9     		cbnz	r1, .L378
1600:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 31250) || (irc_freq > 39063))
 2197              		.loc 1 1600 0
 2198 0040 A0F5F444 		sub	r4, r0, #31232
 2199 0044 123C     		subs	r4, r4, #18
 2200 0046 41F68562 		movw	r2, #7813
 2201 004a 9442     		cmp	r4, r2
 2202 004c 0DD9     		bls	.L424
1602:../Sources/drivers/mcg/mcg.c ****             return 0x31;
 2203              		.loc 1 1602 0
 2204 004e 3120     		movs	r0, #49
 2205              	.LVL230:
 2206 0050 E1E7     		b	.L377
 2207              	.LVL231:
 2208              	.L378:
1607:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 3000000) || (irc_freq > 5000000))
 2209              		.loc 1 1607 0
 2210 0052 A0F53714 		sub	r4, r0, #2998272
 2211 0056 48F28042 		movw	r2, #33920
 2212 005a A4F5D864 		sub	r4, r4, #1728
 2213 005e C0F21E02 		movt	r2, 30
 2214 0062 9442     		cmp	r4, r2
 2215 0064 28D9     		bls	.L425
1609:../Sources/drivers/mcg/mcg.c ****             return 0x32;    // Fast IRC freq
 2216              		.loc 1 1609 0
 2217 0066 3220     		movs	r0, #50
 2218              	.LVL232:
 2219 0068 D5E7     		b	.L377
 2220              	.LVL233:
 2221              	.L424:
1621:../Sources/drivers/mcg/mcg.c ****         MCG_C2 &= ~MCG_C2_IRCS_MASK;                    // select slow IRC by clearing IRCS
 2222              		.loc 1 1621 0
 2223 006a 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 2224 006c 04F0FE02 		and	r2, r4, #254
 2225 0070 5A70     		strb	r2, [r3, #1]
1626:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 2226              		.loc 1 1626 0
 2227 0072 5C79     		ldrb	r4, [r3, #5]	@ zero_extendqisi2
 2228 0074 04F0DF02 		and	r2, r4, #223
 2229 0078 5A71     		strb	r2, [r3, #5]
1630:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 2230              		.loc 1 1630 0
 2231 007a 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 2232              	.LVL234:
1631:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                      // clear CLKS bits
 2233              		.loc 1 1631 0
 2234 007c 04F03F02 		and	r2, r4, #63
 2235              	.LVL235:
1632:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK);   // select IRC as MCGOUT and enable IREFS
 2236              		.loc 1 1632 0
 2237 0080 42F04404 		orr	r4, r2, #68
 2238              	.LVL236:
1633:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;  // update MCG_C1
 2239              		.loc 1 1633 0
 2240 0084 1C70     		strb	r4, [r3, #0]
 2241              	.LVL237:
 2242 0086 4FF4FA62 		mov	r2, #2000
 2243 008a 06E0     		b	.L382
 2244              	.LVL238:
 2245              	.L426:
1641:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears before lo
 2246              		.loc 1 1641 0
 2247 008c 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2248 008e 14F0010F 		tst	r4, #1
 2249 0092 08D0     		beq	.L381
 2250 0094 013A     		subs	r2, r2, #1
 2251 0096 92B2     		uxth	r2, r2
1639:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
 2252              		.loc 1 1639 0
 2253 0098 2AB1     		cbz	r2, .L381
 2254              	.L382:
1641:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears before lo
 2255              		.loc 1 1641 0
 2256 009a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2257 009c 013A     		subs	r2, r2, #1
 2258 009e 14F0010F 		tst	r4, #1
 2259 00a2 92B2     		uxth	r2, r2
 2260 00a4 F2D1     		bne	.L426
 2261              	.L381:
1644:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IRCST_MASK) return 0x13;       // check bit is really clear and return wit
 2262              		.loc 1 1644 0
 2263 00a6 4FF48043 		mov	r3, #16384
 2264 00aa C4F20603 		movt	r3, 16390
 2265 00ae 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2266 00b0 D307     		lsls	r3, r2, #31
 2267 00b2 28D5     		bpl	.L385
 2268 00b4 1320     		movs	r0, #19
 2269              	.LVL239:
 2270 00b6 AEE7     		b	.L377
 2271              	.LVL240:
 2272              	.L425:
1617:../Sources/drivers/mcg/mcg.c ****         MCG_C2 |= MCG_C2_IRCS_MASK;                     // select fast IRC by setting IRCS
 2273              		.loc 1 1617 0
 2274 00b8 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 2275 00ba 44F00102 		orr	r2, r4, #1
 2276 00be 5A70     		strb	r2, [r3, #1]
1626:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 2277              		.loc 1 1626 0
 2278 00c0 5C79     		ldrb	r4, [r3, #5]	@ zero_extendqisi2
 2279 00c2 04F0DF02 		and	r2, r4, #223
 2280 00c6 5A71     		strb	r2, [r3, #5]
1630:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 2281              		.loc 1 1630 0
 2282 00c8 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 2283              	.LVL241:
1631:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                      // clear CLKS bits
 2284              		.loc 1 1631 0
 2285 00ca 04F03F02 		and	r2, r4, #63
 2286              	.LVL242:
1632:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK);   // select IRC as MCGOUT and enable IREFS
 2287              		.loc 1 1632 0
 2288 00ce 42F04404 		orr	r4, r2, #68
 2289              	.LVL243:
1633:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;  // update MCG_C1
 2290              		.loc 1 1633 0
 2291 00d2 1C70     		strb	r4, [r3, #0]
 2292              	.LVL244:
 2293 00d4 4FF4FA62 		mov	r2, #2000
 2294 00d8 06E0     		b	.L380
 2295              	.LVL245:
 2296              	.L427:
1650:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets before loop
 2297              		.loc 1 1650 0
 2298 00da 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2299 00dc 14F0010F 		tst	r4, #1
 2300 00e0 08D1     		bne	.L384
 2301 00e2 013A     		subs	r2, r2, #1
 2302 00e4 92B2     		uxth	r2, r2
1648:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
 2303              		.loc 1 1648 0
 2304 00e6 2AB1     		cbz	r2, .L384
 2305              	.L380:
1650:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets before loop
 2306              		.loc 1 1650 0
 2307 00e8 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2308 00ea 013A     		subs	r2, r2, #1
 2309 00ec 14F0010F 		tst	r4, #1
 2310 00f0 92B2     		uxth	r2, r2
 2311 00f2 F2D0     		beq	.L427
 2312              	.L384:
1653:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IRCST_MASK)) return 0x14;    // check bit is really set and return with 
 2313              		.loc 1 1653 0
 2314 00f4 4FF48043 		mov	r3, #16384
 2315 00f8 C4F20603 		movt	r3, 16390
 2316 00fc 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2317 00fe D307     		lsls	r3, r2, #31
 2318 0100 01D4     		bmi	.L385
 2319 0102 1420     		movs	r0, #20
 2320              	.LVL246:
 2321 0104 87E7     		b	.L377
 2322              	.LVL247:
 2323              	.L385:
1660:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;     // jump out early i
 2324              		.loc 1 1660 0
 2325 0106 4FF48042 		mov	r2, #16384
1633:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;  // update MCG_C1
 2326              		.loc 1 1633 0
 2327 010a 4FF4FA63 		mov	r3, #2000
1660:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;     // jump out early i
 2328              		.loc 1 1660 0
 2329 010e C4F20602 		movt	r2, 16390
 2330 0112 07E0     		b	.L383
 2331              	.LVL248:
 2332              	.L428:
 2333 0114 9479     		ldrb	r4, [r2, #6]	@ zero_extendqisi2
 2334 0116 C4F38104 		ubfx	r4, r4, #2, #2
 2335 011a 012C     		cmp	r4, #1
 2336 011c 09D0     		beq	.L386
 2337 011e 013B     		subs	r3, r3, #1
 2338 0120 9BB2     		uxth	r3, r3
1658:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2339              		.loc 1 1658 0
 2340 0122 33B1     		cbz	r3, .L386
 2341              	.L383:
1660:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;     // jump out early i
 2342              		.loc 1 1660 0
 2343 0124 9479     		ldrb	r4, [r2, #6]	@ zero_extendqisi2
 2344 0126 C4F38104 		ubfx	r4, r4, #2, #2
 2345 012a 013B     		subs	r3, r3, #1
 2346 012c 012C     		cmp	r4, #1
 2347 012e 9BB2     		uxth	r3, r3
 2348 0130 F0D1     		bne	.L428
 2349              	.L386:
1663:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19;   // check IRC is rea
 2350              		.loc 1 1663 0
 2351 0132 4FF48043 		mov	r3, #16384
 2352 0136 C4F20603 		movt	r3, 16390
 2353 013a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2354 013c C2F38102 		ubfx	r2, r2, #2, #2
 2355 0140 012A     		cmp	r2, #1
 2356 0142 01D0     		beq	.L429
 2357 0144 1920     		movs	r0, #25
 2358              	.LVL249:
 2359 0146 66E7     		b	.L377
 2360              	.LVL250:
 2361              	.L429:
 2362 0148 4FF4FA62 		mov	r2, #2000
 2363 014c 08E0     		b	.L388
 2364              	.L430:
1669:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
 2365              		.loc 1 1669 0
 2366 014e 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2367 0150 92B2     		uxth	r2, r2
 2368 0152 04F01004 		and	r4, r4, #16
 2369 0156 013A     		subs	r2, r2, #1
 2370 0158 E4B2     		uxtb	r4, r4
 2371 015a 92B2     		uxth	r2, r2
 2372 015c 3CB9     		cbnz	r4, .L387
1667:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2373              		.loc 1 1667 0
 2374 015e 32B1     		cbz	r2, .L387
 2375              	.L388:
1669:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
 2376              		.loc 1 1669 0
 2377 0160 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2378 0162 04F01004 		and	r4, r4, #16
 2379 0166 E4B2     		uxtb	r4, r4
 2380 0168 013A     		subs	r2, r2, #1
 2381 016a 002C     		cmp	r4, #0
 2382 016c EFD0     		beq	.L430
 2383              	.L387:
1672:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 2384              		.loc 1 1672 0
 2385 016e 4FF48043 		mov	r3, #16384
 2386 0172 C4F20603 		movt	r3, 16390
 2387 0176 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2388 0178 02F01002 		and	r2, r2, #16
 2389 017c D2B2     		uxtb	r2, r2
 2390 017e 0AB9     		cbnz	r2, .L431
 2391 0180 1220     		movs	r0, #18
 2392              	.LVL251:
 2393 0182 48E7     		b	.L377
 2394              	.LVL252:
 2395              	.L431:
1676:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 2396              		.loc 1 1676 0
 2397 0184 0029     		cmp	r1, #0
 2398 0186 3FF446AF 		beq	.L377
1678:../Sources/drivers/mcg/mcg.c ****         fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate th
 2399              		.loc 1 1678 0
 2400 018a 197A     		ldrb	r1, [r3, #8]	@ zero_extendqisi2
 2401              	.LVL253:
 2402 018c 0122     		movs	r2, #1
 2403 018e C1F34203 		ubfx	r3, r1, #1, #3
 2404 0192 02FA03F1 		lsl	r1, r2, r3
 2405              	.LVL254:
1679:../Sources/drivers/mcg/mcg.c ****         return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided by FC
 2406              		.loc 1 1679 0
 2407 0196 CBB2     		uxtb	r3, r1
 2408 0198 90FBF3F0 		sdiv	r0, r0, r3
 2409              	.LVL255:
 2410 019c 3BE7     		b	.L377
 2411              		.cfi_endproc
 2412              	.LFE14:
 2414 019e 00BF     		.section	.text.fbi_fbe,"ax",%progbits
 2415              		.align	2
 2416              		.global	fbi_fbe
 2417              		.thumb
 2418              		.thumb_func
 2420              	fbi_fbe:
 2421              	.LFB15:
1686:../Sources/drivers/mcg/mcg.c **** 
1687:../Sources/drivers/mcg/mcg.c **** /* */
1688:../Sources/drivers/mcg/mcg.c **** 
1689:../Sources/drivers/mcg/mcg.c **** int fbi_fbe
1690:../Sources/drivers/mcg/mcg.c **** (
1691:../Sources/drivers/mcg/mcg.c ****     int             crystal_val,
1692:../Sources/drivers/mcg/mcg.c ****     unsigned char   hgo_val,
1693:../Sources/drivers/mcg/mcg.c ****     unsigned char   erefs_val
1694:../Sources/drivers/mcg/mcg.c **** )
1695:../Sources/drivers/mcg/mcg.c **** {
 2422              		.loc 1 1695 0
 2423              		.cfi_startproc
 2424              		@ args = 0, pretend = 0, frame = 0
 2425              		@ frame_needed = 0, uses_anonymous_args = 0
 2426              		@ link register save eliminated.
 2427              	.LVL256:
 2428 0000 30B4     		push	{r4, r5}
 2429              	.LCFI7:
 2430              		.cfi_def_cfa_offset 8
 2431              		.cfi_offset 4, -8
 2432              		.cfi_offset 5, -4
1696:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1697:../Sources/drivers/mcg/mcg.c **** 
1698:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1699:../Sources/drivers/mcg/mcg.c **** 
1700:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1701:../Sources/drivers/mcg/mcg.c **** 
1702:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1703:../Sources/drivers/mcg/mcg.c **** 
1704:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1705:../Sources/drivers/mcg/mcg.c **** 
1706:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1707:../Sources/drivers/mcg/mcg.c **** 
1708:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
1709:../Sources/drivers/mcg/mcg.c ****     unsigned char   frdiv_val;
1710:../Sources/drivers/mcg/mcg.c ****     short           i;
1711:../Sources/drivers/mcg/mcg.c **** 
1712:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1713:../Sources/drivers/mcg/mcg.c **** 
1714:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1715:../Sources/drivers/mcg/mcg.c **** 
1716:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1717:../Sources/drivers/mcg/mcg.c **** 
1718:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1719:../Sources/drivers/mcg/mcg.c **** 
1720:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1721:../Sources/drivers/mcg/mcg.c **** 
1722:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~*/
1723:../Sources/drivers/mcg/mcg.c **** 
1724:../Sources/drivers/mcg/mcg.c ****     // check if in FBI mode
1725:../Sources/drivers/mcg/mcg.c **** 
1726:../Sources/drivers/mcg/mcg.c ****     if
1727:../Sources/drivers/mcg/mcg.c ****     (
1728:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 2433              		.loc 1 1728 0
 2434 0002 4FF48043 		mov	r3, #16384
 2435 0006 C4F20603 		movt	r3, 16390
 2436 000a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2437 000c C4F38104 		ubfx	r4, r4, #2, #2
1727:../Sources/drivers/mcg/mcg.c ****     (
 2438              		.loc 1 1727 0
 2439 0010 012C     		cmp	r4, #1
 2440 0012 02D0     		beq	.L491
 2441              	.L448:
1729:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
1730:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
1731:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
1732:../Sources/drivers/mcg/mcg.c ****         )
1733:../Sources/drivers/mcg/mcg.c ****     )                       // check LP bit is clear
1734:../Sources/drivers/mcg/mcg.c ****     {
1735:../Sources/drivers/mcg/mcg.c ****         return 0x3;         // MCG not in correct mode return fail code
 2442              		.loc 1 1735 0
 2443 0014 0320     		movs	r0, #3
 2444              	.LVL257:
 2445              	.L433:
1736:../Sources/drivers/mcg/mcg.c ****     }
1737:../Sources/drivers/mcg/mcg.c **** 
1738:../Sources/drivers/mcg/mcg.c ****     // check external frequency is less than the maximum frequency
1739:../Sources/drivers/mcg/mcg.c **** 
1740:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
1741:../Sources/drivers/mcg/mcg.c ****     {
1742:../Sources/drivers/mcg/mcg.c ****         return 0x21;
1743:../Sources/drivers/mcg/mcg.c ****     }
1744:../Sources/drivers/mcg/mcg.c **** 
1745:../Sources/drivers/mcg/mcg.c ****     // check crystal frequency is within spec. if crystal osc is being used
1746:../Sources/drivers/mcg/mcg.c **** 
1747:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
1748:../Sources/drivers/mcg/mcg.c ****     {
1749:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
1750:../Sources/drivers/mcg/mcg.c ****         {
1751:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return error if one of the available crystal options is not availabl
1752:../Sources/drivers/mcg/mcg.c ****         }
1753:../Sources/drivers/mcg/mcg.c ****     }
1754:../Sources/drivers/mcg/mcg.c **** 
1755:../Sources/drivers/mcg/mcg.c ****     // make sure HGO will never be greater than 1. Could return an error instead if desired.
1756:../Sources/drivers/mcg/mcg.c **** 
1757:../Sources/drivers/mcg/mcg.c ****     if(hgo_val > 0)
1758:../Sources/drivers/mcg/mcg.c ****     {
1759:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
1760:../Sources/drivers/mcg/mcg.c ****     }
1761:../Sources/drivers/mcg/mcg.c **** 
1762:../Sources/drivers/mcg/mcg.c ****     // configure the MCG_C2 register
1763:../Sources/drivers/mcg/mcg.c ****     // the RANGE value is determined by the external frequency. Since the RANGE parameter affects t
1764:../Sources/drivers/mcg/mcg.c ****     // it still needs to be set correctly even if the oscillator is not being used
1765:../Sources/drivers/mcg/mcg.c **** 
1766:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
1767:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
1768:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
1769:../Sources/drivers/mcg/mcg.c ****     {
1770:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
1771:../Sources/drivers/mcg/mcg.c ****     }
1772:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
1773:../Sources/drivers/mcg/mcg.c ****     {
1774:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
1775:../Sources/drivers/mcg/mcg.c ****     }
1776:../Sources/drivers/mcg/mcg.c ****     else
1777:../Sources/drivers/mcg/mcg.c ****     {
1778:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
1779:../Sources/drivers/mcg/mcg.c ****     }
1780:../Sources/drivers/mcg/mcg.c **** 
1781:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
1782:../Sources/drivers/mcg/mcg.c **** 
1783:../Sources/drivers/mcg/mcg.c ****     // determine FRDIV based on reference clock frequency
1784:../Sources/drivers/mcg/mcg.c ****     // since the external frequency has already been checked only the maximum frequency for each FR
1785:../Sources/drivers/mcg/mcg.c **** 
1786:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
1787:../Sources/drivers/mcg/mcg.c ****     {
1788:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 0;
1789:../Sources/drivers/mcg/mcg.c ****     }
1790:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
1791:../Sources/drivers/mcg/mcg.c ****     {
1792:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 1;
1793:../Sources/drivers/mcg/mcg.c ****     }
1794:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
1795:../Sources/drivers/mcg/mcg.c ****     {
1796:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 2;
1797:../Sources/drivers/mcg/mcg.c ****     }
1798:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
1799:../Sources/drivers/mcg/mcg.c ****     {
1800:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 3;
1801:../Sources/drivers/mcg/mcg.c ****     }
1802:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
1803:../Sources/drivers/mcg/mcg.c ****     {
1804:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 4;
1805:../Sources/drivers/mcg/mcg.c ****     }
1806:../Sources/drivers/mcg/mcg.c ****     else
1807:../Sources/drivers/mcg/mcg.c ****     {
1808:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 5;
1809:../Sources/drivers/mcg/mcg.c ****     }
1810:../Sources/drivers/mcg/mcg.c **** 
1811:../Sources/drivers/mcg/mcg.c ****     // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1812:../Sources/drivers/mcg/mcg.c ****     // If IRCLK is required it must be enabled outside of this driver, existing state will be maint
1813:../Sources/drivers/mcg/mcg.c ****     // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1814:../Sources/drivers/mcg/mcg.c **** 
1815:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
1816:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
1817:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
1818:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
1819:../Sources/drivers/mcg/mcg.c **** 
1820:../Sources/drivers/mcg/mcg.c ****     // if the external oscillator is used need to wait for OSCINIT to set
1821:../Sources/drivers/mcg/mcg.c **** 
1822:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
1823:../Sources/drivers/mcg/mcg.c ****     {
1824:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 10000; i++)
1825:../Sources/drivers/mcg/mcg.c ****         {
1826:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
1827:../Sources/drivers/mcg/mcg.c ****         }
1828:../Sources/drivers/mcg/mcg.c **** 
1829:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is really 
1830:../Sources/drivers/mcg/mcg.c ****     }
1831:../Sources/drivers/mcg/mcg.c **** 
1832:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
1833:../Sources/drivers/mcg/mcg.c **** 
1834:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1835:../Sources/drivers/mcg/mcg.c ****     {
1836:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
1837:../Sources/drivers/mcg/mcg.c ****     }
1838:../Sources/drivers/mcg/mcg.c **** 
1839:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
1840:../Sources/drivers/mcg/mcg.c **** 
1841:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
1842:../Sources/drivers/mcg/mcg.c **** 
1843:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
1844:../Sources/drivers/mcg/mcg.c ****     {
1845:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CL
1846:../Sources/drivers/mcg/mcg.c ****     }
1847:../Sources/drivers/mcg/mcg.c **** 
1848:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
1849:../Sources/drivers/mcg/mcg.c **** 
1850:../Sources/drivers/mcg/mcg.c ****     // Now in FBE
1851:../Sources/drivers/mcg/mcg.c ****     // It is recommended that the clock monitor is enabled when using an external clock as the cloc
1852:../Sources/drivers/mcg/mcg.c ****     // It is enabled here but can be removed if this is not required.
1853:../Sources/drivers/mcg/mcg.c **** 
1854:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
1855:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
1856:../Sources/drivers/mcg/mcg.c **** }                       // fbi_fbe
 2446              		.loc 1 1856 0
 2447 0016 30BC     		pop	{r4, r5}
 2448 0018 7047     		bx	lr
 2449              	.LVL258:
 2450              	.L491:
1729:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 2451              		.loc 1 1729 0
 2452 001a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2453 001c 04F01004 		and	r4, r4, #16
 2454 0020 E4B2     		uxtb	r4, r4
 2455 0022 002C     		cmp	r4, #0
 2456 0024 F6D0     		beq	.L448
1730:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 2457              		.loc 1 1730 0
 2458 0026 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2459 0028 04F02004 		and	r4, r4, #32
 2460 002c E4B2     		uxtb	r4, r4
 2461 002e 002C     		cmp	r4, #0
 2462 0030 F0D1     		bne	.L448
1731:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 2463              		.loc 1 1731 0
 2464 0032 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
1728:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 2465              		.loc 1 1728 0
 2466 0034 03F00203 		and	r3, r3, #2
 2467 0038 DBB2     		uxtb	r3, r3
 2468 003a 002B     		cmp	r3, #0
 2469 003c EAD1     		bne	.L448
1740:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
 2470              		.loc 1 1740 0
 2471 003e 4FF28003 		movw	r3, #61568
 2472 0042 C0F2FA23 		movt	r3, 762
 2473 0046 9842     		cmp	r0, r3
 2474 0048 01DD     		ble	.L492
1742:../Sources/drivers/mcg/mcg.c ****         return 0x21;
 2475              		.loc 1 1742 0
 2476 004a 2120     		movs	r0, #33
 2477              	.LVL259:
 2478 004c E3E7     		b	.L433
 2479              	.LVL260:
 2480              	.L492:
1747:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 2481              		.loc 1 1747 0
 2482 004e A2B1     		cbz	r2, .L434
1749:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
 2483              		.loc 1 1749 0
 2484 0050 47F22F53 		movw	r3, #29999
 2485 0054 9842     		cmp	r0, r3
 2486 0056 01DC     		bgt	.L493
 2487              	.L452:
1751:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return error if one of the available crystal options is not availabl
 2488              		.loc 1 1751 0
 2489 0058 2220     		movs	r0, #34
 2490              	.LVL261:
 2491 005a DCE7     		b	.L433
 2492              	.LVL262:
 2493              	.L493:
1749:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
 2494              		.loc 1 1749 0
 2495 005c A0F51C43 		sub	r3, r0, #39936
 2496 0060 42F67E24 		movw	r4, #10878
 2497 0064 413B     		subs	r3, r3, #65
 2498 0066 C0F22D04 		movt	r4, 45
 2499 006a A342     		cmp	r3, r4
 2500 006c F4D9     		bls	.L452
 2501 006e 4FF49043 		mov	r3, #18432
 2502 0072 C0F2E813 		movt	r3, 488
 2503 0076 9842     		cmp	r0, r3
 2504 0078 EEDC     		bgt	.L452
 2505              	.L434:
1766:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 2506              		.loc 1 1766 0
 2507 007a 4FF48043 		mov	r3, #16384
 2508 007e C4F20603 		movt	r3, 16390
1759:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 2509              		.loc 1 1759 0
 2510 0082 0031     		adds	r1, r1, #0
 2511              	.LVL263:
1766:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 2512              		.loc 1 1766 0
 2513 0084 5D78     		ldrb	r5, [r3, #1]	@ zero_extendqisi2
1767:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 2514              		.loc 1 1767 0
 2515 0086 05F0C304 		and	r4, r5, #195
1768:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 2516              		.loc 1 1768 0
 2517 008a 49F64045 		movw	r5, #40000
1759:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 2518              		.loc 1 1759 0
 2519 008e 18BF     		it	ne
 2520 0090 0121     		movne	r1, #1
 2521              	.LVL264:
1768:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 2522              		.loc 1 1768 0
 2523 0092 A842     		cmp	r0, r5
 2524 0094 60DC     		bgt	.L435
1770:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 2525              		.loc 1 1770 0
 2526 0096 44EA8204 		orr	r4, r4, r2, lsl #2
 2527              	.LVL265:
 2528 009a E4B2     		uxtb	r4, r4
 2529 009c 44EAC101 		orr	r1, r4, r1, lsl #3
 2530              	.LVL266:
1781:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 2531              		.loc 1 1781 0
 2532 00a0 5970     		strb	r1, [r3, #1]
1788:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 0;
 2533              		.loc 1 1788 0
 2534 00a2 0023     		movs	r3, #0
 2535              	.LVL267:
 2536              	.L436:
1815:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 2537              		.loc 1 1815 0
 2538 00a4 4FF48041 		mov	r1, #16384
 2539 00a8 C4F20601 		movt	r1, 16390
 2540 00ac 0C78     		ldrb	r4, [r1, #0]	@ zero_extendqisi2
 2541              	.LVL268:
1816:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
 2542              		.loc 1 1816 0
 2543 00ae 04F00304 		and	r4, r4, #3
 2544              	.LVL269:
1817:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 2545              		.loc 1 1817 0
 2546 00b2 44F08004 		orr	r4, r4, #128
 2547 00b6 44EAC303 		orr	r3, r4, r3, lsl #3
 2548              	.LVL270:
1818:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 2549              		.loc 1 1818 0
 2550 00ba 0B70     		strb	r3, [r1, #0]
1822:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 2551              		.loc 1 1822 0
 2552 00bc F2B1     		cbz	r2, .L439
 2553 00be 42F21073 		movw	r3, #10000
 2554              	.LVL271:
1826:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
 2555              		.loc 1 1826 0
 2556 00c2 0A46     		mov	r2, r1
 2557              	.LVL272:
 2558 00c4 08E0     		b	.L441
 2559              	.LVL273:
 2560              	.L494:
 2561 00c6 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2562 00c8 9BB2     		uxth	r3, r3
 2563 00ca 01F00201 		and	r1, r1, #2
 2564 00ce 013B     		subs	r3, r3, #1
 2565 00d0 C9B2     		uxtb	r1, r1
 2566 00d2 9BB2     		uxth	r3, r3
 2567 00d4 39B9     		cbnz	r1, .L440
1824:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 10000; i++)
 2568              		.loc 1 1824 0
 2569 00d6 33B1     		cbz	r3, .L440
 2570              	.L441:
1826:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
 2571              		.loc 1 1826 0
 2572 00d8 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2573 00da 01F00201 		and	r1, r1, #2
 2574 00de C9B2     		uxtb	r1, r1
 2575 00e0 013B     		subs	r3, r3, #1
 2576 00e2 0029     		cmp	r1, #0
 2577 00e4 EFD0     		beq	.L494
 2578              	.L440:
1829:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is really 
 2579              		.loc 1 1829 0
 2580 00e6 4FF48042 		mov	r2, #16384
 2581 00ea C4F20602 		movt	r2, 16390
 2582 00ee 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2583 00f0 01F00203 		and	r3, r1, #2
 2584 00f4 DAB2     		uxtb	r2, r3
 2585 00f6 0AB9     		cbnz	r2, .L439
 2586 00f8 2320     		movs	r0, #35
 2587              	.LVL274:
 2588 00fa 8CE7     		b	.L433
 2589              	.LVL275:
 2590              	.L439:
1836:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
 2591              		.loc 1 1836 0
 2592 00fc 4FF48042 		mov	r2, #16384
 2593 0100 C4F20602 		movt	r2, 16390
 2594 0104 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2595 0106 01F01003 		and	r3, r1, #16
 2596 010a D9B2     		uxtb	r1, r3
 2597 010c C1B1     		cbz	r1, .L442
 2598 010e 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 2599 0110 03F01001 		and	r1, r3, #16
 2600 0114 C9B2     		uxtb	r1, r1
 2601 0116 40F2CF73 		movw	r3, #1999
 2602 011a 89B1     		cbz	r1, .L442
 2603 011c 013B     		subs	r3, r3, #1
 2604 011e 08E0     		b	.L468
 2605              	.L495:
 2606 0120 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2607 0122 9BB2     		uxth	r3, r3
 2608 0124 01F01001 		and	r1, r1, #16
 2609 0128 013B     		subs	r3, r3, #1
 2610 012a C9B2     		uxtb	r1, r1
 2611 012c 9BB2     		uxth	r3, r3
 2612 012e 39B1     		cbz	r1, .L442
1834:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2613              		.loc 1 1834 0
 2614 0130 33B1     		cbz	r3, .L442
 2615              	.L468:
1836:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
 2616              		.loc 1 1836 0
 2617 0132 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2618 0134 01F01001 		and	r1, r1, #16
 2619 0138 C9B2     		uxtb	r1, r1
 2620 013a 013B     		subs	r3, r3, #1
 2621 013c 0029     		cmp	r1, #0
 2622 013e EFD1     		bne	.L495
 2623              	.L442:
1839:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 2624              		.loc 1 1839 0
 2625 0140 4FF48042 		mov	r2, #16384
 2626 0144 C4F20602 		movt	r2, 16390
 2627 0148 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2628 014a 01F01003 		and	r3, r1, #16
 2629 014e D9B2     		uxtb	r1, r3
 2630 0150 0029     		cmp	r1, #0
 2631 0152 3BD0     		beq	.L496
 2632 0154 1120     		movs	r0, #17
 2633              	.LVL276:
 2634 0156 5EE7     		b	.L433
 2635              	.LVL277:
 2636              	.L435:
1772:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
 2637              		.loc 1 1772 0
 2638 0158 4FF49055 		mov	r5, #4608
 2639 015c C0F27A05 		movt	r5, 122
 2640 0160 A842     		cmp	r0, r5
 2641 0162 2ADC     		bgt	.L437
1774:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 2642              		.loc 1 1774 0
 2643 0164 44F01005 		orr	r5, r4, #16
 2644 0168 45EA8204 		orr	r4, r5, r2, lsl #2
 2645              	.LVL278:
 2646 016c E5B2     		uxtb	r5, r4
1786:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 2647              		.loc 1 1786 0
 2648 016e 41F2D024 		movw	r4, #4816
 2649 0172 C0F21304 		movt	r4, 19
1774:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 2650              		.loc 1 1774 0
 2651 0176 45EAC101 		orr	r1, r5, r1, lsl #3
 2652              	.LVL279:
1786:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 2653              		.loc 1 1786 0
 2654 017a A042     		cmp	r0, r4
1781:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 2655              		.loc 1 1781 0
 2656 017c 5970     		strb	r1, [r3, #1]
1786:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 2657              		.loc 1 1786 0
 2658 017e 46DD     		ble	.L497
 2659              	.LVL280:
 2660              	.L438:
1790:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 2661              		.loc 1 1790 0
 2662 0180 42F2A053 		movw	r3, #9632
 2663 0184 C0F22603 		movt	r3, 38
 2664 0188 9842     		cmp	r0, r3
 2665 018a 14DD     		ble	.L454
1794:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 2666              		.loc 1 1794 0
 2667 018c 44F64034 		movw	r4, #19264
 2668 0190 C0F24C04 		movt	r4, 76
 2669 0194 A042     		cmp	r0, r4
 2670 0196 38DD     		ble	.L455
1798:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 2671              		.loc 1 1798 0
 2672 0198 49F28061 		movw	r1, #38528
 2673 019c C0F29801 		movt	r1, 152
 2674 01a0 8842     		cmp	r0, r1
 2675 01a2 30DD     		ble	.L456
1802:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 2676              		.loc 1 1802 0
 2677 01a4 4FF43453 		mov	r3, #11520
 2678 01a8 C0F23113 		movt	r3, 305
1804:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 4;
 2679              		.loc 1 1804 0
 2680 01ac 9842     		cmp	r0, r3
 2681 01ae CCBF     		ite	gt
 2682 01b0 0523     		movgt	r3, #5
 2683 01b2 0423     		movle	r3, #4
 2684 01b4 76E7     		b	.L436
 2685              	.L454:
1792:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 1;
 2686              		.loc 1 1792 0
 2687 01b6 0123     		movs	r3, #1
 2688 01b8 74E7     		b	.L436
 2689              	.LVL281:
 2690              	.L437:
1778:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 2691              		.loc 1 1778 0
 2692 01ba 44F02004 		orr	r4, r4, #32
 2693              	.LVL282:
 2694 01be 44EA8204 		orr	r4, r4, r2, lsl #2
 2695 01c2 E4B2     		uxtb	r4, r4
 2696 01c4 44EAC101 		orr	r1, r4, r1, lsl #3
 2697              	.LVL283:
1781:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 2698              		.loc 1 1781 0
 2699 01c8 5970     		strb	r1, [r3, #1]
 2700 01ca D9E7     		b	.L438
 2701              	.LVL284:
 2702              	.L496:
1839:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 2703              		.loc 1 1839 0
 2704 01cc 4FF4FA63 		mov	r3, #2000
 2705 01d0 07E0     		b	.L444
 2706              	.L498:
1845:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CL
 2707              		.loc 1 1845 0
 2708 01d2 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2709 01d4 C1F38101 		ubfx	r1, r1, #2, #2
 2710 01d8 0229     		cmp	r1, #2
 2711 01da 09D0     		beq	.L443
 2712 01dc 013B     		subs	r3, r3, #1
 2713 01de 9BB2     		uxth	r3, r3
1843:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 2714              		.loc 1 1843 0
 2715 01e0 33B1     		cbz	r3, .L443
 2716              	.L444:
1845:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CL
 2717              		.loc 1 1845 0
 2718 01e2 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2719 01e4 C1F38101 		ubfx	r1, r1, #2, #2
 2720 01e8 013B     		subs	r3, r3, #1
 2721 01ea 0229     		cmp	r1, #2
 2722 01ec 9BB2     		uxth	r3, r3
 2723 01ee F0D1     		bne	.L498
 2724              	.L443:
1848:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A;   // check EXT CLK is
 2725              		.loc 1 1848 0
 2726 01f0 4FF48041 		mov	r1, #16384
 2727 01f4 C4F20601 		movt	r1, 16390
 2728 01f8 8A79     		ldrb	r2, [r1, #6]	@ zero_extendqisi2
 2729 01fa C2F38103 		ubfx	r3, r2, #2, #2
 2730 01fe 022B     		cmp	r3, #2
 2731 0200 07D0     		beq	.L499
 2732 0202 1A20     		movs	r0, #26
 2733              	.LVL285:
 2734 0204 07E7     		b	.L433
 2735              	.LVL286:
 2736              	.L456:
1800:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 3;
 2737              		.loc 1 1800 0
 2738 0206 0323     		movs	r3, #3
 2739 0208 4CE7     		b	.L436
 2740              	.L455:
1796:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 2;
 2741              		.loc 1 1796 0
 2742 020a 0223     		movs	r3, #2
 2743 020c 4AE7     		b	.L436
 2744              	.LVL287:
 2745              	.L497:
1788:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 0;
 2746              		.loc 1 1788 0
 2747 020e 0023     		movs	r3, #0
 2748 0210 48E7     		b	.L436
 2749              	.LVL288:
 2750              	.L499:
1854:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 2751              		.loc 1 1854 0
 2752 0212 4A79     		ldrb	r2, [r1, #5]	@ zero_extendqisi2
 2753 0214 42F02003 		orr	r3, r2, #32
 2754 0218 4B71     		strb	r3, [r1, #5]
1855:../Sources/drivers/mcg/mcg.c ****     return crystal_val; // MCGOUT frequency equals external clock frequency
 2755              		.loc 1 1855 0
 2756 021a FCE6     		b	.L433
 2757              		.cfi_endproc
 2758              	.LFE15:
 2760              		.section	.text.fbi_blpi,"ax",%progbits
 2761              		.align	2
 2762              		.global	fbi_blpi
 2763              		.thumb
 2764              		.thumb_func
 2766              	fbi_blpi:
 2767              	.LFB16:
1857:../Sources/drivers/mcg/mcg.c **** 
1858:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
1859:../Sources/drivers/mcg/mcg.c **** 
1860:../Sources/drivers/mcg/mcg.c **** /* Functon name : fbi_blpi
1861:../Sources/drivers/mcg/mcg.c ****  *
1862:../Sources/drivers/mcg/mcg.c ****  * Mode transition: FBI to BLPI mode
1863:../Sources/drivers/mcg/mcg.c ****  *
1864:../Sources/drivers/mcg/mcg.c ****  * This function transitions the MCG from FBI mode to BLPI mode. This is
1865:../Sources/drivers/mcg/mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to
1866:../Sources/drivers/mcg/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1867:../Sources/drivers/mcg/mcg.c ****  * in FBI mode.
1868:../Sources/drivers/mcg/mcg.c ****  *
1869:../Sources/drivers/mcg/mcg.c ****  * Parameters: irc_freq - internal reference clock frequency
1870:../Sources/drivers/mcg/mcg.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1871:../Sources/drivers/mcg/mcg.c ****  *
1872:../Sources/drivers/mcg/mcg.c ****  * Return value : MCGOUT frequency or error code 0x13
1873:../Sources/drivers/mcg/mcg.c ****  */
1874:../Sources/drivers/mcg/mcg.c **** 
1875:../Sources/drivers/mcg/mcg.c **** int fbi_blpi
1876:../Sources/drivers/mcg/mcg.c **** (
1877:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
1878:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select
1879:../Sources/drivers/mcg/mcg.c **** )
1880:../Sources/drivers/mcg/mcg.c **** {
 2768              		.loc 1 1880 0
 2769              		.cfi_startproc
 2770              		@ args = 0, pretend = 0, frame = 0
 2771              		@ frame_needed = 0, uses_anonymous_args = 0
 2772              		@ link register save eliminated.
 2773              	.LVL289:
 2774 0000 10B4     		push	{r4}
 2775              	.LCFI8:
 2776              		.cfi_def_cfa_offset 4
 2777              		.cfi_offset 4, -4
1881:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1882:../Sources/drivers/mcg/mcg.c **** 
1883:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1884:../Sources/drivers/mcg/mcg.c **** 
1885:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1886:../Sources/drivers/mcg/mcg.c **** 
1887:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1888:../Sources/drivers/mcg/mcg.c **** 
1889:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1890:../Sources/drivers/mcg/mcg.c **** 
1891:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1892:../Sources/drivers/mcg/mcg.c **** 
1893:../Sources/drivers/mcg/mcg.c ****     unsigned char   fcrdiv_val;
1894:../Sources/drivers/mcg/mcg.c **** 
1895:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1896:../Sources/drivers/mcg/mcg.c **** 
1897:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1898:../Sources/drivers/mcg/mcg.c **** 
1899:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1900:../Sources/drivers/mcg/mcg.c **** 
1901:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1902:../Sources/drivers/mcg/mcg.c **** 
1903:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1904:../Sources/drivers/mcg/mcg.c **** 
1905:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1906:../Sources/drivers/mcg/mcg.c **** 
1907:../Sources/drivers/mcg/mcg.c ****     // check if in FBI mode
1908:../Sources/drivers/mcg/mcg.c **** 
1909:../Sources/drivers/mcg/mcg.c ****     if
1910:../Sources/drivers/mcg/mcg.c ****     (
1911:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 2778              		.loc 1 1911 0
 2779 0002 4FF48043 		mov	r3, #16384
 2780 0006 C4F20603 		movt	r3, 16390
 2781 000a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2782 000c C2F38102 		ubfx	r2, r2, #2, #2
1910:../Sources/drivers/mcg/mcg.c ****     (
 2783              		.loc 1 1910 0
 2784 0010 012A     		cmp	r2, #1
 2785 0012 02D0     		beq	.L509
 2786              	.L505:
1912:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
1913:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
1914:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
1915:../Sources/drivers/mcg/mcg.c ****         )
1916:../Sources/drivers/mcg/mcg.c ****     )               // check LP bit is clear
1917:../Sources/drivers/mcg/mcg.c ****     {
1918:../Sources/drivers/mcg/mcg.c ****         return 0x3; // MCG not in correct mode return fail code
 2787              		.loc 1 1918 0
 2788 0014 0320     		movs	r0, #3
 2789              	.LVL290:
 2790              	.L501:
1919:../Sources/drivers/mcg/mcg.c ****     }
1920:../Sources/drivers/mcg/mcg.c **** 
1921:../Sources/drivers/mcg/mcg.c ****     // Set LP bit to disable the FLL and enter BLPI
1922:../Sources/drivers/mcg/mcg.c **** 
1923:../Sources/drivers/mcg/mcg.c ****     MCG_C2 |= MCG_C2_LP_MASK;
1924:../Sources/drivers/mcg/mcg.c **** 
1925:../Sources/drivers/mcg/mcg.c ****     // Now in BLPI
1926:../Sources/drivers/mcg/mcg.c **** 
1927:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
1928:../Sources/drivers/mcg/mcg.c ****     {
1929:../Sources/drivers/mcg/mcg.c ****         fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate th
1930:../Sources/drivers/mcg/mcg.c ****         return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided by 2
1931:../Sources/drivers/mcg/mcg.c ****     }
1932:../Sources/drivers/mcg/mcg.c ****     else
1933:../Sources/drivers/mcg/mcg.c ****     {
1934:../Sources/drivers/mcg/mcg.c ****         return irc_freq;                // MCGOUT frequency equals slow IRC frequency
1935:../Sources/drivers/mcg/mcg.c ****     }
1936:../Sources/drivers/mcg/mcg.c **** }   // fbi_blpi
 2791              		.loc 1 1936 0
 2792 0016 10BC     		pop	{r4}
 2793 0018 7047     		bx	lr
 2794              	.LVL291:
 2795              	.L509:
1912:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 2796              		.loc 1 1912 0
 2797 001a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2798 001c 04F01004 		and	r4, r4, #16
 2799 0020 E4B2     		uxtb	r4, r4
 2800 0022 002C     		cmp	r4, #0
 2801 0024 F6D0     		beq	.L505
1913:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 2802              		.loc 1 1913 0
 2803 0026 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2804 0028 04F02004 		and	r4, r4, #32
 2805 002c E4B2     		uxtb	r4, r4
 2806 002e 002C     		cmp	r4, #0
 2807 0030 F0D1     		bne	.L505
1914:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 2808              		.loc 1 1914 0
 2809 0032 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
1911:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 2810              		.loc 1 1911 0
 2811 0034 04F00204 		and	r4, r4, #2
 2812 0038 E4B2     		uxtb	r4, r4
 2813 003a 002C     		cmp	r4, #0
 2814 003c EAD1     		bne	.L505
1923:../Sources/drivers/mcg/mcg.c ****     MCG_C2 |= MCG_C2_LP_MASK;
 2815              		.loc 1 1923 0
 2816 003e 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 2817 0040 44F00204 		orr	r4, r4, #2
 2818 0044 5C70     		strb	r4, [r3, #1]
1927:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 2819              		.loc 1 1927 0
 2820 0046 0029     		cmp	r1, #0
 2821 0048 E5D0     		beq	.L501
1929:../Sources/drivers/mcg/mcg.c ****         fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate th
 2822              		.loc 1 1929 0
 2823 004a 197A     		ldrb	r1, [r3, #8]	@ zero_extendqisi2
 2824              	.LVL292:
 2825 004c C1F34203 		ubfx	r3, r1, #1, #3
 2826 0050 02FA03F2 		lsl	r2, r2, r3
1930:../Sources/drivers/mcg/mcg.c ****         return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided by 2
 2827              		.loc 1 1930 0
 2828 0054 D1B2     		uxtb	r1, r2
 2829              	.LVL293:
 2830 0056 90FBF1F0 		sdiv	r0, r0, r1
 2831              	.LVL294:
 2832 005a DCE7     		b	.L501
 2833              		.cfi_endproc
 2834              	.LFE16:
 2836              		.section	.text.blpi_fbi,"ax",%progbits
 2837              		.align	2
 2838              		.global	blpi_fbi
 2839              		.thumb
 2840              		.thumb_func
 2842              	blpi_fbi:
 2843              	.LFB17:
1937:../Sources/drivers/mcg/mcg.c **** 
1938:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
1939:../Sources/drivers/mcg/mcg.c **** 
1940:../Sources/drivers/mcg/mcg.c **** /* Functon name : blpi_fbi
1941:../Sources/drivers/mcg/mcg.c ****  *
1942:../Sources/drivers/mcg/mcg.c ****  * Mode transition: BLPI to FBI mode
1943:../Sources/drivers/mcg/mcg.c ****  *
1944:../Sources/drivers/mcg/mcg.c ****  * This function transitions the MCG from BLPI mode to FBI mode. This is
1945:../Sources/drivers/mcg/mcg.c ****  * achieved by clearing the MCG_C2[LP] bit. There is no status bit to
1946:../Sources/drivers/mcg/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1947:../Sources/drivers/mcg/mcg.c ****  * in BLPI mode.
1948:../Sources/drivers/mcg/mcg.c ****  *
1949:../Sources/drivers/mcg/mcg.c ****  * Parameters: irc_freq - internal reference clock frequency
1950:../Sources/drivers/mcg/mcg.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1951:../Sources/drivers/mcg/mcg.c ****  *
1952:../Sources/drivers/mcg/mcg.c ****  * Return value : MCGOUT frequency or error code 0x15
1953:../Sources/drivers/mcg/mcg.c ****  */
1954:../Sources/drivers/mcg/mcg.c **** 
1955:../Sources/drivers/mcg/mcg.c **** int blpi_fbi
1956:../Sources/drivers/mcg/mcg.c **** (
1957:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
1958:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select
1959:../Sources/drivers/mcg/mcg.c **** )
1960:../Sources/drivers/mcg/mcg.c **** {
 2844              		.loc 1 1960 0
 2845              		.cfi_startproc
 2846              		@ args = 0, pretend = 0, frame = 0
 2847              		@ frame_needed = 0, uses_anonymous_args = 0
 2848              		@ link register save eliminated.
 2849              	.LVL295:
 2850 0000 10B4     		push	{r4}
 2851              	.LCFI9:
 2852              		.cfi_def_cfa_offset 4
 2853              		.cfi_offset 4, -4
1961:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1962:../Sources/drivers/mcg/mcg.c **** 
1963:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1964:../Sources/drivers/mcg/mcg.c **** 
1965:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1966:../Sources/drivers/mcg/mcg.c **** 
1967:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1968:../Sources/drivers/mcg/mcg.c **** 
1969:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1970:../Sources/drivers/mcg/mcg.c **** 
1971:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1972:../Sources/drivers/mcg/mcg.c **** 
1973:../Sources/drivers/mcg/mcg.c ****     unsigned char   fcrdiv_val;
1974:../Sources/drivers/mcg/mcg.c **** 
1975:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1976:../Sources/drivers/mcg/mcg.c **** 
1977:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1978:../Sources/drivers/mcg/mcg.c **** 
1979:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1980:../Sources/drivers/mcg/mcg.c **** 
1981:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1982:../Sources/drivers/mcg/mcg.c **** 
1983:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1984:../Sources/drivers/mcg/mcg.c **** 
1985:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
1986:../Sources/drivers/mcg/mcg.c **** 
1987:../Sources/drivers/mcg/mcg.c ****     // check if in BLPI mode
1988:../Sources/drivers/mcg/mcg.c **** 
1989:../Sources/drivers/mcg/mcg.c ****     if
1990:../Sources/drivers/mcg/mcg.c ****     (
1991:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 2854              		.loc 1 1991 0
 2855 0002 4FF48043 		mov	r3, #16384
 2856 0006 C4F20603 		movt	r3, 16390
 2857 000a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2858 000c C2F38102 		ubfx	r2, r2, #2, #2
1990:../Sources/drivers/mcg/mcg.c ****     (
 2859              		.loc 1 1990 0
 2860 0010 012A     		cmp	r2, #1
 2861 0012 02D0     		beq	.L519
 2862              	.L515:
1992:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
1993:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
1994:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
1995:../Sources/drivers/mcg/mcg.c ****         )
1996:../Sources/drivers/mcg/mcg.c ****     )               // check LP bit is set
1997:../Sources/drivers/mcg/mcg.c ****     {
1998:../Sources/drivers/mcg/mcg.c ****         return 0x5; // MCG not in correct mode return fail code
 2863              		.loc 1 1998 0
 2864 0014 0520     		movs	r0, #5
 2865              	.LVL296:
 2866              	.L511:
1999:../Sources/drivers/mcg/mcg.c ****     }
2000:../Sources/drivers/mcg/mcg.c **** 
2001:../Sources/drivers/mcg/mcg.c ****     // Clear LP bit to enable the FLL and enter FBI mode
2002:../Sources/drivers/mcg/mcg.c **** 
2003:../Sources/drivers/mcg/mcg.c ****     MCG_C2 &= ~MCG_C2_LP_MASK;
2004:../Sources/drivers/mcg/mcg.c **** 
2005:../Sources/drivers/mcg/mcg.c ****     // Now in FBI mode
2006:../Sources/drivers/mcg/mcg.c **** 
2007:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
2008:../Sources/drivers/mcg/mcg.c ****     {
2009:../Sources/drivers/mcg/mcg.c ****         fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate th
2010:../Sources/drivers/mcg/mcg.c ****         return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided by 2
2011:../Sources/drivers/mcg/mcg.c ****     }
2012:../Sources/drivers/mcg/mcg.c ****     else
2013:../Sources/drivers/mcg/mcg.c ****     {
2014:../Sources/drivers/mcg/mcg.c ****         return irc_freq;                // MCGOUT frequency equals slow IRC frequency
2015:../Sources/drivers/mcg/mcg.c ****     }
2016:../Sources/drivers/mcg/mcg.c **** }   // blpi_fbi
 2867              		.loc 1 2016 0
 2868 0016 10BC     		pop	{r4}
 2869 0018 7047     		bx	lr
 2870              	.LVL297:
 2871              	.L519:
1992:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 2872              		.loc 1 1992 0
 2873 001a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2874 001c 04F01004 		and	r4, r4, #16
 2875 0020 E4B2     		uxtb	r4, r4
 2876 0022 002C     		cmp	r4, #0
 2877 0024 F6D0     		beq	.L515
1993:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 2878              		.loc 1 1993 0
 2879 0026 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 2880 0028 04F02004 		and	r4, r4, #32
 2881 002c E4B2     		uxtb	r4, r4
 2882 002e 002C     		cmp	r4, #0
 2883 0030 F0D1     		bne	.L515
1994:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
 2884              		.loc 1 1994 0
 2885 0032 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
1991:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 2886              		.loc 1 1991 0
 2887 0034 04F00204 		and	r4, r4, #2
 2888 0038 E4B2     		uxtb	r4, r4
 2889 003a 002C     		cmp	r4, #0
 2890 003c EAD0     		beq	.L515
2003:../Sources/drivers/mcg/mcg.c ****     MCG_C2 &= ~MCG_C2_LP_MASK;
 2891              		.loc 1 2003 0
 2892 003e 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 2893 0040 04F0FD04 		and	r4, r4, #253
 2894 0044 5C70     		strb	r4, [r3, #1]
2007:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 2895              		.loc 1 2007 0
 2896 0046 0029     		cmp	r1, #0
 2897 0048 E5D0     		beq	.L511
2009:../Sources/drivers/mcg/mcg.c ****         fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate th
 2898              		.loc 1 2009 0
 2899 004a 197A     		ldrb	r1, [r3, #8]	@ zero_extendqisi2
 2900              	.LVL298:
 2901 004c C1F34203 		ubfx	r3, r1, #1, #3
 2902 0050 02FA03F2 		lsl	r2, r2, r3
2010:../Sources/drivers/mcg/mcg.c ****         return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided by 2
 2903              		.loc 1 2010 0
 2904 0054 D1B2     		uxtb	r1, r2
 2905              	.LVL299:
 2906 0056 90FBF1F0 		sdiv	r0, r0, r1
 2907              	.LVL300:
 2908 005a DCE7     		b	.L511
 2909              		.cfi_endproc
 2910              	.LFE17:
 2912              		.section	.text.fee_fbi,"ax",%progbits
 2913              		.align	2
 2914              		.global	fee_fbi
 2915              		.thumb
 2916              		.thumb_func
 2918              	fee_fbi:
 2919              	.LFB19:
2017:../Sources/drivers/mcg/mcg.c **** 
2018:../Sources/drivers/mcg/mcg.c **** /* */
2019:../Sources/drivers/mcg/mcg.c **** 
2020:../Sources/drivers/mcg/mcg.c **** int fbi_fee
2021:../Sources/drivers/mcg/mcg.c **** (
2022:../Sources/drivers/mcg/mcg.c ****     int             crystal_val,
2023:../Sources/drivers/mcg/mcg.c ****     unsigned char   hgo_val,
2024:../Sources/drivers/mcg/mcg.c ****     unsigned char   erefs_val
2025:../Sources/drivers/mcg/mcg.c **** )
2026:../Sources/drivers/mcg/mcg.c **** {
2027:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2028:../Sources/drivers/mcg/mcg.c **** 
2029:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2030:../Sources/drivers/mcg/mcg.c **** 
2031:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2032:../Sources/drivers/mcg/mcg.c **** 
2033:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2034:../Sources/drivers/mcg/mcg.c **** 
2035:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2036:../Sources/drivers/mcg/mcg.c **** 
2037:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2038:../Sources/drivers/mcg/mcg.c **** 
2039:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
2040:../Sources/drivers/mcg/mcg.c ****     unsigned char   frdiv_val;
2041:../Sources/drivers/mcg/mcg.c ****     short           i;
2042:../Sources/drivers/mcg/mcg.c ****     int             mcg_out, fll_ref_freq;
2043:../Sources/drivers/mcg/mcg.c **** 
2044:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2045:../Sources/drivers/mcg/mcg.c **** 
2046:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2047:../Sources/drivers/mcg/mcg.c **** 
2048:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2049:../Sources/drivers/mcg/mcg.c **** 
2050:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2051:../Sources/drivers/mcg/mcg.c **** 
2052:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2053:../Sources/drivers/mcg/mcg.c **** 
2054:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2055:../Sources/drivers/mcg/mcg.c **** 
2056:../Sources/drivers/mcg/mcg.c ****     // check if in FBI mode
2057:../Sources/drivers/mcg/mcg.c **** 
2058:../Sources/drivers/mcg/mcg.c ****     if
2059:../Sources/drivers/mcg/mcg.c ****     (
2060:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
2061:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
2062:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
2063:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
2064:../Sources/drivers/mcg/mcg.c ****         )
2065:../Sources/drivers/mcg/mcg.c ****     )                       // check LP bit is clear
2066:../Sources/drivers/mcg/mcg.c ****     {
2067:../Sources/drivers/mcg/mcg.c ****         return 0x3;         // MCG not in correct mode return fail code
2068:../Sources/drivers/mcg/mcg.c ****     }
2069:../Sources/drivers/mcg/mcg.c **** 
2070:../Sources/drivers/mcg/mcg.c ****     // check external frequency is less than the maximum frequency
2071:../Sources/drivers/mcg/mcg.c **** 
2072:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
2073:../Sources/drivers/mcg/mcg.c ****     {
2074:../Sources/drivers/mcg/mcg.c ****         return 0x21;
2075:../Sources/drivers/mcg/mcg.c ****     }
2076:../Sources/drivers/mcg/mcg.c **** 
2077:../Sources/drivers/mcg/mcg.c ****     // check crystal frequency is within spec. if crystal osc is being used
2078:../Sources/drivers/mcg/mcg.c **** 
2079:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
2080:../Sources/drivers/mcg/mcg.c ****     {
2081:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
2082:../Sources/drivers/mcg/mcg.c ****         {
2083:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return error if one of the available crystal options is not availabl
2084:../Sources/drivers/mcg/mcg.c ****         }
2085:../Sources/drivers/mcg/mcg.c ****     }
2086:../Sources/drivers/mcg/mcg.c **** 
2087:../Sources/drivers/mcg/mcg.c ****     // make sure HGO will never be greater than 1. Could return an error instead if desired.
2088:../Sources/drivers/mcg/mcg.c **** 
2089:../Sources/drivers/mcg/mcg.c ****     if(hgo_val > 0)
2090:../Sources/drivers/mcg/mcg.c ****     {
2091:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
2092:../Sources/drivers/mcg/mcg.c ****     }
2093:../Sources/drivers/mcg/mcg.c **** 
2094:../Sources/drivers/mcg/mcg.c ****     // configure the MCG_C2 register
2095:../Sources/drivers/mcg/mcg.c ****     // the RANGE value is determined by the external frequency. Since the RANGE parameter affects t
2096:../Sources/drivers/mcg/mcg.c ****     // it still needs to be set correctly even if the oscillator is not being used
2097:../Sources/drivers/mcg/mcg.c **** 
2098:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
2099:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
2100:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
2101:../Sources/drivers/mcg/mcg.c ****     {
2102:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
2103:../Sources/drivers/mcg/mcg.c ****     }
2104:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
2105:../Sources/drivers/mcg/mcg.c ****     {
2106:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
2107:../Sources/drivers/mcg/mcg.c ****     }
2108:../Sources/drivers/mcg/mcg.c ****     else
2109:../Sources/drivers/mcg/mcg.c ****     {
2110:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
2111:../Sources/drivers/mcg/mcg.c ****     }
2112:../Sources/drivers/mcg/mcg.c **** 
2113:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
2114:../Sources/drivers/mcg/mcg.c **** 
2115:../Sources/drivers/mcg/mcg.c ****     // determine FRDIV based on reference clock frequency
2116:../Sources/drivers/mcg/mcg.c ****     // since the external frequency has already been checked only the maximum frequency for each FR
2117:../Sources/drivers/mcg/mcg.c **** 
2118:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
2119:../Sources/drivers/mcg/mcg.c ****     {
2120:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 0;
2121:../Sources/drivers/mcg/mcg.c ****     }
2122:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
2123:../Sources/drivers/mcg/mcg.c ****     {
2124:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 1;
2125:../Sources/drivers/mcg/mcg.c ****     }
2126:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
2127:../Sources/drivers/mcg/mcg.c ****     {
2128:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 2;
2129:../Sources/drivers/mcg/mcg.c ****     }
2130:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
2131:../Sources/drivers/mcg/mcg.c ****     {
2132:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 3;
2133:../Sources/drivers/mcg/mcg.c ****     }
2134:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
2135:../Sources/drivers/mcg/mcg.c ****     {
2136:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 4;
2137:../Sources/drivers/mcg/mcg.c ****     }
2138:../Sources/drivers/mcg/mcg.c ****     else
2139:../Sources/drivers/mcg/mcg.c ****     {
2140:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 5;
2141:../Sources/drivers/mcg/mcg.c ****     }
2142:../Sources/drivers/mcg/mcg.c **** 
2143:../Sources/drivers/mcg/mcg.c ****     // The FLL ref clk divide value depends on FRDIV and the RANGE value
2144:../Sources/drivers/mcg/mcg.c **** 
2145:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
2146:../Sources/drivers/mcg/mcg.c ****     {
2147:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
2148:../Sources/drivers/mcg/mcg.c ****     }
2149:../Sources/drivers/mcg/mcg.c ****     else
2150:../Sources/drivers/mcg/mcg.c ****     {
2151:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
2152:../Sources/drivers/mcg/mcg.c ****     }
2153:../Sources/drivers/mcg/mcg.c **** 
2154:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
2155:../Sources/drivers/mcg/mcg.c **** 
2156:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
2157:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
2158:../Sources/drivers/mcg/mcg.c ****     {
2159:../Sources/drivers/mcg/mcg.c ****         return mcg_out;                 // If error code returned, return the code to calling funct
2160:../Sources/drivers/mcg/mcg.c ****     }
2161:../Sources/drivers/mcg/mcg.c **** 
2162:../Sources/drivers/mcg/mcg.c ****     // Select external oscilator and Reference Divider and clear IREFS to start ext osc
2163:../Sources/drivers/mcg/mcg.c ****     // If IRCLK is required it must be enabled outside of this driver, existing state will be maint
2164:../Sources/drivers/mcg/mcg.c ****     // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=?, IREFSTEN=?
2165:../Sources/drivers/mcg/mcg.c **** 
2166:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
2167:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear CLKS, FRDI
2168:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
2169:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
2170:../Sources/drivers/mcg/mcg.c **** 
2171:../Sources/drivers/mcg/mcg.c ****     // if the external oscillator is used need to wait for OSCINIT to set
2172:../Sources/drivers/mcg/mcg.c **** 
2173:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
2174:../Sources/drivers/mcg/mcg.c ****     {
2175:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 10000; i++)
2176:../Sources/drivers/mcg/mcg.c ****         {
2177:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
2178:../Sources/drivers/mcg/mcg.c ****         }
2179:../Sources/drivers/mcg/mcg.c **** 
2180:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is really 
2181:../Sources/drivers/mcg/mcg.c ****     }
2182:../Sources/drivers/mcg/mcg.c **** 
2183:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
2184:../Sources/drivers/mcg/mcg.c **** 
2185:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
2186:../Sources/drivers/mcg/mcg.c ****     {
2187:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
2188:../Sources/drivers/mcg/mcg.c ****     }
2189:../Sources/drivers/mcg/mcg.c **** 
2190:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
2191:../Sources/drivers/mcg/mcg.c **** 
2192:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
2193:../Sources/drivers/mcg/mcg.c **** 
2194:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
2195:../Sources/drivers/mcg/mcg.c ****     {
2196:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CL
2197:../Sources/drivers/mcg/mcg.c ****     }
2198:../Sources/drivers/mcg/mcg.c **** 
2199:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check FLLK is re
2200:../Sources/drivers/mcg/mcg.c **** 
2201:../Sources/drivers/mcg/mcg.c ****     // Now in FEE
2202:../Sources/drivers/mcg/mcg.c ****     // It is recommended that the clock monitor is enabled when using an external clock as the cloc
2203:../Sources/drivers/mcg/mcg.c ****     // It is enabled here but can be removed if this is not required.
2204:../Sources/drivers/mcg/mcg.c ****     // The clock monitor MUST be disabled when returning to a non-external clock mode (FEI, FBI and
2205:../Sources/drivers/mcg/mcg.c **** 
2206:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
2207:../Sources/drivers/mcg/mcg.c ****     return mcg_out; // MCGOUT frequency equals FLL frequency
2208:../Sources/drivers/mcg/mcg.c **** }                   //fbi_fee
2209:../Sources/drivers/mcg/mcg.c **** 
2210:../Sources/drivers/mcg/mcg.c **** /* */
2211:../Sources/drivers/mcg/mcg.c **** 
2212:../Sources/drivers/mcg/mcg.c **** int fee_fbi
2213:../Sources/drivers/mcg/mcg.c **** (
2214:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
2215:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select
2216:../Sources/drivers/mcg/mcg.c **** )
2217:../Sources/drivers/mcg/mcg.c **** {
 2920              		.loc 1 2217 0
 2921              		.cfi_startproc
 2922              		@ args = 0, pretend = 0, frame = 0
 2923              		@ frame_needed = 0, uses_anonymous_args = 0
 2924              		@ link register save eliminated.
 2925              	.LVL301:
 2926 0000 10B4     		push	{r4}
 2927              	.LCFI10:
 2928              		.cfi_def_cfa_offset 4
 2929              		.cfi_offset 4, -4
2218:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2219:../Sources/drivers/mcg/mcg.c **** 
2220:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2221:../Sources/drivers/mcg/mcg.c **** 
2222:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2223:../Sources/drivers/mcg/mcg.c **** 
2224:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2225:../Sources/drivers/mcg/mcg.c **** 
2226:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2227:../Sources/drivers/mcg/mcg.c **** 
2228:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2229:../Sources/drivers/mcg/mcg.c **** 
2230:../Sources/drivers/mcg/mcg.c ****     unsigned char   fcrdiv_val;
2231:../Sources/drivers/mcg/mcg.c ****     short           i;
2232:../Sources/drivers/mcg/mcg.c **** 
2233:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2234:../Sources/drivers/mcg/mcg.c **** 
2235:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2236:../Sources/drivers/mcg/mcg.c **** 
2237:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2238:../Sources/drivers/mcg/mcg.c **** 
2239:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2240:../Sources/drivers/mcg/mcg.c **** 
2241:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2242:../Sources/drivers/mcg/mcg.c **** 
2243:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2244:../Sources/drivers/mcg/mcg.c **** 
2245:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FEE mode
2246:../Sources/drivers/mcg/mcg.c **** 
2247:../Sources/drivers/mcg/mcg.c ****     if
2248:../Sources/drivers/mcg/mcg.c ****     (
2249:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 2930              		.loc 1 2249 0
 2931 0002 4FF48043 		mov	r3, #16384
 2932 0006 C4F20603 		movt	r3, 16390
 2933 000a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
2248:../Sources/drivers/mcg/mcg.c ****     (
 2934              		.loc 1 2248 0
 2935 000c 12F00C0F 		tst	r2, #12
 2936 0010 02D0     		beq	.L566
 2937              	.L535:
2250:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
2251:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
2252:../Sources/drivers/mcg/mcg.c ****         )
2253:../Sources/drivers/mcg/mcg.c ****     )                       // check PLLS mux has selected FLL
2254:../Sources/drivers/mcg/mcg.c ****     {
2255:../Sources/drivers/mcg/mcg.c ****         return 0x2;         // return error code
 2938              		.loc 1 2255 0
 2939 0012 0220     		movs	r0, #2
 2940              	.LVL302:
 2941              	.L521:
2256:../Sources/drivers/mcg/mcg.c ****     }
2257:../Sources/drivers/mcg/mcg.c **** 
2258:../Sources/drivers/mcg/mcg.c ****     // Check that the irc frequency matches the selected IRC
2259:../Sources/drivers/mcg/mcg.c **** 
2260:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
2261:../Sources/drivers/mcg/mcg.c ****     {
2262:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 31250) || (irc_freq > 39063))
2263:../Sources/drivers/mcg/mcg.c ****         {
2264:../Sources/drivers/mcg/mcg.c ****             return 0x31;
2265:../Sources/drivers/mcg/mcg.c ****         }
2266:../Sources/drivers/mcg/mcg.c ****     }
2267:../Sources/drivers/mcg/mcg.c ****     else
2268:../Sources/drivers/mcg/mcg.c ****     {
2269:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 3000000) || (irc_freq > 5000000))
2270:../Sources/drivers/mcg/mcg.c ****         {
2271:../Sources/drivers/mcg/mcg.c ****             return 0x32;    // Fast IRC freq
2272:../Sources/drivers/mcg/mcg.c ****         }
2273:../Sources/drivers/mcg/mcg.c ****     }
2274:../Sources/drivers/mcg/mcg.c **** 
2275:../Sources/drivers/mcg/mcg.c ****     // Select the required IRC
2276:../Sources/drivers/mcg/mcg.c **** 
2277:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
2278:../Sources/drivers/mcg/mcg.c ****     {
2279:../Sources/drivers/mcg/mcg.c ****         MCG_C2 |= MCG_C2_IRCS_MASK;                     // select fast IRC by setting IRCS
2280:../Sources/drivers/mcg/mcg.c ****     }
2281:../Sources/drivers/mcg/mcg.c ****     else
2282:../Sources/drivers/mcg/mcg.c ****     {
2283:../Sources/drivers/mcg/mcg.c ****         MCG_C2 &= ~MCG_C2_IRCS_MASK;                    // select slow IRC by clearing IRCS
2284:../Sources/drivers/mcg/mcg.c ****     }
2285:../Sources/drivers/mcg/mcg.c **** 
2286:../Sources/drivers/mcg/mcg.c ****     // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
2287:../Sources/drivers/mcg/mcg.c **** 
2288:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
2289:../Sources/drivers/mcg/mcg.c **** 
2290:../Sources/drivers/mcg/mcg.c ****     // Select the IRC as the CLKS mux selection
2291:../Sources/drivers/mcg/mcg.c **** 
2292:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK;       // set IREFS and select IRC as MCGOUT
2293:../Sources/drivers/mcg/mcg.c **** 
2294:../Sources/drivers/mcg/mcg.c ****     // wait until internal reference switches to requested irc.
2295:../Sources/drivers/mcg/mcg.c **** 
2296:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
2297:../Sources/drivers/mcg/mcg.c ****     {
2298:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
2299:../Sources/drivers/mcg/mcg.c ****         {
2300:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears before lo
2301:../Sources/drivers/mcg/mcg.c ****         }
2302:../Sources/drivers/mcg/mcg.c **** 
2303:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IRCST_MASK) return 0x13;       // check bit is really clear and return wit
2304:../Sources/drivers/mcg/mcg.c ****     }
2305:../Sources/drivers/mcg/mcg.c ****     else
2306:../Sources/drivers/mcg/mcg.c ****     {
2307:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
2308:../Sources/drivers/mcg/mcg.c ****         {
2309:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets before loop
2310:../Sources/drivers/mcg/mcg.c ****         }
2311:../Sources/drivers/mcg/mcg.c **** 
2312:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IRCST_MASK)) return 0x14;    // check bit is really set and return with 
2313:../Sources/drivers/mcg/mcg.c ****     }
2314:../Sources/drivers/mcg/mcg.c **** 
2315:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
2316:../Sources/drivers/mcg/mcg.c **** 
2317:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
2318:../Sources/drivers/mcg/mcg.c ****     {
2319:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;     // jump out early i
2320:../Sources/drivers/mcg/mcg.c ****     }
2321:../Sources/drivers/mcg/mcg.c **** 
2322:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19;   // check IRC is rea
2323:../Sources/drivers/mcg/mcg.c **** 
2324:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to set
2325:../Sources/drivers/mcg/mcg.c **** 
2326:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
2327:../Sources/drivers/mcg/mcg.c ****     {
2328:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
2329:../Sources/drivers/mcg/mcg.c ****     }
2330:../Sources/drivers/mcg/mcg.c **** 
2331:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
2332:../Sources/drivers/mcg/mcg.c **** 
2333:../Sources/drivers/mcg/mcg.c ****     // Now in FBI mode
2334:../Sources/drivers/mcg/mcg.c **** 
2335:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
2336:../Sources/drivers/mcg/mcg.c ****     {
2337:../Sources/drivers/mcg/mcg.c ****         fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate th
2338:../Sources/drivers/mcg/mcg.c ****         return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided by 2
2339:../Sources/drivers/mcg/mcg.c ****     }
2340:../Sources/drivers/mcg/mcg.c ****     else
2341:../Sources/drivers/mcg/mcg.c ****     {
2342:../Sources/drivers/mcg/mcg.c ****         return irc_freq;                // MCGOUT frequency equals slow IRC frequency
2343:../Sources/drivers/mcg/mcg.c ****     }
2344:../Sources/drivers/mcg/mcg.c **** }   // fee_fbi
 2942              		.loc 1 2344 0
 2943 0014 10BC     		pop	{r4}
 2944 0016 7047     		bx	lr
 2945              	.LVL303:
 2946              	.L566:
2250:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 2947              		.loc 1 2250 0
 2948 0018 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 2949 001a 02F01002 		and	r2, r2, #16
 2950 001e D2B2     		uxtb	r2, r2
 2951 0020 002A     		cmp	r2, #0
 2952 0022 F6D1     		bne	.L535
2251:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
 2953              		.loc 1 2251 0
 2954 0024 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
2249:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 2955              		.loc 1 2249 0
 2956 0026 02F02002 		and	r2, r2, #32
 2957 002a D2B2     		uxtb	r2, r2
 2958 002c 002A     		cmp	r2, #0
 2959 002e F0D1     		bne	.L535
2260:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
 2960              		.loc 1 2260 0
 2961 0030 41B9     		cbnz	r1, .L522
2262:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 31250) || (irc_freq > 39063))
 2962              		.loc 1 2262 0
 2963 0032 A0F5F444 		sub	r4, r0, #31232
 2964 0036 123C     		subs	r4, r4, #18
 2965 0038 41F68562 		movw	r2, #7813
 2966 003c 9442     		cmp	r4, r2
 2967 003e 0DD9     		bls	.L567
2264:../Sources/drivers/mcg/mcg.c ****             return 0x31;
 2968              		.loc 1 2264 0
 2969 0040 3120     		movs	r0, #49
 2970              	.LVL304:
 2971 0042 E7E7     		b	.L521
 2972              	.LVL305:
 2973              	.L522:
2269:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 3000000) || (irc_freq > 5000000))
 2974              		.loc 1 2269 0
 2975 0044 A0F53714 		sub	r4, r0, #2998272
 2976 0048 48F28042 		movw	r2, #33920
 2977 004c A4F5D864 		sub	r4, r4, #1728
 2978 0050 C0F21E02 		movt	r2, 30
 2979 0054 9442     		cmp	r4, r2
 2980 0056 26D9     		bls	.L568
2271:../Sources/drivers/mcg/mcg.c ****             return 0x32;    // Fast IRC freq
 2981              		.loc 1 2271 0
 2982 0058 3220     		movs	r0, #50
 2983              	.LVL306:
 2984 005a DBE7     		b	.L521
 2985              	.LVL307:
 2986              	.L567:
2283:../Sources/drivers/mcg/mcg.c ****         MCG_C2 &= ~MCG_C2_IRCS_MASK;                    // select slow IRC by clearing IRCS
 2987              		.loc 1 2283 0
 2988 005c 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 2989 005e 04F0FE02 		and	r2, r4, #254
 2990 0062 5A70     		strb	r2, [r3, #1]
2288:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 2991              		.loc 1 2288 0
 2992 0064 5C79     		ldrb	r4, [r3, #5]	@ zero_extendqisi2
 2993 0066 04F0DF02 		and	r2, r4, #223
 2994 006a 5A71     		strb	r2, [r3, #5]
2292:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK;       // set IREFS and select IRC as MCGOUT
 2995              		.loc 1 2292 0
 2996 006c 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 2997 006e 44F04402 		orr	r2, r4, #68
 2998 0072 1A70     		strb	r2, [r3, #0]
 2999              	.LVL308:
 3000 0074 4FF4FA62 		mov	r2, #2000
 3001 0078 06E0     		b	.L526
 3002              	.LVL309:
 3003              	.L569:
2300:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears before lo
 3004              		.loc 1 2300 0
 3005 007a 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 3006 007c 14F0010F 		tst	r4, #1
 3007 0080 08D0     		beq	.L525
 3008 0082 013A     		subs	r2, r2, #1
 3009 0084 92B2     		uxth	r2, r2
2298:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
 3010              		.loc 1 2298 0
 3011 0086 2AB1     		cbz	r2, .L525
 3012              	.L526:
2300:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears before lo
 3013              		.loc 1 2300 0
 3014 0088 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 3015 008a 013A     		subs	r2, r2, #1
 3016 008c 14F0010F 		tst	r4, #1
 3017 0090 92B2     		uxth	r2, r2
 3018 0092 F2D1     		bne	.L569
 3019              	.L525:
2303:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IRCST_MASK) return 0x13;       // check bit is really clear and return wit
 3020              		.loc 1 2303 0
 3021 0094 4FF48043 		mov	r3, #16384
 3022 0098 C4F20603 		movt	r3, 16390
 3023 009c 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3024 009e D307     		lsls	r3, r2, #31
 3025 00a0 26D5     		bpl	.L529
 3026 00a2 1320     		movs	r0, #19
 3027              	.LVL310:
 3028 00a4 B6E7     		b	.L521
 3029              	.LVL311:
 3030              	.L568:
2279:../Sources/drivers/mcg/mcg.c ****         MCG_C2 |= MCG_C2_IRCS_MASK;                     // select fast IRC by setting IRCS
 3031              		.loc 1 2279 0
 3032 00a6 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 3033 00a8 44F00102 		orr	r2, r4, #1
 3034 00ac 5A70     		strb	r2, [r3, #1]
2288:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 3035              		.loc 1 2288 0
 3036 00ae 5C79     		ldrb	r4, [r3, #5]	@ zero_extendqisi2
 3037 00b0 04F0DF02 		and	r2, r4, #223
 3038 00b4 5A71     		strb	r2, [r3, #5]
2292:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK;       // set IREFS and select IRC as MCGOUT
 3039              		.loc 1 2292 0
 3040 00b6 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 3041 00b8 44F04402 		orr	r2, r4, #68
 3042 00bc 1A70     		strb	r2, [r3, #0]
 3043              	.LVL312:
 3044 00be 4FF4FA62 		mov	r2, #2000
 3045 00c2 06E0     		b	.L524
 3046              	.LVL313:
 3047              	.L570:
2309:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets before loop
 3048              		.loc 1 2309 0
 3049 00c4 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 3050 00c6 14F0010F 		tst	r4, #1
 3051 00ca 08D1     		bne	.L528
 3052 00cc 013A     		subs	r2, r2, #1
 3053 00ce 92B2     		uxth	r2, r2
2307:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
 3054              		.loc 1 2307 0
 3055 00d0 2AB1     		cbz	r2, .L528
 3056              	.L524:
2309:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets before loop
 3057              		.loc 1 2309 0
 3058 00d2 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 3059 00d4 013A     		subs	r2, r2, #1
 3060 00d6 14F0010F 		tst	r4, #1
 3061 00da 92B2     		uxth	r2, r2
 3062 00dc F2D0     		beq	.L570
 3063              	.L528:
2312:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IRCST_MASK)) return 0x14;    // check bit is really set and return with 
 3064              		.loc 1 2312 0
 3065 00de 4FF48043 		mov	r3, #16384
 3066 00e2 C4F20603 		movt	r3, 16390
 3067 00e6 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3068 00e8 D307     		lsls	r3, r2, #31
 3069 00ea 01D4     		bmi	.L529
 3070 00ec 1420     		movs	r0, #20
 3071              	.LVL314:
 3072 00ee 91E7     		b	.L521
 3073              	.LVL315:
 3074              	.L529:
2319:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;     // jump out early i
 3075              		.loc 1 2319 0
 3076 00f0 4FF48042 		mov	r2, #16384
2292:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK;       // set IREFS and select IRC as MCGOUT
 3077              		.loc 1 2292 0
 3078 00f4 4FF4FA63 		mov	r3, #2000
2319:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;     // jump out early i
 3079              		.loc 1 2319 0
 3080 00f8 C4F20602 		movt	r2, 16390
 3081 00fc 07E0     		b	.L527
 3082              	.LVL316:
 3083              	.L571:
 3084 00fe 9479     		ldrb	r4, [r2, #6]	@ zero_extendqisi2
 3085 0100 C4F38104 		ubfx	r4, r4, #2, #2
 3086 0104 012C     		cmp	r4, #1
 3087 0106 09D0     		beq	.L530
 3088 0108 013B     		subs	r3, r3, #1
 3089 010a 9BB2     		uxth	r3, r3
2317:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3090              		.loc 1 2317 0
 3091 010c 33B1     		cbz	r3, .L530
 3092              	.L527:
2319:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;     // jump out early i
 3093              		.loc 1 2319 0
 3094 010e 9479     		ldrb	r4, [r2, #6]	@ zero_extendqisi2
 3095 0110 C4F38104 		ubfx	r4, r4, #2, #2
 3096 0114 013B     		subs	r3, r3, #1
 3097 0116 012C     		cmp	r4, #1
 3098 0118 9BB2     		uxth	r3, r3
 3099 011a F0D1     		bne	.L571
 3100              	.L530:
2322:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19;   // check IRC is rea
 3101              		.loc 1 2322 0
 3102 011c 4FF48042 		mov	r2, #16384
 3103 0120 C4F20602 		movt	r2, 16390
 3104 0124 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 3105 0126 C3F38103 		ubfx	r3, r3, #2, #2
 3106 012a 012B     		cmp	r3, #1
 3107 012c 01D0     		beq	.L572
 3108 012e 1920     		movs	r0, #25
 3109              	.LVL317:
 3110 0130 70E7     		b	.L521
 3111              	.LVL318:
 3112              	.L572:
 3113 0132 4FF4FA63 		mov	r3, #2000
 3114 0136 08E0     		b	.L532
 3115              	.L573:
2328:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
 3116              		.loc 1 2328 0
 3117 0138 9479     		ldrb	r4, [r2, #6]	@ zero_extendqisi2
 3118 013a 9BB2     		uxth	r3, r3
 3119 013c 04F01004 		and	r4, r4, #16
 3120 0140 013B     		subs	r3, r3, #1
 3121 0142 E4B2     		uxtb	r4, r4
 3122 0144 9BB2     		uxth	r3, r3
 3123 0146 3CB9     		cbnz	r4, .L531
2326:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3124              		.loc 1 2326 0
 3125 0148 33B1     		cbz	r3, .L531
 3126              	.L532:
2328:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
 3127              		.loc 1 2328 0
 3128 014a 9479     		ldrb	r4, [r2, #6]	@ zero_extendqisi2
 3129 014c 04F01004 		and	r4, r4, #16
 3130 0150 E4B2     		uxtb	r4, r4
 3131 0152 013B     		subs	r3, r3, #1
 3132 0154 002C     		cmp	r4, #0
 3133 0156 EFD0     		beq	.L573
 3134              	.L531:
2331:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 3135              		.loc 1 2331 0
 3136 0158 4FF48043 		mov	r3, #16384
 3137 015c C4F20603 		movt	r3, 16390
 3138 0160 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3139 0162 02F01002 		and	r2, r2, #16
 3140 0166 D2B2     		uxtb	r2, r2
 3141 0168 0AB9     		cbnz	r2, .L574
 3142 016a 1220     		movs	r0, #18
 3143              	.LVL319:
 3144 016c 52E7     		b	.L521
 3145              	.LVL320:
 3146              	.L574:
2335:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 3147              		.loc 1 2335 0
 3148 016e 0029     		cmp	r1, #0
 3149 0170 3FF450AF 		beq	.L521
2337:../Sources/drivers/mcg/mcg.c ****         fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate th
 3150              		.loc 1 2337 0
 3151 0174 197A     		ldrb	r1, [r3, #8]	@ zero_extendqisi2
 3152              	.LVL321:
 3153 0176 0122     		movs	r2, #1
 3154 0178 C1F34203 		ubfx	r3, r1, #1, #3
 3155 017c 02FA03F1 		lsl	r1, r2, r3
 3156              	.LVL322:
2338:../Sources/drivers/mcg/mcg.c ****         return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided by 2
 3157              		.loc 1 2338 0
 3158 0180 CBB2     		uxtb	r3, r1
 3159 0182 90FBF3F0 		sdiv	r0, r0, r3
 3160              	.LVL323:
 3161 0186 45E7     		b	.L521
 3162              		.cfi_endproc
 3163              	.LFE19:
 3165              		.section	.text.fei_fbi,"ax",%progbits
 3166              		.align	2
 3167              		.global	fei_fbi
 3168              		.thumb
 3169              		.thumb_func
 3171              	fei_fbi:
 3172              	.LFB21:
2345:../Sources/drivers/mcg/mcg.c **** 
2346:../Sources/drivers/mcg/mcg.c **** /* */
2347:../Sources/drivers/mcg/mcg.c **** 
2348:../Sources/drivers/mcg/mcg.c **** int fbi_fei
2349:../Sources/drivers/mcg/mcg.c **** (int slow_irc_freq)
2350:../Sources/drivers/mcg/mcg.c **** {
2351:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2352:../Sources/drivers/mcg/mcg.c **** 
2353:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2354:../Sources/drivers/mcg/mcg.c **** 
2355:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2356:../Sources/drivers/mcg/mcg.c **** 
2357:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2358:../Sources/drivers/mcg/mcg.c **** 
2359:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2360:../Sources/drivers/mcg/mcg.c **** 
2361:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2362:../Sources/drivers/mcg/mcg.c **** 
2363:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
2364:../Sources/drivers/mcg/mcg.c ****     short           i;
2365:../Sources/drivers/mcg/mcg.c ****     int             mcg_out;
2366:../Sources/drivers/mcg/mcg.c **** 
2367:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2368:../Sources/drivers/mcg/mcg.c **** 
2369:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2370:../Sources/drivers/mcg/mcg.c **** 
2371:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2372:../Sources/drivers/mcg/mcg.c **** 
2373:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2374:../Sources/drivers/mcg/mcg.c **** 
2375:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2376:../Sources/drivers/mcg/mcg.c **** 
2377:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~*/
2378:../Sources/drivers/mcg/mcg.c **** 
2379:../Sources/drivers/mcg/mcg.c ****     // check if in FBI mode
2380:../Sources/drivers/mcg/mcg.c **** 
2381:../Sources/drivers/mcg/mcg.c ****     if
2382:../Sources/drivers/mcg/mcg.c ****     (
2383:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
2384:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
2385:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
2386:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
2387:../Sources/drivers/mcg/mcg.c ****         )
2388:../Sources/drivers/mcg/mcg.c ****     )                   // check LP bit is clear
2389:../Sources/drivers/mcg/mcg.c ****     {
2390:../Sources/drivers/mcg/mcg.c ****         return 0x3;     // MCG not in correct mode return fail code
2391:../Sources/drivers/mcg/mcg.c ****     }
2392:../Sources/drivers/mcg/mcg.c **** 
2393:../Sources/drivers/mcg/mcg.c ****     // Check IRC frequency is within spec.
2394:../Sources/drivers/mcg/mcg.c **** 
2395:../Sources/drivers/mcg/mcg.c ****     if((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
2396:../Sources/drivers/mcg/mcg.c ****     {
2397:../Sources/drivers/mcg/mcg.c ****         return 0x31;
2398:../Sources/drivers/mcg/mcg.c ****     }
2399:../Sources/drivers/mcg/mcg.c **** 
2400:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
2401:../Sources/drivers/mcg/mcg.c **** 
2402:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(slow_irc_freq);
2403:../Sources/drivers/mcg/mcg.c **** 
2404:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
2405:../Sources/drivers/mcg/mcg.c ****     {
2406:../Sources/drivers/mcg/mcg.c ****         return mcg_out; // If error code returned, return the code to calling function
2407:../Sources/drivers/mcg/mcg.c ****     }
2408:../Sources/drivers/mcg/mcg.c **** 
2409:../Sources/drivers/mcg/mcg.c ****     // Change the CLKS mux to select the FLL output as MCGOUT
2410:../Sources/drivers/mcg/mcg.c **** 
2411:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
2412:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                  // clear CLKS field
2413:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_CLKS(0);                     // select FLL as MCGOUT
2414:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_IREFS_MASK;                  // make sure IRC is FLL reference
2415:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;                              // update MCG_C1
2416:../Sources/drivers/mcg/mcg.c **** 
2417:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
2418:../Sources/drivers/mcg/mcg.c **** 
2419:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
2420:../Sources/drivers/mcg/mcg.c ****     {
2421:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST clears before loop 
2422:../Sources/drivers/mcg/mcg.c ****     }
2423:../Sources/drivers/mcg/mcg.c **** 
2424:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
2425:../Sources/drivers/mcg/mcg.c **** 
2426:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to show clock source is ext ref clk
2427:../Sources/drivers/mcg/mcg.c **** 
2428:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
2429:../Sources/drivers/mcg/mcg.c ****     {
2430:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out early i
2431:../Sources/drivers/mcg/mcg.c ****     }
2432:../Sources/drivers/mcg/mcg.c **** 
2433:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check FLL is rea
2434:../Sources/drivers/mcg/mcg.c **** 
2435:../Sources/drivers/mcg/mcg.c ****     // Now in FEI mode
2436:../Sources/drivers/mcg/mcg.c **** 
2437:../Sources/drivers/mcg/mcg.c ****     return mcg_out;
2438:../Sources/drivers/mcg/mcg.c **** }   // fbi_fei
2439:../Sources/drivers/mcg/mcg.c **** 
2440:../Sources/drivers/mcg/mcg.c **** /* */
2441:../Sources/drivers/mcg/mcg.c **** 
2442:../Sources/drivers/mcg/mcg.c **** int fei_fbi
2443:../Sources/drivers/mcg/mcg.c **** (
2444:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
2445:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select
2446:../Sources/drivers/mcg/mcg.c **** )
2447:../Sources/drivers/mcg/mcg.c **** {
 3173              		.loc 1 2447 0
 3174              		.cfi_startproc
 3175              		@ args = 0, pretend = 0, frame = 0
 3176              		@ frame_needed = 0, uses_anonymous_args = 0
 3177              		@ link register save eliminated.
 3178              	.LVL324:
 3179 0000 10B4     		push	{r4}
 3180              	.LCFI11:
 3181              		.cfi_def_cfa_offset 4
 3182              		.cfi_offset 4, -4
2448:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2449:../Sources/drivers/mcg/mcg.c **** 
2450:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2451:../Sources/drivers/mcg/mcg.c **** 
2452:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2453:../Sources/drivers/mcg/mcg.c **** 
2454:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2455:../Sources/drivers/mcg/mcg.c **** 
2456:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2457:../Sources/drivers/mcg/mcg.c **** 
2458:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2459:../Sources/drivers/mcg/mcg.c **** 
2460:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
2461:../Sources/drivers/mcg/mcg.c ****     unsigned char   fcrdiv_val;
2462:../Sources/drivers/mcg/mcg.c ****     short           i;
2463:../Sources/drivers/mcg/mcg.c **** 
2464:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2465:../Sources/drivers/mcg/mcg.c **** 
2466:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2467:../Sources/drivers/mcg/mcg.c **** 
2468:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2469:../Sources/drivers/mcg/mcg.c **** 
2470:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2471:../Sources/drivers/mcg/mcg.c **** 
2472:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2473:../Sources/drivers/mcg/mcg.c **** 
2474:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~*/
2475:../Sources/drivers/mcg/mcg.c **** 
2476:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FEI mode
2477:../Sources/drivers/mcg/mcg.c **** 
2478:../Sources/drivers/mcg/mcg.c ****     if
2479:../Sources/drivers/mcg/mcg.c ****     (
2480:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 3183              		.loc 1 2480 0
 3184 0002 4FF48043 		mov	r3, #16384
 3185 0006 C4F20603 		movt	r3, 16390
 3186 000a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
2479:../Sources/drivers/mcg/mcg.c ****     (
 3187              		.loc 1 2479 0
 3188 000c 12F00C0F 		tst	r2, #12
 3189 0010 13D1     		bne	.L588
2481:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
 3190              		.loc 1 2481 0
 3191 0012 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3192 0014 02F01002 		and	r2, r2, #16
 3193 0018 D2B2     		uxtb	r2, r2
 3194 001a 72B1     		cbz	r2, .L588
2482:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
 3195              		.loc 1 2482 0
 3196 001c 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
2480:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 3197              		.loc 1 2480 0
 3198 001e 02F02002 		and	r2, r2, #32
 3199 0022 D2B2     		uxtb	r2, r2
 3200 0024 4AB9     		cbnz	r2, .L588
2483:../Sources/drivers/mcg/mcg.c ****         )
2484:../Sources/drivers/mcg/mcg.c ****     )                       // check PLLS mux has selected FLL
2485:../Sources/drivers/mcg/mcg.c ****     {
2486:../Sources/drivers/mcg/mcg.c ****         return 0x1;         // return error code
2487:../Sources/drivers/mcg/mcg.c ****     }
2488:../Sources/drivers/mcg/mcg.c **** 
2489:../Sources/drivers/mcg/mcg.c ****     // Check that the irc frequency matches the selected IRC
2490:../Sources/drivers/mcg/mcg.c **** 
2491:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
 3201              		.loc 1 2491 0
 3202 0026 59B9     		cbnz	r1, .L577
2492:../Sources/drivers/mcg/mcg.c ****     {
2493:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 31250) || (irc_freq > 39063))
 3203              		.loc 1 2493 0
 3204 0028 A0F5F444 		sub	r4, r0, #31232
 3205 002c 123C     		subs	r4, r4, #18
 3206 002e 41F68562 		movw	r2, #7813
 3207 0032 9442     		cmp	r4, r2
 3208 0034 33D9     		bls	.L615
2494:../Sources/drivers/mcg/mcg.c ****         {
2495:../Sources/drivers/mcg/mcg.c ****             return 0x31;
 3209              		.loc 1 2495 0
 3210 0036 3120     		movs	r0, #49
 3211              	.LVL325:
 3212 0038 00E0     		b	.L576
 3213              	.LVL326:
 3214              	.L588:
2486:../Sources/drivers/mcg/mcg.c ****         return 0x1;         // return error code
 3215              		.loc 1 2486 0
 3216 003a 0120     		movs	r0, #1
 3217              	.LVL327:
 3218              	.L576:
2496:../Sources/drivers/mcg/mcg.c ****         }
2497:../Sources/drivers/mcg/mcg.c ****     }
2498:../Sources/drivers/mcg/mcg.c ****     else
2499:../Sources/drivers/mcg/mcg.c ****     {
2500:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 3000000) || (irc_freq > 5000000))
2501:../Sources/drivers/mcg/mcg.c ****         {
2502:../Sources/drivers/mcg/mcg.c ****             return 0x32;    // Fast IRC freq
2503:../Sources/drivers/mcg/mcg.c ****         }
2504:../Sources/drivers/mcg/mcg.c ****     }
2505:../Sources/drivers/mcg/mcg.c **** 
2506:../Sources/drivers/mcg/mcg.c ****     // Select the desired IRC
2507:../Sources/drivers/mcg/mcg.c **** 
2508:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
2509:../Sources/drivers/mcg/mcg.c ****     {
2510:../Sources/drivers/mcg/mcg.c ****         MCG_C2 |= MCG_C2_IRCS_MASK;                     // select fast IRCS
2511:../Sources/drivers/mcg/mcg.c ****     }
2512:../Sources/drivers/mcg/mcg.c ****     else
2513:../Sources/drivers/mcg/mcg.c ****     {
2514:../Sources/drivers/mcg/mcg.c ****         MCG_C2 &= ~MCG_C2_IRCS_MASK;                    // select slow IRCS
2515:../Sources/drivers/mcg/mcg.c ****     }
2516:../Sources/drivers/mcg/mcg.c **** 
2517:../Sources/drivers/mcg/mcg.c ****     // Change the CLKS mux to select the IRC as the MCGOUT
2518:../Sources/drivers/mcg/mcg.c **** 
2519:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
2520:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                      // clear CLKS
2521:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_CLKS(1);                         // select IRC as the MCG clock sourse
2522:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
2523:../Sources/drivers/mcg/mcg.c **** 
2524:../Sources/drivers/mcg/mcg.c ****     // wait until internal reference switches to requested irc.
2525:../Sources/drivers/mcg/mcg.c **** 
2526:../Sources/drivers/mcg/mcg.c ****     if(!(irc_select))
2527:../Sources/drivers/mcg/mcg.c ****     {
2528:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
2529:../Sources/drivers/mcg/mcg.c ****         {
2530:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears before lo
2531:../Sources/drivers/mcg/mcg.c ****         }
2532:../Sources/drivers/mcg/mcg.c **** 
2533:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IRCST_MASK) return 0x13;       // check bit is really clear and return wit
2534:../Sources/drivers/mcg/mcg.c ****     }
2535:../Sources/drivers/mcg/mcg.c ****     else
2536:../Sources/drivers/mcg/mcg.c ****     {
2537:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
2538:../Sources/drivers/mcg/mcg.c ****         {
2539:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets before loop
2540:../Sources/drivers/mcg/mcg.c ****         }
2541:../Sources/drivers/mcg/mcg.c **** 
2542:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IRCST_MASK)) return 0x14;    // check bit is really set and return with 
2543:../Sources/drivers/mcg/mcg.c ****     }
2544:../Sources/drivers/mcg/mcg.c **** 
2545:../Sources/drivers/mcg/mcg.c ****     // Wait for clock status bits to update
2546:../Sources/drivers/mcg/mcg.c **** 
2547:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
2548:../Sources/drivers/mcg/mcg.c ****     {
2549:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;         // jump out ear
2550:../Sources/drivers/mcg/mcg.c ****     }
2551:../Sources/drivers/mcg/mcg.c **** 
2552:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19;       // check IRC is
2553:../Sources/drivers/mcg/mcg.c **** 
2554:../Sources/drivers/mcg/mcg.c ****     // Now in FBI mode
2555:../Sources/drivers/mcg/mcg.c **** 
2556:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
2557:../Sources/drivers/mcg/mcg.c ****     {
2558:../Sources/drivers/mcg/mcg.c ****         fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate th
2559:../Sources/drivers/mcg/mcg.c ****         return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided by 2
2560:../Sources/drivers/mcg/mcg.c ****     }
2561:../Sources/drivers/mcg/mcg.c ****     else
2562:../Sources/drivers/mcg/mcg.c ****     {
2563:../Sources/drivers/mcg/mcg.c ****         return irc_freq;                // MCGOUT frequency equals slow IRC frequency
2564:../Sources/drivers/mcg/mcg.c ****     }
2565:../Sources/drivers/mcg/mcg.c **** }   // fei_fbi
 3219              		.loc 1 2565 0
 3220 003c 10BC     		pop	{r4}
 3221 003e 7047     		bx	lr
 3222              	.LVL328:
 3223              	.L577:
2500:../Sources/drivers/mcg/mcg.c ****         if((irc_freq < 3000000) || (irc_freq > 5000000))
 3224              		.loc 1 2500 0
 3225 0040 A0F53714 		sub	r4, r0, #2998272
 3226 0044 48F28042 		movw	r2, #33920
 3227 0048 A4F5D864 		sub	r4, r4, #1728
 3228 004c C0F21E02 		movt	r2, 30
 3229 0050 9442     		cmp	r4, r2
 3230 0052 01D9     		bls	.L616
2502:../Sources/drivers/mcg/mcg.c ****             return 0x32;    // Fast IRC freq
 3231              		.loc 1 2502 0
 3232 0054 3220     		movs	r0, #50
 3233              	.LVL329:
 3234 0056 F1E7     		b	.L576
 3235              	.LVL330:
 3236              	.L616:
2510:../Sources/drivers/mcg/mcg.c ****         MCG_C2 |= MCG_C2_IRCS_MASK;                     // select fast IRCS
 3237              		.loc 1 2510 0
 3238 0058 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 3239 005a 44F00102 		orr	r2, r4, #1
 3240 005e 5A70     		strb	r2, [r3, #1]
2519:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 3241              		.loc 1 2519 0
 3242 0060 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 3243              	.LVL331:
2520:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                      // clear CLKS
 3244              		.loc 1 2520 0
 3245 0062 04F03F02 		and	r2, r4, #63
 3246              	.LVL332:
2521:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_CLKS(1);                         // select IRC as the MCG clock sourse
 3247              		.loc 1 2521 0
 3248 0066 42F04004 		orr	r4, r2, #64
 3249              	.LVL333:
2522:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 3250              		.loc 1 2522 0
 3251 006a 1C70     		strb	r4, [r3, #0]
 3252              	.LVL334:
 3253 006c 4FF4FA62 		mov	r2, #2000
 3254 0070 06E0     		b	.L579
 3255              	.LVL335:
 3256              	.L617:
2539:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets before loop
 3257              		.loc 1 2539 0
 3258 0072 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 3259 0074 14F0010F 		tst	r4, #1
 3260 0078 08D1     		bne	.L583
 3261 007a 013A     		subs	r2, r2, #1
 3262 007c 92B2     		uxth	r2, r2
2537:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
 3263              		.loc 1 2537 0
 3264 007e 2AB1     		cbz	r2, .L583
 3265              	.L579:
2539:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_IRCST_MASK) break;         // jump out early if IRCST sets before loop
 3266              		.loc 1 2539 0
 3267 0080 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 3268 0082 013A     		subs	r2, r2, #1
 3269 0084 14F0010F 		tst	r4, #1
 3270 0088 92B2     		uxth	r2, r2
 3271 008a F2D0     		beq	.L617
 3272              	.L583:
2542:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IRCST_MASK)) return 0x14;    // check bit is really set and return with 
 3273              		.loc 1 2542 0
 3274 008c 4FF48043 		mov	r3, #16384
 3275 0090 C4F20603 		movt	r3, 16390
 3276 0094 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3277 0096 D307     		lsls	r3, r2, #31
 3278 0098 24D4     		bmi	.L584
 3279 009a 1420     		movs	r0, #20
 3280              	.LVL336:
 3281 009c CEE7     		b	.L576
 3282              	.LVL337:
 3283              	.L615:
2514:../Sources/drivers/mcg/mcg.c ****         MCG_C2 &= ~MCG_C2_IRCS_MASK;                    // select slow IRCS
 3284              		.loc 1 2514 0
 3285 009e 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 3286 00a0 04F0FE02 		and	r2, r4, #254
 3287 00a4 5A70     		strb	r2, [r3, #1]
2519:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 3288              		.loc 1 2519 0
 3289 00a6 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 3290              	.LVL338:
2520:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                      // clear CLKS
 3291              		.loc 1 2520 0
 3292 00a8 04F03F02 		and	r2, r4, #63
 3293              	.LVL339:
2521:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_CLKS(1);                         // select IRC as the MCG clock sourse
 3294              		.loc 1 2521 0
 3295 00ac 42F04004 		orr	r4, r2, #64
 3296              	.LVL340:
2522:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 3297              		.loc 1 2522 0
 3298 00b0 1C70     		strb	r4, [r3, #0]
 3299              	.LVL341:
 3300 00b2 4FF4FA62 		mov	r2, #2000
 3301 00b6 06E0     		b	.L581
 3302              	.LVL342:
 3303              	.L618:
2530:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears before lo
 3304              		.loc 1 2530 0
 3305 00b8 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 3306 00ba 14F0010F 		tst	r4, #1
 3307 00be 08D0     		beq	.L580
 3308 00c0 013A     		subs	r2, r2, #1
 3309 00c2 92B2     		uxth	r2, r2
2528:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 2000; i++)
 3310              		.loc 1 2528 0
 3311 00c4 2AB1     		cbz	r2, .L580
 3312              	.L581:
2530:../Sources/drivers/mcg/mcg.c ****             if(!(MCG_S & MCG_S_IRCST_MASK)) break;      // jump out early if IRCST clears before lo
 3313              		.loc 1 2530 0
 3314 00c6 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 3315 00c8 013A     		subs	r2, r2, #1
 3316 00ca 14F0010F 		tst	r4, #1
 3317 00ce 92B2     		uxth	r2, r2
 3318 00d0 F2D1     		bne	.L618
 3319              	.L580:
2533:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IRCST_MASK) return 0x13;       // check bit is really clear and return wit
 3320              		.loc 1 2533 0
 3321 00d2 4FF48043 		mov	r3, #16384
 3322 00d6 C4F20603 		movt	r3, 16390
 3323 00da 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3324 00dc D307     		lsls	r3, r2, #31
 3325 00de 01D5     		bpl	.L584
 3326 00e0 1320     		movs	r0, #19
 3327              	.LVL343:
 3328 00e2 ABE7     		b	.L576
 3329              	.LVL344:
 3330              	.L584:
2549:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;         // jump out ear
 3331              		.loc 1 2549 0
 3332 00e4 4FF48042 		mov	r2, #16384
2522:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 3333              		.loc 1 2522 0
 3334 00e8 4FF4FA63 		mov	r3, #2000
2549:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;         // jump out ear
 3335              		.loc 1 2549 0
 3336 00ec C4F20602 		movt	r2, 16390
 3337 00f0 07E0     		b	.L582
 3338              	.LVL345:
 3339              	.L619:
 3340 00f2 9479     		ldrb	r4, [r2, #6]	@ zero_extendqisi2
 3341 00f4 C4F38104 		ubfx	r4, r4, #2, #2
 3342 00f8 012C     		cmp	r4, #1
 3343 00fa 09D0     		beq	.L585
 3344 00fc 013B     		subs	r3, r3, #1
 3345 00fe 9BB2     		uxth	r3, r3
2547:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3346              		.loc 1 2547 0
 3347 0100 33B1     		cbz	r3, .L585
 3348              	.L582:
2549:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break;         // jump out ear
 3349              		.loc 1 2549 0
 3350 0102 9479     		ldrb	r4, [r2, #6]	@ zero_extendqisi2
 3351 0104 C4F38104 		ubfx	r4, r4, #2, #2
 3352 0108 013B     		subs	r3, r3, #1
 3353 010a 012C     		cmp	r4, #1
 3354 010c 9BB2     		uxth	r3, r3
 3355 010e F0D1     		bne	.L619
 3356              	.L585:
2552:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19;       // check IRC is
 3357              		.loc 1 2552 0
 3358 0110 4FF48043 		mov	r3, #16384
 3359 0114 C4F20603 		movt	r3, 16390
 3360 0118 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 3361 011a C2F38102 		ubfx	r2, r2, #2, #2
 3362 011e 012A     		cmp	r2, #1
 3363 0120 01D0     		beq	.L620
 3364 0122 1920     		movs	r0, #25
 3365              	.LVL346:
 3366 0124 8AE7     		b	.L576
 3367              	.LVL347:
 3368              	.L620:
2556:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
 3369              		.loc 1 2556 0
 3370 0126 0029     		cmp	r1, #0
 3371 0128 88D0     		beq	.L576
2558:../Sources/drivers/mcg/mcg.c ****         fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate th
 3372              		.loc 1 2558 0
 3373 012a 197A     		ldrb	r1, [r3, #8]	@ zero_extendqisi2
 3374              	.LVL348:
 3375 012c C1F34203 		ubfx	r3, r1, #1, #3
 3376 0130 02FA03F2 		lsl	r2, r2, r3
2559:../Sources/drivers/mcg/mcg.c ****         return(irc_freq / fcrdiv_val);  // MCGOUT frequency equals fast IRC frequency divided by 2
 3377              		.loc 1 2559 0
 3378 0134 D1B2     		uxtb	r1, r2
 3379              	.LVL349:
 3380 0136 90FBF1F0 		sdiv	r0, r0, r1
 3381              	.LVL350:
 3382 013a 7FE7     		b	.L576
 3383              		.cfi_endproc
 3384              	.LFE21:
 3386              		.section	.text.fll_freq,"ax",%progbits
 3387              		.align	2
 3388              		.global	fll_freq
 3389              		.thumb
 3390              		.thumb_func
 3392              	fll_freq:
 3393              	.LFB25:
2566:../Sources/drivers/mcg/mcg.c **** 
2567:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
2568:../Sources/drivers/mcg/mcg.c **** 
2569:../Sources/drivers/mcg/mcg.c **** /* Functon name : fei_fee
2570:../Sources/drivers/mcg/mcg.c ****  *
2571:../Sources/drivers/mcg/mcg.c ****  * Mode transition: FEI to FEE mode
2572:../Sources/drivers/mcg/mcg.c ****  *
2573:../Sources/drivers/mcg/mcg.c ****  * This function transitions the MCG from FEI mode to FEE mode. This is
2574:../Sources/drivers/mcg/mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to
2575:../Sources/drivers/mcg/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
2576:../Sources/drivers/mcg/mcg.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
2577:../Sources/drivers/mcg/mcg.c ****  *
2578:../Sources/drivers/mcg/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
2579:../Sources/drivers/mcg/mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
2580:../Sources/drivers/mcg/mcg.c ****  *                           for the crystal oscillator. This has no meaning if an
2581:../Sources/drivers/mcg/mcg.c ****  *                           external clock is used.
2582:../Sources/drivers/mcg/mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
2583:../Sources/drivers/mcg/mcg.c ****  *
2584:../Sources/drivers/mcg/mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
2585:../Sources/drivers/mcg/mcg.c ****  */
2586:../Sources/drivers/mcg/mcg.c **** 
2587:../Sources/drivers/mcg/mcg.c **** int fei_fee
2588:../Sources/drivers/mcg/mcg.c **** (
2589:../Sources/drivers/mcg/mcg.c ****     int             crystal_val,
2590:../Sources/drivers/mcg/mcg.c ****     unsigned char   hgo_val,
2591:../Sources/drivers/mcg/mcg.c ****     unsigned char   erefs_val
2592:../Sources/drivers/mcg/mcg.c **** )
2593:../Sources/drivers/mcg/mcg.c **** {
2594:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2595:../Sources/drivers/mcg/mcg.c **** 
2596:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2597:../Sources/drivers/mcg/mcg.c **** 
2598:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2599:../Sources/drivers/mcg/mcg.c **** 
2600:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2601:../Sources/drivers/mcg/mcg.c **** 
2602:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2603:../Sources/drivers/mcg/mcg.c **** 
2604:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2605:../Sources/drivers/mcg/mcg.c **** 
2606:../Sources/drivers/mcg/mcg.c ****     unsigned char   frdiv_val;
2607:../Sources/drivers/mcg/mcg.c ****     unsigned char   temp_reg;
2608:../Sources/drivers/mcg/mcg.c **** 
2609:../Sources/drivers/mcg/mcg.c ****     // short i;
2610:../Sources/drivers/mcg/mcg.c **** 
2611:../Sources/drivers/mcg/mcg.c ****     int             mcg_out, fll_ref_freq, i;
2612:../Sources/drivers/mcg/mcg.c **** 
2613:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2614:../Sources/drivers/mcg/mcg.c **** 
2615:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2616:../Sources/drivers/mcg/mcg.c **** 
2617:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2618:../Sources/drivers/mcg/mcg.c **** 
2619:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2620:../Sources/drivers/mcg/mcg.c **** 
2621:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2622:../Sources/drivers/mcg/mcg.c **** 
2623:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2624:../Sources/drivers/mcg/mcg.c **** 
2625:../Sources/drivers/mcg/mcg.c ****     // check if in FEI mode
2626:../Sources/drivers/mcg/mcg.c **** 
2627:../Sources/drivers/mcg/mcg.c ****     if
2628:../Sources/drivers/mcg/mcg.c ****     (
2629:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
2630:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
2631:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
2632:../Sources/drivers/mcg/mcg.c ****         )
2633:../Sources/drivers/mcg/mcg.c ****     )                       // check PLLS mux has selected FLL
2634:../Sources/drivers/mcg/mcg.c ****     {
2635:../Sources/drivers/mcg/mcg.c ****         return 0x1;         // return error code
2636:../Sources/drivers/mcg/mcg.c ****     }
2637:../Sources/drivers/mcg/mcg.c **** 
2638:../Sources/drivers/mcg/mcg.c ****     // check external frequency is less than the maximum frequency
2639:../Sources/drivers/mcg/mcg.c **** 
2640:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
2641:../Sources/drivers/mcg/mcg.c ****     {
2642:../Sources/drivers/mcg/mcg.c ****         return 0x21;
2643:../Sources/drivers/mcg/mcg.c ****     }
2644:../Sources/drivers/mcg/mcg.c **** 
2645:../Sources/drivers/mcg/mcg.c ****     // check crystal frequency is within spec. if crystal osc is being used
2646:../Sources/drivers/mcg/mcg.c **** 
2647:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
2648:../Sources/drivers/mcg/mcg.c ****     {
2649:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
2650:../Sources/drivers/mcg/mcg.c ****         {
2651:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return error if one of the available crystal options is not availabl
2652:../Sources/drivers/mcg/mcg.c ****         }
2653:../Sources/drivers/mcg/mcg.c ****     }
2654:../Sources/drivers/mcg/mcg.c **** 
2655:../Sources/drivers/mcg/mcg.c ****     // make sure HGO will never be greater than 1. Could return an error instead if desired.
2656:../Sources/drivers/mcg/mcg.c **** 
2657:../Sources/drivers/mcg/mcg.c ****     if(hgo_val > 0)
2658:../Sources/drivers/mcg/mcg.c ****     {
2659:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
2660:../Sources/drivers/mcg/mcg.c ****     }
2661:../Sources/drivers/mcg/mcg.c **** 
2662:../Sources/drivers/mcg/mcg.c ****     // configure the MCG_C2 register
2663:../Sources/drivers/mcg/mcg.c ****     // the RANGE value is determined by the external frequency. Since the RANGE parameter affects t
2664:../Sources/drivers/mcg/mcg.c ****     // it still needs to be set correctly even if the oscillator is not being used
2665:../Sources/drivers/mcg/mcg.c **** 
2666:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
2667:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
2668:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
2669:../Sources/drivers/mcg/mcg.c ****     {
2670:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
2671:../Sources/drivers/mcg/mcg.c ****     }
2672:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
2673:../Sources/drivers/mcg/mcg.c ****     {
2674:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
2675:../Sources/drivers/mcg/mcg.c ****     }
2676:../Sources/drivers/mcg/mcg.c ****     else
2677:../Sources/drivers/mcg/mcg.c ****     {
2678:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
2679:../Sources/drivers/mcg/mcg.c ****     }
2680:../Sources/drivers/mcg/mcg.c **** 
2681:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
2682:../Sources/drivers/mcg/mcg.c **** 
2683:../Sources/drivers/mcg/mcg.c ****     // determine FRDIV based on reference clock frequency
2684:../Sources/drivers/mcg/mcg.c ****     // since the external frequency has already been checked only the maximum frequency for each FR
2685:../Sources/drivers/mcg/mcg.c **** 
2686:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
2687:../Sources/drivers/mcg/mcg.c ****     {
2688:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 0;
2689:../Sources/drivers/mcg/mcg.c ****     }
2690:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
2691:../Sources/drivers/mcg/mcg.c ****     {
2692:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 1;
2693:../Sources/drivers/mcg/mcg.c ****     }
2694:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
2695:../Sources/drivers/mcg/mcg.c ****     {
2696:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 2;
2697:../Sources/drivers/mcg/mcg.c ****     }
2698:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
2699:../Sources/drivers/mcg/mcg.c ****     {
2700:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 3;
2701:../Sources/drivers/mcg/mcg.c ****     }
2702:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
2703:../Sources/drivers/mcg/mcg.c ****     {
2704:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 4;
2705:../Sources/drivers/mcg/mcg.c ****     }
2706:../Sources/drivers/mcg/mcg.c ****     else
2707:../Sources/drivers/mcg/mcg.c ****     {
2708:../Sources/drivers/mcg/mcg.c ****         frdiv_val = 5;
2709:../Sources/drivers/mcg/mcg.c ****     }
2710:../Sources/drivers/mcg/mcg.c **** 
2711:../Sources/drivers/mcg/mcg.c ****     // The FLL ref clk divide value depends on FRDIV and the RANGE value
2712:../Sources/drivers/mcg/mcg.c **** 
2713:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
2714:../Sources/drivers/mcg/mcg.c ****     {
2715:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
2716:../Sources/drivers/mcg/mcg.c ****     }
2717:../Sources/drivers/mcg/mcg.c ****     else
2718:../Sources/drivers/mcg/mcg.c ****     {
2719:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
2720:../Sources/drivers/mcg/mcg.c ****     }
2721:../Sources/drivers/mcg/mcg.c **** 
2722:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
2723:../Sources/drivers/mcg/mcg.c **** 
2724:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
2725:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
2726:../Sources/drivers/mcg/mcg.c ****     {
2727:../Sources/drivers/mcg/mcg.c ****         return mcg_out;                 // If error code returned, return the code to calling funct
2728:../Sources/drivers/mcg/mcg.c ****     }
2729:../Sources/drivers/mcg/mcg.c **** 
2730:../Sources/drivers/mcg/mcg.c ****     // Select external oscilator and Reference Divider and clear IREFS to start ext osc
2731:../Sources/drivers/mcg/mcg.c ****     // If IRCLK is required it must be enabled outside of this driver, existing state will be maint
2732:../Sources/drivers/mcg/mcg.c ****     // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
2733:../Sources/drivers/mcg/mcg.c **** 
2734:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
2735:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
2736:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
2737:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
2738:../Sources/drivers/mcg/mcg.c **** 
2739:../Sources/drivers/mcg/mcg.c ****     // if the external oscillator is used need to wait for OSCINIT to set
2740:../Sources/drivers/mcg/mcg.c **** 
2741:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
2742:../Sources/drivers/mcg/mcg.c ****     {
2743:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 20000000; i++)
2744:../Sources/drivers/mcg/mcg.c ****         {
2745:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;      // jump out early if OSCINIT sets before lo
2746:../Sources/drivers/mcg/mcg.c ****         }
2747:../Sources/drivers/mcg/mcg.c **** 
2748:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with 
2749:../Sources/drivers/mcg/mcg.c ****     }
2750:../Sources/drivers/mcg/mcg.c **** 
2751:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock Status bit to clear
2752:../Sources/drivers/mcg/mcg.c **** 
2753:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
2754:../Sources/drivers/mcg/mcg.c ****     {
2755:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;         // jump out early if IREFST clears before l
2756:../Sources/drivers/mcg/mcg.c ****     }
2757:../Sources/drivers/mcg/mcg.c **** 
2758:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;          // check bit is really clear and return wit
2759:../Sources/drivers/mcg/mcg.c **** 
2760:../Sources/drivers/mcg/mcg.c ****     // Now in FBE
2761:../Sources/drivers/mcg/mcg.c ****     // It is recommended that the clock monitor is enabled when using an external clock as the cloc
2762:../Sources/drivers/mcg/mcg.c ****     // It is enabled here but can be removed if this is not required.
2763:../Sources/drivers/mcg/mcg.c **** 
2764:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
2765:../Sources/drivers/mcg/mcg.c ****     return mcg_out; // MCGOUT frequency equals FLL frequency
2766:../Sources/drivers/mcg/mcg.c **** }                   // fei_fee
2767:../Sources/drivers/mcg/mcg.c **** 
2768:../Sources/drivers/mcg/mcg.c **** /* */
2769:../Sources/drivers/mcg/mcg.c **** 
2770:../Sources/drivers/mcg/mcg.c **** int fee_fei
2771:../Sources/drivers/mcg/mcg.c **** (int slow_irc_freq)
2772:../Sources/drivers/mcg/mcg.c **** {
2773:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2774:../Sources/drivers/mcg/mcg.c **** 
2775:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2776:../Sources/drivers/mcg/mcg.c **** 
2777:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2778:../Sources/drivers/mcg/mcg.c **** 
2779:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2780:../Sources/drivers/mcg/mcg.c **** 
2781:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2782:../Sources/drivers/mcg/mcg.c **** 
2783:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2784:../Sources/drivers/mcg/mcg.c **** 
2785:../Sources/drivers/mcg/mcg.c ****     short   i;
2786:../Sources/drivers/mcg/mcg.c ****     int     mcg_out;
2787:../Sources/drivers/mcg/mcg.c **** 
2788:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2789:../Sources/drivers/mcg/mcg.c **** 
2790:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2791:../Sources/drivers/mcg/mcg.c **** 
2792:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2793:../Sources/drivers/mcg/mcg.c **** 
2794:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2795:../Sources/drivers/mcg/mcg.c **** 
2796:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2797:../Sources/drivers/mcg/mcg.c **** 
2798:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
2799:../Sources/drivers/mcg/mcg.c **** 
2800:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FEE mode
2801:../Sources/drivers/mcg/mcg.c **** 
2802:../Sources/drivers/mcg/mcg.c ****     if
2803:../Sources/drivers/mcg/mcg.c ****     (
2804:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
2805:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
2806:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
2807:../Sources/drivers/mcg/mcg.c ****         )
2808:../Sources/drivers/mcg/mcg.c ****     )                   // check PLLS mux has selected FLL
2809:../Sources/drivers/mcg/mcg.c ****     {
2810:../Sources/drivers/mcg/mcg.c ****         return 0x2;     // return error code
2811:../Sources/drivers/mcg/mcg.c ****     }
2812:../Sources/drivers/mcg/mcg.c **** 
2813:../Sources/drivers/mcg/mcg.c ****     // Check IRC frequency is within spec.
2814:../Sources/drivers/mcg/mcg.c **** 
2815:../Sources/drivers/mcg/mcg.c ****     if((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
2816:../Sources/drivers/mcg/mcg.c ****     {
2817:../Sources/drivers/mcg/mcg.c ****         return 0x31;
2818:../Sources/drivers/mcg/mcg.c ****     }
2819:../Sources/drivers/mcg/mcg.c **** 
2820:../Sources/drivers/mcg/mcg.c ****     // Check resulting FLL frequency
2821:../Sources/drivers/mcg/mcg.c **** 
2822:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(slow_irc_freq);
2823:../Sources/drivers/mcg/mcg.c **** 
2824:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
2825:../Sources/drivers/mcg/mcg.c ****     {
2826:../Sources/drivers/mcg/mcg.c ****         return mcg_out; // If error code returned, return the code to calling function
2827:../Sources/drivers/mcg/mcg.c ****     }
2828:../Sources/drivers/mcg/mcg.c **** 
2829:../Sources/drivers/mcg/mcg.c ****     // Ensure clock monitor is disabled before switching to FEI otherwise a loss of clock will trig
2830:../Sources/drivers/mcg/mcg.c **** 
2831:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
2832:../Sources/drivers/mcg/mcg.c **** 
2833:../Sources/drivers/mcg/mcg.c ****     // Change FLL reference clock from external to internal by setting IREFS bit
2834:../Sources/drivers/mcg/mcg.c **** 
2835:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_IREFS_MASK;                    // select internal reference
2836:../Sources/drivers/mcg/mcg.c **** 
2837:../Sources/drivers/mcg/mcg.c ****     // wait for Reference clock to switch to internal reference
2838:../Sources/drivers/mcg/mcg.c **** 
2839:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
2840:../Sources/drivers/mcg/mcg.c ****     {
2841:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
2842:../Sources/drivers/mcg/mcg.c ****     }
2843:../Sources/drivers/mcg/mcg.c **** 
2844:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
2845:../Sources/drivers/mcg/mcg.c **** 
2846:../Sources/drivers/mcg/mcg.c ****     // Now in FEI mode
2847:../Sources/drivers/mcg/mcg.c **** 
2848:../Sources/drivers/mcg/mcg.c ****     return mcg_out;
2849:../Sources/drivers/mcg/mcg.c **** }   // fee_fei
2850:../Sources/drivers/mcg/mcg.c **** 
2851:../Sources/drivers/mcg/mcg.c **** /* */
2852:../Sources/drivers/mcg/mcg.c **** 
2853:../Sources/drivers/mcg/mcg.c **** unsigned char atc
2854:../Sources/drivers/mcg/mcg.c **** (
2855:../Sources/drivers/mcg/mcg.c ****     unsigned char   irc_select,
2856:../Sources/drivers/mcg/mcg.c ****     int             irc_freq,
2857:../Sources/drivers/mcg/mcg.c ****     int             mcg_out_freq
2858:../Sources/drivers/mcg/mcg.c **** )
2859:../Sources/drivers/mcg/mcg.c **** {
2860:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2861:../Sources/drivers/mcg/mcg.c **** 
2862:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2863:../Sources/drivers/mcg/mcg.c **** 
2864:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2865:../Sources/drivers/mcg/mcg.c **** 
2866:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2867:../Sources/drivers/mcg/mcg.c **** 
2868:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2869:../Sources/drivers/mcg/mcg.c **** 
2870:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2871:../Sources/drivers/mcg/mcg.c **** 
2872:../Sources/drivers/mcg/mcg.c ****     unsigned char   mcg_mode;
2873:../Sources/drivers/mcg/mcg.c ****     unsigned short  atcv;
2874:../Sources/drivers/mcg/mcg.c ****     int             bus_clock_freq;
2875:../Sources/drivers/mcg/mcg.c ****     int             bus_clk_div_val;
2876:../Sources/drivers/mcg/mcg.c ****     int             orig_div;
2877:../Sources/drivers/mcg/mcg.c ****     int             temp_reg;
2878:../Sources/drivers/mcg/mcg.c **** 
2879:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2880:../Sources/drivers/mcg/mcg.c **** 
2881:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2882:../Sources/drivers/mcg/mcg.c **** 
2883:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2884:../Sources/drivers/mcg/mcg.c **** 
2885:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2886:../Sources/drivers/mcg/mcg.c **** 
2887:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2888:../Sources/drivers/mcg/mcg.c **** 
2889:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
2890:../Sources/drivers/mcg/mcg.c **** 
2891:../Sources/drivers/mcg/mcg.c ****     if(irc_select > 0)  // force irc to 1 if greater than 0
2892:../Sources/drivers/mcg/mcg.c ****     {
2893:../Sources/drivers/mcg/mcg.c ****         irc_select = 1;
2894:../Sources/drivers/mcg/mcg.c ****     }
2895:../Sources/drivers/mcg/mcg.c **** 
2896:../Sources/drivers/mcg/mcg.c ****     mcg_mode = what_mcg_mode();                                     // get present MCG mode
2897:../Sources/drivers/mcg/mcg.c ****     if((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
2898:../Sources/drivers/mcg/mcg.c ****     {
2899:../Sources/drivers/mcg/mcg.c ****         return 1;                                                   // return error code if not in 
2900:../Sources/drivers/mcg/mcg.c ****     }
2901:../Sources/drivers/mcg/mcg.c **** 
2902:../Sources/drivers/mcg/mcg.c ****     orig_div = SIM_CLKDIV1;                                         //store present clock divider v
2903:../Sources/drivers/mcg/mcg.c ****     bus_clk_div_val = mcg_out_freq / 16000000;                      // calculate bus clock divider 
2904:../Sources/drivers/mcg/mcg.c ****     temp_reg = SIM_CLKDIV1;
2905:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK;                          // clear dividers except core
2906:../Sources/drivers/mcg/mcg.c **** 
2907:../Sources/drivers/mcg/mcg.c ****     // set all bus and flash dividers to same value to ensure clocking restrictions are met
2908:../Sources/drivers/mcg/mcg.c **** 
2909:../Sources/drivers/mcg/mcg.c ****     temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
2910:../Sources/drivers/mcg/mcg.c ****     SIM_CLKDIV1 = temp_reg;                                         // set actual dividers
2911:../Sources/drivers/mcg/mcg.c ****     bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16) + 1);    //For KL25, flash and bus use t
2912:../Sources/drivers/mcg/mcg.c ****     if((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
2913:../Sources/drivers/mcg/mcg.c ****     {
2914:../Sources/drivers/mcg/mcg.c ****         SIM_CLKDIV1 = orig_div;     // set SIM_CLKDIV1 back to original value
2915:../Sources/drivers/mcg/mcg.c ****         return 3;                   // error, bus clock frequency is not within 8MHz to 16MHz
2916:../Sources/drivers/mcg/mcg.c ****     }
2917:../Sources/drivers/mcg/mcg.c **** 
2918:../Sources/drivers/mcg/mcg.c ****     if(!irc_select)                 //determine if slow or fast IRC to be trimmed
2919:../Sources/drivers/mcg/mcg.c ****     {
2920:../Sources/drivers/mcg/mcg.c ****         if(irc_freq < 31250)        // check frequency is above min spec.
2921:../Sources/drivers/mcg/mcg.c ****         {
2922:../Sources/drivers/mcg/mcg.c ****             SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
2923:../Sources/drivers/mcg/mcg.c ****             return 4;
2924:../Sources/drivers/mcg/mcg.c ****         }
2925:../Sources/drivers/mcg/mcg.c **** 
2926:../Sources/drivers/mcg/mcg.c ****         if(irc_freq > 39062)        // check frequency is below max spec.
2927:../Sources/drivers/mcg/mcg.c ****         {
2928:../Sources/drivers/mcg/mcg.c ****             SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
2929:../Sources/drivers/mcg/mcg.c ****             return 5;
2930:../Sources/drivers/mcg/mcg.c ****         }
2931:../Sources/drivers/mcg/mcg.c ****     }
2932:../Sources/drivers/mcg/mcg.c ****     else
2933:../Sources/drivers/mcg/mcg.c ****     {
2934:../Sources/drivers/mcg/mcg.c ****         if(irc_freq < 3000000)      // check frequency is above min spec.
2935:../Sources/drivers/mcg/mcg.c ****         {
2936:../Sources/drivers/mcg/mcg.c ****             SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
2937:../Sources/drivers/mcg/mcg.c ****             return 6;
2938:../Sources/drivers/mcg/mcg.c ****         }
2939:../Sources/drivers/mcg/mcg.c **** 
2940:../Sources/drivers/mcg/mcg.c ****         if(irc_freq > 5000000)      // check frequency is below max spec.
2941:../Sources/drivers/mcg/mcg.c ****         {
2942:../Sources/drivers/mcg/mcg.c ****             SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
2943:../Sources/drivers/mcg/mcg.c ****             return 7;
2944:../Sources/drivers/mcg/mcg.c ****         }
2945:../Sources/drivers/mcg/mcg.c ****     }   // if
2946:../Sources/drivers/mcg/mcg.c **** 
2947:../Sources/drivers/mcg/mcg.c ****     // Set up autocal registers, must use floating point calculation
2948:../Sources/drivers/mcg/mcg.c **** 
2949:../Sources/drivers/mcg/mcg.c ****     if(irc_select)
2950:../Sources/drivers/mcg/mcg.c ****         atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
2951:../Sources/drivers/mcg/mcg.c ****     else
2952:../Sources/drivers/mcg/mcg.c ****         atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
2953:../Sources/drivers/mcg/mcg.c **** 
2954:../Sources/drivers/mcg/mcg.c ****     MCG_ATCVL = (atcv & 0xFF);          //Set ATCVL to lower 8 bits of count value
2955:../Sources/drivers/mcg/mcg.c ****     MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
2956:../Sources/drivers/mcg/mcg.c **** 
2957:../Sources/drivers/mcg/mcg.c ****     // Enable autocal
2958:../Sources/drivers/mcg/mcg.c **** 
2959:../Sources/drivers/mcg/mcg.c ****     MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK | MCG_SC_ATMF_MASK);    // clear auto trim sett
2960:../Sources/drivers/mcg/mcg.c ****     temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT));      //Select IRC to trim an
2961:../Sources/drivers/mcg/mcg.c ****     MCG_SC |= temp_reg;
2962:../Sources/drivers/mcg/mcg.c **** 
2963:../Sources/drivers/mcg/mcg.c ****     while(MCG_SC & MCG_SC_ATME_MASK)
2964:../Sources/drivers/mcg/mcg.c ****     {
2965:../Sources/drivers/mcg/mcg.c ****     };
2966:../Sources/drivers/mcg/mcg.c **** 
2967:../Sources/drivers/mcg/mcg.c ****     //poll for ATME bit to clear
2968:../Sources/drivers/mcg/mcg.c **** 
2969:../Sources/drivers/mcg/mcg.c ****     if(MCG_SC & MCG_SC_ATMF_MASK)       // check if error flag set
2970:../Sources/drivers/mcg/mcg.c ****     {
2971:../Sources/drivers/mcg/mcg.c ****         SIM_CLKDIV1 = orig_div;         // set SIM_CLKDIV1 back to original value
2972:../Sources/drivers/mcg/mcg.c ****         return 8;
2973:../Sources/drivers/mcg/mcg.c ****     }
2974:../Sources/drivers/mcg/mcg.c ****     else
2975:../Sources/drivers/mcg/mcg.c ****     {
2976:../Sources/drivers/mcg/mcg.c ****         if(!irc_select)
2977:../Sources/drivers/mcg/mcg.c ****         {
2978:../Sources/drivers/mcg/mcg.c ****             if((MCG_C3 == 0xFF) || (MCG_C3 == 0))
2979:../Sources/drivers/mcg/mcg.c ****             {
2980:../Sources/drivers/mcg/mcg.c ****                 SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
2981:../Sources/drivers/mcg/mcg.c ****                 return 9;
2982:../Sources/drivers/mcg/mcg.c ****             }
2983:../Sources/drivers/mcg/mcg.c ****         }
2984:../Sources/drivers/mcg/mcg.c ****         else
2985:../Sources/drivers/mcg/mcg.c ****         {
2986:../Sources/drivers/mcg/mcg.c ****             if
2987:../Sources/drivers/mcg/mcg.c ****             (
2988:../Sources/drivers/mcg/mcg.c ****                 (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF)
2989:../Sources/drivers/mcg/mcg.c ****             ||  (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0)
2990:../Sources/drivers/mcg/mcg.c ****             )
2991:../Sources/drivers/mcg/mcg.c ****             {
2992:../Sources/drivers/mcg/mcg.c ****                 SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
2993:../Sources/drivers/mcg/mcg.c ****                 return 10;
2994:../Sources/drivers/mcg/mcg.c ****             }
2995:../Sources/drivers/mcg/mcg.c ****         }
2996:../Sources/drivers/mcg/mcg.c ****     }
2997:../Sources/drivers/mcg/mcg.c **** 
2998:../Sources/drivers/mcg/mcg.c ****     SIM_CLKDIV1 = orig_div;             // set SIM_CLKDIV1 back to original value
2999:../Sources/drivers/mcg/mcg.c ****     return 0;
3000:../Sources/drivers/mcg/mcg.c **** }   // atc
3001:../Sources/drivers/mcg/mcg.c **** 
3002:../Sources/drivers/mcg/mcg.c **** /* */
3003:../Sources/drivers/mcg/mcg.c **** 
3004:../Sources/drivers/mcg/mcg.c **** int fll_freq
3005:../Sources/drivers/mcg/mcg.c **** (int fll_ref)
3006:../Sources/drivers/mcg/mcg.c **** {
 3394              		.loc 1 3006 0
 3395              		.cfi_startproc
 3396              		@ args = 0, pretend = 0, frame = 0
 3397              		@ frame_needed = 0, uses_anonymous_args = 0
 3398              		@ link register save eliminated.
 3399              	.LVL351:
3007:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3008:../Sources/drivers/mcg/mcg.c **** 
3009:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3010:../Sources/drivers/mcg/mcg.c **** 
3011:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3012:../Sources/drivers/mcg/mcg.c **** 
3013:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3014:../Sources/drivers/mcg/mcg.c **** 
3015:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3016:../Sources/drivers/mcg/mcg.c **** 
3017:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3018:../Sources/drivers/mcg/mcg.c **** 
3019:../Sources/drivers/mcg/mcg.c ****     int fll_freq_hz;
3020:../Sources/drivers/mcg/mcg.c **** 
3021:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3022:../Sources/drivers/mcg/mcg.c **** 
3023:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3024:../Sources/drivers/mcg/mcg.c **** 
3025:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3026:../Sources/drivers/mcg/mcg.c **** 
3027:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3028:../Sources/drivers/mcg/mcg.c **** 
3029:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3030:../Sources/drivers/mcg/mcg.c **** 
3031:../Sources/drivers/mcg/mcg.c ****     /*~~~~~~~~~~~~*/
3032:../Sources/drivers/mcg/mcg.c **** 
3033:../Sources/drivers/mcg/mcg.c ****     // Check that only allowed ranges have been selected
3034:../Sources/drivers/mcg/mcg.c **** 
3035:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1)
 3400              		.loc 1 3035 0
 3401 0000 4FF48043 		mov	r3, #16384
 3402 0004 C4F20603 		movt	r3, 16390
 3403 0008 DA78     		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 3404 000a C2F34111 		ubfx	r1, r2, #5, #2
 3405 000e 0129     		cmp	r1, #1
 3406 0010 01D9     		bls	.L645
3036:../Sources/drivers/mcg/mcg.c ****     {
3037:../Sources/drivers/mcg/mcg.c ****         return 0x3B;    // return error code if DRS range 2 or 3 selected
 3407              		.loc 1 3037 0
 3408 0012 3B20     		movs	r0, #59
 3409              	.LVL352:
 3410 0014 7047     		bx	lr
 3411              	.LVL353:
 3412              	.L645:
3038:../Sources/drivers/mcg/mcg.c ****     }
3039:../Sources/drivers/mcg/mcg.c **** 
3040:../Sources/drivers/mcg/mcg.c ****     if(MCG_C4 & MCG_C4_DMX32_MASK)  // if DMX32 set
 3413              		.loc 1 3040 0
 3414 0016 DA78     		ldrb	r2, [r3, #3]	@ zero_extendqisi2
3041:../Sources/drivers/mcg/mcg.c ****     {
3042:../Sources/drivers/mcg/mcg.c ****         switch((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)    // determine multiplier
 3415              		.loc 1 3042 0
 3416 0018 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
3040:../Sources/drivers/mcg/mcg.c ****     if(MCG_C4 & MCG_C4_DMX32_MASK)  // if DMX32 set
 3417              		.loc 1 3040 0
 3418 001a 1206     		lsls	r2, r2, #24
 3419              		.loc 1 3042 0
 3420 001c C3F34111 		ubfx	r1, r3, #5, #2
3040:../Sources/drivers/mcg/mcg.c ****     if(MCG_C4 & MCG_C4_DMX32_MASK)  // if DMX32 set
 3421              		.loc 1 3040 0
 3422 0020 19D4     		bmi	.L646
3043:../Sources/drivers/mcg/mcg.c ****         {
3044:../Sources/drivers/mcg/mcg.c ****             case 0:
3045:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 732);
3046:../Sources/drivers/mcg/mcg.c **** 
3047:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 20000000)
3048:../Sources/drivers/mcg/mcg.c ****                 {
3049:../Sources/drivers/mcg/mcg.c ****                     return 0x33;
3050:../Sources/drivers/mcg/mcg.c ****                 }
3051:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 25000000)
3052:../Sources/drivers/mcg/mcg.c ****                 {
3053:../Sources/drivers/mcg/mcg.c ****                     return 0x34;
3054:../Sources/drivers/mcg/mcg.c ****                 }
3055:../Sources/drivers/mcg/mcg.c ****                 break;
3056:../Sources/drivers/mcg/mcg.c **** 
3057:../Sources/drivers/mcg/mcg.c ****             case 1:
3058:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 1464);
3059:../Sources/drivers/mcg/mcg.c **** 
3060:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 40000000)
3061:../Sources/drivers/mcg/mcg.c ****                 {
3062:../Sources/drivers/mcg/mcg.c ****                     return 0x35;
3063:../Sources/drivers/mcg/mcg.c ****                 }
3064:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 50000000)
3065:../Sources/drivers/mcg/mcg.c ****                 {
3066:../Sources/drivers/mcg/mcg.c ****                     return 0x36;
3067:../Sources/drivers/mcg/mcg.c ****                 }
3068:../Sources/drivers/mcg/mcg.c ****                 break;
3069:../Sources/drivers/mcg/mcg.c **** 
3070:../Sources/drivers/mcg/mcg.c ****             case 2:
3071:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 2197);
3072:../Sources/drivers/mcg/mcg.c **** 
3073:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 60000000)
3074:../Sources/drivers/mcg/mcg.c ****                 {
3075:../Sources/drivers/mcg/mcg.c ****                     return 0x37;
3076:../Sources/drivers/mcg/mcg.c ****                 }
3077:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 75000000)
3078:../Sources/drivers/mcg/mcg.c ****                 {
3079:../Sources/drivers/mcg/mcg.c ****                     return 0x38;
3080:../Sources/drivers/mcg/mcg.c ****                 }
3081:../Sources/drivers/mcg/mcg.c ****                 break;
3082:../Sources/drivers/mcg/mcg.c **** 
3083:../Sources/drivers/mcg/mcg.c ****             case 3:
3084:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 2929);
3085:../Sources/drivers/mcg/mcg.c **** 
3086:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 80000000)
3087:../Sources/drivers/mcg/mcg.c ****                 {
3088:../Sources/drivers/mcg/mcg.c ****                     return 0x39;
3089:../Sources/drivers/mcg/mcg.c ****                 }
3090:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 100000000)
3091:../Sources/drivers/mcg/mcg.c ****                 {
3092:../Sources/drivers/mcg/mcg.c ****                     return 0x3A;
3093:../Sources/drivers/mcg/mcg.c ****                 }
3094:../Sources/drivers/mcg/mcg.c ****                 break;
3095:../Sources/drivers/mcg/mcg.c ****         }
3096:../Sources/drivers/mcg/mcg.c ****     }
3097:../Sources/drivers/mcg/mcg.c ****     else    // if DMX32 = 0
3098:../Sources/drivers/mcg/mcg.c ****     {
3099:../Sources/drivers/mcg/mcg.c ****         switch((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)    // determine multiplier
 3423              		.loc 1 3099 0
 3424 0022 0229     		cmp	r1, #2
 3425 0024 38D0     		beq	.L630
 3426 0026 0329     		cmp	r1, #3
3100:../Sources/drivers/mcg/mcg.c ****         {
3101:../Sources/drivers/mcg/mcg.c ****             case 0:
3102:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 640);
3103:../Sources/drivers/mcg/mcg.c **** 
3104:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 20000000)
3105:../Sources/drivers/mcg/mcg.c ****                 {
3106:../Sources/drivers/mcg/mcg.c ****                     return 0x33;
3107:../Sources/drivers/mcg/mcg.c ****                 }
3108:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 25000000)
3109:../Sources/drivers/mcg/mcg.c ****                 {
3110:../Sources/drivers/mcg/mcg.c ****                     return 0x34;
3111:../Sources/drivers/mcg/mcg.c ****                 }
3112:../Sources/drivers/mcg/mcg.c ****                 break;
3113:../Sources/drivers/mcg/mcg.c **** 
3114:../Sources/drivers/mcg/mcg.c ****             case 1:
3115:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 1280);
3116:../Sources/drivers/mcg/mcg.c **** 
3117:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 40000000)
3118:../Sources/drivers/mcg/mcg.c ****                 {
3119:../Sources/drivers/mcg/mcg.c ****                     return 0x35;
3120:../Sources/drivers/mcg/mcg.c ****                 }
3121:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 50000000)
3122:../Sources/drivers/mcg/mcg.c ****                 {
3123:../Sources/drivers/mcg/mcg.c ****                     return 0x36;
3124:../Sources/drivers/mcg/mcg.c ****                 }
3125:../Sources/drivers/mcg/mcg.c ****                 break;
3126:../Sources/drivers/mcg/mcg.c **** 
3127:../Sources/drivers/mcg/mcg.c ****             case 2:
3128:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 1920);
3129:../Sources/drivers/mcg/mcg.c **** 
3130:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 60000000)
3131:../Sources/drivers/mcg/mcg.c ****                 {
3132:../Sources/drivers/mcg/mcg.c ****                     return 0x37;
3133:../Sources/drivers/mcg/mcg.c ****                 }
3134:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 75000000)
3135:../Sources/drivers/mcg/mcg.c ****                 {
3136:../Sources/drivers/mcg/mcg.c ****                     return 0x38;
3137:../Sources/drivers/mcg/mcg.c ****                 }
3138:../Sources/drivers/mcg/mcg.c ****                 break;
3139:../Sources/drivers/mcg/mcg.c **** 
3140:../Sources/drivers/mcg/mcg.c ****             case 3:
3141:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 2560);
 3427              		.loc 1 3141 0
 3428 0028 00EB8000 		add	r0, r0, r0, lsl #2
 3429              	.LVL354:
3099:../Sources/drivers/mcg/mcg.c ****         switch((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)    // determine multiplier
 3430              		.loc 1 3099 0
 3431 002c 2BD0     		beq	.L631
 3432 002e 0129     		cmp	r1, #1
 3433 0030 08D0     		beq	.L629
3104:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 20000000)
 3434              		.loc 1 3104 0
 3435 0032 42F6FF42 		movw	r2, #11519
3102:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 640);
 3436              		.loc 1 3102 0
 3437 0036 C001     		lsls	r0, r0, #7
 3438              	.LVL355:
3104:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 20000000)
 3439              		.loc 1 3104 0
 3440 0038 C0F23112 		movt	r2, 305
 3441 003c 9042     		cmp	r0, r2
 3442 003e 1ADC     		bgt	.L644
 3443              	.L637:
3049:../Sources/drivers/mcg/mcg.c ****                     return 0x33;
 3444              		.loc 1 3049 0
 3445 0040 3320     		movs	r0, #51
 3446              	.LVL356:
 3447 0042 7047     		bx	lr
 3448              	.L629:
3117:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 40000000)
 3449              		.loc 1 3117 0
 3450 0044 45F6FF13 		movw	r3, #23039
3115:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 1280);
 3451              		.loc 1 3115 0
 3452 0048 0002     		lsls	r0, r0, #8
 3453              	.LVL357:
3117:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 40000000)
 3454              		.loc 1 3117 0
 3455 004a C0F26223 		movt	r3, 610
 3456 004e 9842     		cmp	r0, r3
 3457 0050 37DC     		bgt	.L641
 3458              	.LVL358:
 3459              	.L638:
3062:../Sources/drivers/mcg/mcg.c ****                     return 0x35;
 3460              		.loc 1 3062 0
 3461 0052 3520     		movs	r0, #53
 3462 0054 7047     		bx	lr
 3463              	.LVL359:
 3464              	.L646:
3042:../Sources/drivers/mcg/mcg.c ****         switch((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)    // determine multiplier
 3465              		.loc 1 3042 0
 3466 0056 0229     		cmp	r1, #2
 3467 0058 4DD0     		beq	.L626
 3468 005a 0329     		cmp	r1, #3
 3469 005c 39D0     		beq	.L627
 3470 005e 0129     		cmp	r1, #1
 3471 0060 25D0     		beq	.L625
3047:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 20000000)
 3472              		.loc 1 3047 0
 3473 0062 42F6FF43 		movw	r3, #11519
3045:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 732);
 3474              		.loc 1 3045 0
 3475 0066 4FF43771 		mov	r1, #732
 3476 006a 01FB00F0 		mul	r0, r1, r0
 3477              	.LVL360:
3047:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 20000000)
 3478              		.loc 1 3047 0
 3479 006e C0F23113 		movt	r3, 305
 3480 0072 9842     		cmp	r0, r3
 3481 0074 E4DD     		ble	.L637
 3482              	.L644:
3108:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 25000000)
 3483              		.loc 1 3108 0
 3484 0076 47F64002 		movw	r2, #30784
 3485 007a C0F27D12 		movt	r2, 381
3053:../Sources/drivers/mcg/mcg.c ****                     return 0x34;
 3486              		.loc 1 3053 0
 3487 007e 9042     		cmp	r0, r2
 3488 0080 C8BF     		it	gt
 3489 0082 3420     		movgt	r0, #52
 3490              	.LVL361:
 3491 0084 7047     		bx	lr
 3492              	.L631:
3142:../Sources/drivers/mcg/mcg.c **** 
3143:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 80000000)
 3493              		.loc 1 3143 0
 3494 0086 4BF2FF31 		movw	r1, #46079
3141:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 2560);
 3495              		.loc 1 3141 0
 3496 008a 4002     		lsls	r0, r0, #9
 3497              	.LVL362:
 3498              		.loc 1 3143 0
 3499 008c C0F2C441 		movt	r1, 1220
 3500 0090 8842     		cmp	r0, r1
 3501 0092 28DC     		bgt	.L642
 3502              	.LVL363:
 3503              	.L640:
3088:../Sources/drivers/mcg/mcg.c ****                     return 0x39;
 3504              		.loc 1 3088 0
 3505 0094 3920     		movs	r0, #57
3144:../Sources/drivers/mcg/mcg.c ****                 {
3145:../Sources/drivers/mcg/mcg.c ****                     return 0x39;
3146:../Sources/drivers/mcg/mcg.c ****                 }
3147:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 100000000)
3148:../Sources/drivers/mcg/mcg.c ****                 {
3149:../Sources/drivers/mcg/mcg.c ****                     return 0x3A;
3150:../Sources/drivers/mcg/mcg.c ****                 }
3151:../Sources/drivers/mcg/mcg.c ****                 break;
3152:../Sources/drivers/mcg/mcg.c ****         }
3153:../Sources/drivers/mcg/mcg.c ****     }
3154:../Sources/drivers/mcg/mcg.c **** 
3155:../Sources/drivers/mcg/mcg.c ****     return fll_freq_hz;
3156:../Sources/drivers/mcg/mcg.c **** }   // fll_freq
 3506              		.loc 1 3156 0
 3507 0096 7047     		bx	lr
 3508              	.LVL364:
 3509              	.L630:
3128:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 1920);
 3510              		.loc 1 3128 0
 3511 0098 C0EB0010 		rsb	r0, r0, r0, lsl #4
 3512              	.LVL365:
3130:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 60000000)
 3513              		.loc 1 3130 0
 3514 009c 48F2FF62 		movw	r2, #34559
3128:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 1920);
 3515              		.loc 1 3128 0
 3516 00a0 C001     		lsls	r0, r0, #7
 3517              	.LVL366:
3130:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 60000000)
 3518              		.loc 1 3130 0
 3519 00a2 C0F29332 		movt	r2, 915
 3520 00a6 9042     		cmp	r0, r2
 3521 00a8 2FDC     		bgt	.L643
 3522              	.LVL367:
 3523              	.L639:
3075:../Sources/drivers/mcg/mcg.c ****                     return 0x37;
 3524              		.loc 1 3075 0
 3525 00aa 3720     		movs	r0, #55
 3526 00ac 7047     		bx	lr
 3527              	.LVL368:
 3528              	.L625:
3060:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 40000000)
 3529              		.loc 1 3060 0
 3530 00ae 45F6FF13 		movw	r3, #23039
3058:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 1464);
 3531              		.loc 1 3058 0
 3532 00b2 4FF4B761 		mov	r1, #1464
 3533 00b6 01FB00F0 		mul	r0, r1, r0
 3534              	.LVL369:
3060:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 40000000)
 3535              		.loc 1 3060 0
 3536 00ba C0F26223 		movt	r3, 610
 3537 00be 9842     		cmp	r0, r3
 3538 00c0 C7DD     		ble	.L638
 3539              	.L641:
3121:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 50000000)
 3540              		.loc 1 3121 0
 3541 00c2 4FF28002 		movw	r2, #61568
 3542 00c6 C0F2FA22 		movt	r2, 762
3066:../Sources/drivers/mcg/mcg.c ****                     return 0x36;
 3543              		.loc 1 3066 0
 3544 00ca 9042     		cmp	r0, r2
 3545 00cc C8BF     		it	gt
 3546 00ce 3620     		movgt	r0, #54
 3547 00d0 7047     		bx	lr
 3548              	.LVL370:
 3549              	.L627:
3086:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 80000000)
 3550              		.loc 1 3086 0
 3551 00d2 4BF2FF33 		movw	r3, #46079
3084:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 2929);
 3552              		.loc 1 3084 0
 3553 00d6 40F67131 		movw	r1, #2929
 3554 00da 01FB00F0 		mul	r0, r1, r0
 3555              	.LVL371:
3086:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 80000000)
 3556              		.loc 1 3086 0
 3557 00de C0F2C443 		movt	r3, 1220
 3558 00e2 9842     		cmp	r0, r3
 3559 00e4 D6DD     		ble	.L640
 3560              	.L642:
3147:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 100000000)
 3561              		.loc 1 3147 0
 3562 00e6 4FF46142 		mov	r2, #57600
 3563 00ea C0F2F552 		movt	r2, 1525
3092:../Sources/drivers/mcg/mcg.c ****                     return 0x3A;
 3564              		.loc 1 3092 0
 3565 00ee 9042     		cmp	r0, r2
 3566 00f0 C8BF     		it	gt
 3567 00f2 3A20     		movgt	r0, #58
 3568 00f4 7047     		bx	lr
 3569              	.LVL372:
 3570              	.L626:
3073:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 60000000)
 3571              		.loc 1 3073 0
 3572 00f6 48F2FF63 		movw	r3, #34559
3071:../Sources/drivers/mcg/mcg.c ****                 fll_freq_hz = (fll_ref * 2197);
 3573              		.loc 1 3071 0
 3574 00fa 40F69501 		movw	r1, #2197
 3575 00fe 01FB00F0 		mul	r0, r1, r0
 3576              	.LVL373:
3073:../Sources/drivers/mcg/mcg.c ****                 if(fll_freq_hz < 60000000)
 3577              		.loc 1 3073 0
 3578 0102 C0F29333 		movt	r3, 915
 3579 0106 9842     		cmp	r0, r3
 3580 0108 CFDD     		ble	.L639
 3581              	.L643:
3134:../Sources/drivers/mcg/mcg.c ****                 else if(fll_freq_hz > 75000000)
 3582              		.loc 1 3134 0
 3583 010a 46F6C002 		movw	r2, #26816
 3584 010e C0F27842 		movt	r2, 1144
3079:../Sources/drivers/mcg/mcg.c ****                     return 0x38;
 3585              		.loc 1 3079 0
 3586 0112 9042     		cmp	r0, r2
 3587 0114 C8BF     		it	gt
 3588 0116 3820     		movgt	r0, #56
 3589 0118 7047     		bx	lr
 3590              		.cfi_endproc
 3591              	.LFE25:
 3593 011a 00BF     		.section	.text.fee_fei,"ax",%progbits
 3594              		.align	2
 3595              		.global	fee_fei
 3596              		.thumb
 3597              		.thumb_func
 3599              	fee_fei:
 3600              	.LFB23:
2772:../Sources/drivers/mcg/mcg.c **** {
 3601              		.loc 1 2772 0
 3602              		.cfi_startproc
 3603              		@ args = 0, pretend = 0, frame = 0
 3604              		@ frame_needed = 0, uses_anonymous_args = 0
 3605              	.LVL374:
 3606 0000 10B5     		push	{r4, lr}
 3607              	.LCFI12:
 3608              		.cfi_def_cfa_offset 8
 3609              		.cfi_offset 4, -8
 3610              		.cfi_offset 14, -4
2804:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 3611              		.loc 1 2804 0
 3612 0002 4FF48044 		mov	r4, #16384
 3613 0006 C4F20604 		movt	r4, 16390
 3614 000a A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
2803:../Sources/drivers/mcg/mcg.c ****     (
 3615              		.loc 1 2803 0
 3616 000c 13F00C0F 		tst	r3, #12
 3617 0010 01D0     		beq	.L658
 3618              	.L653:
2810:../Sources/drivers/mcg/mcg.c ****         return 0x2;     // return error code
 3619              		.loc 1 2810 0
 3620 0012 0220     		movs	r0, #2
 3621              	.LVL375:
 3622 0014 10BD     		pop	{r4, pc}
 3623              	.LVL376:
 3624              	.L658:
2805:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 3625              		.loc 1 2805 0
 3626 0016 A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 3627 0018 01F01003 		and	r3, r1, #16
 3628 001c D9B2     		uxtb	r1, r3
 3629 001e 0029     		cmp	r1, #0
 3630 0020 F7D1     		bne	.L653
2806:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
 3631              		.loc 1 2806 0
 3632 0022 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
2804:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 3633              		.loc 1 2804 0
 3634 0024 03F02001 		and	r1, r3, #32
 3635 0028 CBB2     		uxtb	r3, r1
 3636 002a 002B     		cmp	r3, #0
 3637 002c F1D1     		bne	.L653
2815:../Sources/drivers/mcg/mcg.c ****     if((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 3638              		.loc 1 2815 0
 3639 002e A0F5F442 		sub	r2, r0, #31232
 3640 0032 123A     		subs	r2, r2, #18
 3641 0034 41F68561 		movw	r1, #7813
 3642 0038 8A42     		cmp	r2, r1
 3643 003a 01D9     		bls	.L659
2817:../Sources/drivers/mcg/mcg.c ****         return 0x31;
 3644              		.loc 1 2817 0
 3645 003c 3120     		movs	r0, #49
 3646              	.LVL377:
 3647              	.L648:
2849:../Sources/drivers/mcg/mcg.c **** }   // fee_fei
 3648              		.loc 1 2849 0
 3649 003e 10BD     		pop	{r4, pc}
 3650              	.LVL378:
 3651              	.L659:
2822:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(slow_irc_freq);
 3652              		.loc 1 2822 0
 3653 0040 FFF7FEFF 		bl	fll_freq
 3654              	.LVL379:
2824:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 3655              		.loc 1 2824 0
 3656 0044 3B28     		cmp	r0, #59
 3657 0046 FADD     		ble	.L648
2831:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 3658              		.loc 1 2831 0
 3659 0048 6379     		ldrb	r3, [r4, #5]	@ zero_extendqisi2
 3660 004a 03F0DF02 		and	r2, r3, #223
 3661 004e 6271     		strb	r2, [r4, #5]
2835:../Sources/drivers/mcg/mcg.c ****     MCG_C1 |= MCG_C1_IREFS_MASK;                    // select internal reference
 3662              		.loc 1 2835 0
 3663 0050 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 3664 0052 41F00403 		orr	r3, r1, #4
 3665 0056 2370     		strb	r3, [r4, #0]
 3666              	.LVL380:
 3667 0058 4FF4FA63 		mov	r3, #2000
 3668 005c 08E0     		b	.L650
 3669              	.LVL381:
 3670              	.L660:
2841:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
 3671              		.loc 1 2841 0
 3672 005e A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 3673 0060 9BB2     		uxth	r3, r3
 3674 0062 01F01002 		and	r2, r1, #16
 3675 0066 D1B2     		uxtb	r1, r2
 3676 0068 5A1E     		subs	r2, r3, #1
 3677 006a 93B2     		uxth	r3, r2
 3678 006c 39B9     		cbnz	r1, .L649
2839:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3679              		.loc 1 2839 0
 3680 006e 33B1     		cbz	r3, .L649
 3681              	.L650:
2841:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
 3682              		.loc 1 2841 0
 3683 0070 A279     		ldrb	r2, [r4, #6]	@ zero_extendqisi2
 3684 0072 02F01001 		and	r1, r2, #16
 3685 0076 CAB2     		uxtb	r2, r1
 3686 0078 013B     		subs	r3, r3, #1
 3687 007a 002A     		cmp	r2, #0
 3688 007c EFD0     		beq	.L660
 3689              	.L649:
2844:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 3690              		.loc 1 2844 0
 3691 007e 4FF48041 		mov	r1, #16384
 3692 0082 C4F20601 		movt	r1, 16390
 3693 0086 8A79     		ldrb	r2, [r1, #6]	@ zero_extendqisi2
 3694 0088 02F01003 		and	r3, r2, #16
 3695 008c D9B2     		uxtb	r1, r3
 3696 008e 0029     		cmp	r1, #0
 3697 0090 08BF     		it	eq
 3698 0092 1220     		moveq	r0, #18
 3699              	.LVL382:
 3700 0094 10BD     		pop	{r4, pc}
 3701              		.cfi_endproc
 3702              	.LFE23:
 3704 0096 00BF     		.section	.text.fei_fee,"ax",%progbits
 3705              		.align	2
 3706              		.global	fei_fee
 3707              		.thumb
 3708              		.thumb_func
 3710              	fei_fee:
 3711              	.LFB22:
2593:../Sources/drivers/mcg/mcg.c **** {
 3712              		.loc 1 2593 0
 3713              		.cfi_startproc
 3714              		@ args = 0, pretend = 0, frame = 8
 3715              		@ frame_needed = 0, uses_anonymous_args = 0
 3716              	.LVL383:
 3717 0000 30B5     		push	{r4, r5, lr}
 3718              	.LCFI13:
 3719              		.cfi_def_cfa_offset 12
 3720              		.cfi_offset 4, -12
 3721              		.cfi_offset 5, -8
 3722              		.cfi_offset 14, -4
2629:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 3723              		.loc 1 2629 0
 3724 0002 4FF48043 		mov	r3, #16384
 3725 0006 C4F20603 		movt	r3, 16390
2593:../Sources/drivers/mcg/mcg.c **** {
 3726              		.loc 1 2593 0
 3727 000a 83B0     		sub	sp, sp, #12
 3728              	.LCFI14:
 3729              		.cfi_def_cfa_offset 24
2629:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 3730              		.loc 1 2629 0
 3731 000c 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
2628:../Sources/drivers/mcg/mcg.c ****     (
 3732              		.loc 1 2628 0
 3733 000e 14F00C0F 		tst	r4, #12
 3734 0012 11D1     		bne	.L676
2630:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
 3735              		.loc 1 2630 0
 3736 0014 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 3737 0016 04F01004 		and	r4, r4, #16
 3738 001a E4B2     		uxtb	r4, r4
 3739 001c 64B1     		cbz	r4, .L676
2631:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
 3740              		.loc 1 2631 0
 3741 001e 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
2629:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)    // check CLKS mux has selct
 3742              		.loc 1 2629 0
 3743 0020 03F02003 		and	r3, r3, #32
 3744 0024 DBB2     		uxtb	r3, r3
 3745 0026 3BB9     		cbnz	r3, .L676
2640:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
 3746              		.loc 1 2640 0
 3747 0028 4FF28003 		movw	r3, #61568
 3748 002c C0F2FA23 		movt	r3, 762
 3749 0030 9842     		cmp	r0, r3
 3750 0032 04DD     		ble	.L712
2642:../Sources/drivers/mcg/mcg.c ****         return 0x21;
 3751              		.loc 1 2642 0
 3752 0034 2120     		movs	r0, #33
 3753              	.LVL384:
 3754 0036 00E0     		b	.L662
 3755              	.LVL385:
 3756              	.L676:
2635:../Sources/drivers/mcg/mcg.c ****         return 0x1;         // return error code
 3757              		.loc 1 2635 0
 3758 0038 0120     		movs	r0, #1
 3759              	.LVL386:
 3760              	.L662:
2766:../Sources/drivers/mcg/mcg.c **** }                   // fei_fee
 3761              		.loc 1 2766 0
 3762 003a 03B0     		add	sp, sp, #12
 3763 003c 30BD     		pop	{r4, r5, pc}
 3764              	.LVL387:
 3765              	.L712:
2647:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 3766              		.loc 1 2647 0
 3767 003e 002A     		cmp	r2, #0
 3768 0040 53D1     		bne	.L713
 3769              	.L663:
2666:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 3770              		.loc 1 2666 0
 3771 0042 4FF48043 		mov	r3, #16384
 3772 0046 C4F20603 		movt	r3, 16390
2659:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 3773              		.loc 1 2659 0
 3774 004a 0031     		adds	r1, r1, #0
 3775              	.LVL388:
2666:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 3776              		.loc 1 2666 0
 3777 004c 5D78     		ldrb	r5, [r3, #1]	@ zero_extendqisi2
2668:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 3778              		.loc 1 2668 0
 3779 004e 49F64044 		movw	r4, #40000
2659:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 3780              		.loc 1 2659 0
 3781 0052 18BF     		it	ne
 3782 0054 0121     		movne	r1, #1
 3783              	.LVL389:
2668:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 3784              		.loc 1 2668 0
 3785 0056 A042     		cmp	r0, r4
2667:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 3786              		.loc 1 2667 0
 3787 0058 05F0C305 		and	r5, r5, #195
 3788              	.LVL390:
2668:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 3789              		.loc 1 2668 0
 3790 005c 5CDC     		bgt	.L664
2670:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 3791              		.loc 1 2670 0
 3792 005e 45EA8205 		orr	r5, r5, r2, lsl #2
 3793              	.LVL391:
 3794 0062 ECB2     		uxtb	r4, r5
 3795 0064 44EAC101 		orr	r1, r4, r1, lsl #3
 3796              	.LVL392:
2681:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 3797              		.loc 1 2681 0
 3798 0068 5970     		strb	r1, [r3, #1]
 3799 006a 0024     		movs	r4, #0
 3800 006c 0121     		movs	r1, #1
 3801              	.LVL393:
 3802 006e 2025     		movs	r5, #32
 3803              	.L665:
2713:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 3804              		.loc 1 2713 0
 3805 0070 4FF48043 		mov	r3, #16384
 3806 0074 C4F20603 		movt	r3, 16390
 3807 0078 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
2724:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
 3808              		.loc 1 2724 0
 3809 007a 0192     		str	r2, [sp, #4]
2713:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 3810              		.loc 1 2713 0
 3811 007c 13F0300F 		tst	r3, #48
2715:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
 3812              		.loc 1 2715 0
 3813 0080 14BF     		ite	ne
 3814 0082 90FBF5F0 		sdivne	r0, r0, r5
 3815              	.LVL394:
2719:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 3816              		.loc 1 2719 0
 3817 0086 90FBF1F0 		sdiveq	r0, r0, r1
 3818              	.LVL395:
2724:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
 3819              		.loc 1 2724 0
 3820 008a FFF7FEFF 		bl	fll_freq
 3821              	.LVL396:
2725:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 3822              		.loc 1 2725 0
 3823 008e 3B28     		cmp	r0, #59
 3824 0090 019A     		ldr	r2, [sp, #4]
 3825 0092 D2DD     		ble	.L662
2734:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 3826              		.loc 1 2734 0
 3827 0094 4FF48041 		mov	r1, #16384
 3828 0098 C4F20601 		movt	r1, 16390
 3829 009c 0B78     		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 3830              	.LVL397:
2735:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear values in 
 3831              		.loc 1 2735 0
 3832 009e 03F00303 		and	r3, r3, #3
 3833              	.LVL398:
2736:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 3834              		.loc 1 2736 0
 3835 00a2 1C43     		orrs	r4, r4, r3
 3836              	.LVL399:
2737:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 3837              		.loc 1 2737 0
 3838 00a4 0C70     		strb	r4, [r1, #0]
2741:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 3839              		.loc 1 2741 0
 3840 00a6 002A     		cmp	r2, #0
 3841 00a8 6DD0     		beq	.L670
 3842 00aa 4FF43453 		mov	r3, #11520
 3843 00ae C0F23113 		movt	r3, 305
2745:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;      // jump out early if OSCINIT sets before lo
 3844              		.loc 1 2745 0
 3845 00b2 0A46     		mov	r2, r1
 3846 00b4 07E0     		b	.L672
 3847              	.LVL400:
 3848              	.L714:
 3849 00b6 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3850 00b8 01F00201 		and	r1, r1, #2
 3851 00bc C9B2     		uxtb	r1, r1
 3852 00be 013B     		subs	r3, r3, #1
 3853 00c0 39B9     		cbnz	r1, .L671
2743:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 20000000; i++)
 3854              		.loc 1 2743 0
 3855 00c2 013B     		subs	r3, r3, #1
 3856 00c4 05D0     		beq	.L671
 3857              	.L672:
2745:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;      // jump out early if OSCINIT sets before lo
 3858              		.loc 1 2745 0
 3859 00c6 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3860 00c8 01F00201 		and	r1, r1, #2
 3861 00cc C9B2     		uxtb	r1, r1
 3862 00ce 0029     		cmp	r1, #0
 3863 00d0 F1D0     		beq	.L714
 3864              	.L671:
2748:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with 
 3865              		.loc 1 2748 0
 3866 00d2 4FF48042 		mov	r2, #16384
 3867 00d6 C4F20602 		movt	r2, 16390
 3868 00da 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3869 00dc 01F00203 		and	r3, r1, #2
 3870 00e0 DAB2     		uxtb	r2, r3
 3871 00e2 002A     		cmp	r2, #0
 3872 00e4 4FD1     		bne	.L670
 3873 00e6 2320     		movs	r0, #35
 3874              	.LVL401:
 3875 00e8 A7E7     		b	.L662
 3876              	.LVL402:
 3877              	.L713:
2649:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
 3878              		.loc 1 2649 0
 3879 00ea 47F22F53 		movw	r3, #29999
 3880 00ee 9842     		cmp	r0, r3
 3881 00f0 01DC     		bgt	.L715
 3882              	.L680:
2651:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return error if one of the available crystal options is not availabl
 3883              		.loc 1 2651 0
 3884 00f2 2220     		movs	r0, #34
 3885              	.LVL403:
 3886 00f4 A1E7     		b	.L662
 3887              	.LVL404:
 3888              	.L715:
2649:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
 3889              		.loc 1 2649 0
 3890 00f6 A0F51C44 		sub	r4, r0, #39936
 3891 00fa 42F67E23 		movw	r3, #10878
 3892 00fe 413C     		subs	r4, r4, #65
 3893 0100 C0F22D03 		movt	r3, 45
 3894 0104 9C42     		cmp	r4, r3
 3895 0106 F4D9     		bls	.L680
 3896 0108 4FF49043 		mov	r3, #18432
 3897 010c C0F2E813 		movt	r3, 488
 3898 0110 9842     		cmp	r0, r3
 3899 0112 96DD     		ble	.L663
2651:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return error if one of the available crystal options is not availabl
 3900              		.loc 1 2651 0
 3901 0114 2220     		movs	r0, #34
 3902              	.LVL405:
 3903 0116 90E7     		b	.L662
 3904              	.LVL406:
 3905              	.L664:
2672:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
 3906              		.loc 1 2672 0
 3907 0118 4FF49054 		mov	r4, #4608
 3908 011c C0F27A04 		movt	r4, 122
 3909 0120 A042     		cmp	r0, r4
 3910 0122 5EDC     		bgt	.L666
2674:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 3911              		.loc 1 2674 0
 3912 0124 45F01004 		orr	r4, r5, #16
 3913 0128 44EA8205 		orr	r5, r4, r2, lsl #2
 3914              	.LVL407:
2686:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 3915              		.loc 1 2686 0
 3916 012c 41F2D024 		movw	r4, #4816
2674:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 3917              		.loc 1 2674 0
 3918 0130 EDB2     		uxtb	r5, r5
2686:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 3919              		.loc 1 2686 0
 3920 0132 C0F21304 		movt	r4, 19
2674:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 3921              		.loc 1 2674 0
 3922 0136 45EAC101 		orr	r1, r5, r1, lsl #3
 3923              	.LVL408:
2686:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 3924              		.loc 1 2686 0
 3925 013a A042     		cmp	r0, r4
2681:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 3926              		.loc 1 2681 0
 3927 013c 5970     		strb	r1, [r3, #1]
2686:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 3928              		.loc 1 2686 0
 3929 013e 67DD     		ble	.L716
 3930              	.LVL409:
 3931              	.L667:
2690:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 3932              		.loc 1 2690 0
 3933 0140 42F2A053 		movw	r3, #9632
 3934 0144 C0F22603 		movt	r3, 38
 3935 0148 9842     		cmp	r0, r3
 3936 014a 46DD     		ble	.L682
2694:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 3937              		.loc 1 2694 0
 3938 014c 44F64035 		movw	r5, #19264
 3939 0150 C0F24C05 		movt	r5, 76
 3940 0154 A842     		cmp	r0, r5
 3941 0156 52DD     		ble	.L683
2698:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 3942              		.loc 1 2698 0
 3943 0158 49F28064 		movw	r4, #38528
 3944 015c C0F29804 		movt	r4, 152
 3945 0160 A042     		cmp	r0, r4
 3946 0162 50DD     		ble	.L684
2702:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 3947              		.loc 1 2702 0
 3948 0164 4FF43451 		mov	r1, #11520
 3949 0168 C0F23111 		movt	r1, 305
 3950 016c 8842     		cmp	r0, r1
 3951 016e CCBF     		ite	gt
 3952 0170 2824     		movgt	r4, #40
 3953 0172 2024     		movle	r4, #32
 3954 0174 CCBF     		ite	gt
 3955 0176 2021     		movgt	r1, #32
 3956 0178 1021     		movle	r1, #16
 3957 017a CCBF     		ite	gt
 3958 017c 4FF48065 		movgt	r5, #1024
 3959 0180 4FF40075 		movle	r5, #512
 3960 0184 74E7     		b	.L665
 3961              	.LVL410:
 3962              	.L670:
2755:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;         // jump out early if IREFST clears before l
 3963              		.loc 1 2755 0
 3964 0186 4FF48042 		mov	r2, #16384
 3965 018a C4F20602 		movt	r2, 16390
 3966 018e 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3967 0190 01F01003 		and	r3, r1, #16
 3968 0194 D9B2     		uxtb	r1, r3
 3969 0196 A9B1     		cbz	r1, .L673
 3970 0198 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 3971 019a 03F01001 		and	r1, r3, #16
 3972 019e CBB2     		uxtb	r3, r1
 3973 01a0 83B1     		cbz	r3, .L673
 3974 01a2 40F2CE73 		movw	r3, #1998
 3975 01a6 07E0     		b	.L693
 3976              	.L717:
 3977 01a8 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3978 01aa 01F01001 		and	r1, r1, #16
 3979 01ae C9B2     		uxtb	r1, r1
 3980 01b0 013B     		subs	r3, r3, #1
 3981 01b2 39B1     		cbz	r1, .L673
2753:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 3982              		.loc 1 2753 0
 3983 01b4 013B     		subs	r3, r3, #1
 3984 01b6 05D0     		beq	.L673
 3985              	.L693:
2755:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;         // jump out early if IREFST clears before l
 3986              		.loc 1 2755 0
 3987 01b8 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3988 01ba 01F01001 		and	r1, r1, #16
 3989 01be C9B2     		uxtb	r1, r1
 3990 01c0 0029     		cmp	r1, #0
 3991 01c2 F1D1     		bne	.L717
 3992              	.L673:
2758:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;          // check bit is really clear and return wit
 3993              		.loc 1 2758 0
 3994 01c4 4FF48041 		mov	r1, #16384
 3995 01c8 C4F20601 		movt	r1, 16390
 3996 01cc 8A79     		ldrb	r2, [r1, #6]	@ zero_extendqisi2
 3997 01ce 02F01003 		and	r3, r2, #16
 3998 01d2 DAB2     		uxtb	r2, r3
 3999 01d4 72B1     		cbz	r2, .L718
 4000 01d6 1120     		movs	r0, #17
 4001              	.LVL411:
 4002 01d8 2FE7     		b	.L662
 4003              	.LVL412:
 4004              	.L682:
2690:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 4005              		.loc 1 2690 0
 4006 01da 0824     		movs	r4, #8
 4007 01dc 0221     		movs	r1, #2
 4008 01de 4025     		movs	r5, #64
 4009 01e0 46E7     		b	.L665
 4010              	.LVL413:
 4011              	.L666:
2678:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 4012              		.loc 1 2678 0
 4013 01e2 45F02005 		orr	r5, r5, #32
 4014              	.LVL414:
 4015 01e6 45EA8204 		orr	r4, r5, r2, lsl #2
 4016 01ea E5B2     		uxtb	r5, r4
 4017 01ec 45EAC101 		orr	r1, r5, r1, lsl #3
 4018              	.LVL415:
2681:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 4019              		.loc 1 2681 0
 4020 01f0 5970     		strb	r1, [r3, #1]
 4021 01f2 A5E7     		b	.L667
 4022              	.LVL416:
 4023              	.L718:
2764:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 4024              		.loc 1 2764 0
 4025 01f4 4B79     		ldrb	r3, [r1, #5]	@ zero_extendqisi2
 4026 01f6 43F02002 		orr	r2, r3, #32
 4027 01fa 4A71     		strb	r2, [r1, #5]
2765:../Sources/drivers/mcg/mcg.c ****     return mcg_out; // MCGOUT frequency equals FLL frequency
 4028              		.loc 1 2765 0
 4029 01fc 1DE7     		b	.L662
 4030              	.LVL417:
 4031              	.L683:
2694:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 4032              		.loc 1 2694 0
 4033 01fe 1024     		movs	r4, #16
 4034 0200 0421     		movs	r1, #4
 4035 0202 8025     		movs	r5, #128
 4036 0204 34E7     		b	.L665
 4037              	.L684:
2698:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 4038              		.loc 1 2698 0
 4039 0206 1824     		movs	r4, #24
 4040 0208 0821     		movs	r1, #8
 4041 020a 4FF48075 		mov	r5, #256
 4042 020e 2FE7     		b	.L665
 4043              	.LVL418:
 4044              	.L716:
2686:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 4045              		.loc 1 2686 0
 4046 0210 0024     		movs	r4, #0
 4047 0212 0121     		movs	r1, #1
 4048              	.LVL419:
 4049 0214 2025     		movs	r5, #32
 4050 0216 2BE7     		b	.L665
 4051              		.cfi_endproc
 4052              	.LFE22:
 4054              		.section	.text.fbi_fei,"ax",%progbits
 4055              		.align	2
 4056              		.global	fbi_fei
 4057              		.thumb
 4058              		.thumb_func
 4060              	fbi_fei:
 4061              	.LFB20:
2350:../Sources/drivers/mcg/mcg.c **** {
 4062              		.loc 1 2350 0
 4063              		.cfi_startproc
 4064              		@ args = 0, pretend = 0, frame = 0
 4065              		@ frame_needed = 0, uses_anonymous_args = 0
 4066              	.LVL420:
 4067 0000 10B5     		push	{r4, lr}
 4068              	.LCFI15:
 4069              		.cfi_def_cfa_offset 8
 4070              		.cfi_offset 4, -8
 4071              		.cfi_offset 14, -4
2383:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4072              		.loc 1 2383 0
 4073 0002 4FF48044 		mov	r4, #16384
 4074 0006 C4F20604 		movt	r4, 16390
 4075 000a A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4076 000c C3F38101 		ubfx	r1, r3, #2, #2
2382:../Sources/drivers/mcg/mcg.c ****     (
 4077              		.loc 1 2382 0
 4078 0010 0129     		cmp	r1, #1
 4079 0012 01D0     		beq	.L743
 4080              	.L728:
2390:../Sources/drivers/mcg/mcg.c ****         return 0x3;     // MCG not in correct mode return fail code
 4081              		.loc 1 2390 0
 4082 0014 0320     		movs	r0, #3
 4083              	.LVL421:
 4084 0016 10BD     		pop	{r4, pc}
 4085              	.LVL422:
 4086              	.L743:
2384:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 4087              		.loc 1 2384 0
 4088 0018 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4089 001a 03F01001 		and	r1, r3, #16
 4090 001e CBB2     		uxtb	r3, r1
 4091 0020 002B     		cmp	r3, #0
 4092 0022 F7D0     		beq	.L728
2385:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 4093              		.loc 1 2385 0
 4094 0024 A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 4095 0026 01F02003 		and	r3, r1, #32
 4096 002a D9B2     		uxtb	r1, r3
 4097 002c 0029     		cmp	r1, #0
 4098 002e F1D1     		bne	.L728
2386:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 4099              		.loc 1 2386 0
 4100 0030 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
2383:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4101              		.loc 1 2383 0
 4102 0032 03F00201 		and	r1, r3, #2
 4103 0036 CBB2     		uxtb	r3, r1
 4104 0038 002B     		cmp	r3, #0
 4105 003a EBD1     		bne	.L728
2395:../Sources/drivers/mcg/mcg.c ****     if((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4106              		.loc 1 2395 0
 4107 003c A0F5F442 		sub	r2, r0, #31232
 4108 0040 123A     		subs	r2, r2, #18
 4109 0042 41F68561 		movw	r1, #7813
 4110 0046 8A42     		cmp	r2, r1
 4111 0048 01D9     		bls	.L744
2397:../Sources/drivers/mcg/mcg.c ****         return 0x31;
 4112              		.loc 1 2397 0
 4113 004a 3120     		movs	r0, #49
 4114              	.LVL423:
 4115 004c 10BD     		pop	{r4, pc}
 4116              	.LVL424:
 4117              	.L744:
2402:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(slow_irc_freq);
 4118              		.loc 1 2402 0
 4119 004e FFF7FEFF 		bl	fll_freq
 4120              	.LVL425:
2404:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 4121              		.loc 1 2404 0
 4122 0052 3B28     		cmp	r0, #59
 4123 0054 22DD     		ble	.L720
2411:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 4124              		.loc 1 2411 0
 4125 0056 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 4126              	.LVL426:
2412:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                  // clear CLKS field
 4127              		.loc 1 2412 0
 4128 0058 03F03F02 		and	r2, r3, #63
 4129              	.LVL427:
2414:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_IREFS_MASK;                  // make sure IRC is FLL reference
 4130              		.loc 1 2414 0
 4131 005c 42F00401 		orr	r1, r2, #4
 4132              	.LVL428:
2415:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;                              // update MCG_C1
 4133              		.loc 1 2415 0
 4134 0060 2170     		strb	r1, [r4, #0]
 4135              	.LVL429:
 4136 0062 4FF4FA63 		mov	r3, #2000
 4137 0066 08E0     		b	.L722
 4138              	.LVL430:
 4139              	.L745:
2421:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST clears before loop 
 4140              		.loc 1 2421 0
 4141 0068 A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 4142 006a 9BB2     		uxth	r3, r3
 4143 006c 01F01002 		and	r2, r1, #16
 4144 0070 D1B2     		uxtb	r1, r2
 4145 0072 5A1E     		subs	r2, r3, #1
 4146 0074 93B2     		uxth	r3, r2
 4147 0076 39B9     		cbnz	r1, .L721
2419:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4148              		.loc 1 2419 0
 4149 0078 33B1     		cbz	r3, .L721
 4150              	.L722:
2421:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST clears before loop 
 4151              		.loc 1 2421 0
 4152 007a A279     		ldrb	r2, [r4, #6]	@ zero_extendqisi2
 4153 007c 02F01001 		and	r1, r2, #16
 4154 0080 CAB2     		uxtb	r2, r1
 4155 0082 013B     		subs	r3, r3, #1
 4156 0084 002A     		cmp	r2, #0
 4157 0086 EFD0     		beq	.L745
 4158              	.L721:
2424:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 4159              		.loc 1 2424 0
 4160 0088 4FF48043 		mov	r3, #16384
 4161 008c C4F20603 		movt	r3, 16390
 4162 0090 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4163 0092 01F01002 		and	r2, r1, #16
 4164 0096 D1B2     		uxtb	r1, r2
 4165 0098 09B9     		cbnz	r1, .L746
 4166 009a 1220     		movs	r0, #18
 4167              	.LVL431:
 4168              	.L720:
2438:../Sources/drivers/mcg/mcg.c **** }   // fbi_fei
 4169              		.loc 1 2438 0
 4170 009c 10BD     		pop	{r4, pc}
 4171              	.LVL432:
 4172              	.L746:
2424:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 4173              		.loc 1 2424 0
 4174 009e 4FF4FA62 		mov	r2, #2000
 4175 00a2 06E0     		b	.L724
 4176              	.L747:
2430:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out early i
 4177              		.loc 1 2430 0
 4178 00a4 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4179 00a6 11F00C0F 		tst	r1, #12
 4180 00aa 08D0     		beq	.L723
 4181 00ac 013A     		subs	r2, r2, #1
 4182 00ae 92B2     		uxth	r2, r2
2428:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4183              		.loc 1 2428 0
 4184 00b0 2AB1     		cbz	r2, .L723
 4185              	.L724:
2430:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out early i
 4186              		.loc 1 2430 0
 4187 00b2 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4188 00b4 013A     		subs	r2, r2, #1
 4189 00b6 11F00C0F 		tst	r1, #12
 4190 00ba 92B2     		uxth	r2, r2
 4191 00bc F2D1     		bne	.L747
 4192              	.L723:
2433:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check FLL is rea
 4193              		.loc 1 2433 0
 4194 00be 4FF48043 		mov	r3, #16384
 4195 00c2 C4F20603 		movt	r3, 16390
 4196 00c6 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4197 00c8 11F00C0F 		tst	r1, #12
 4198 00cc 18BF     		it	ne
 4199 00ce 1820     		movne	r0, #24
 4200              	.LVL433:
 4201 00d0 10BD     		pop	{r4, pc}
 4202              		.cfi_endproc
 4203              	.LFE20:
 4205 00d2 00BF     		.section	.text.fbi_fee,"ax",%progbits
 4206              		.align	2
 4207              		.global	fbi_fee
 4208              		.thumb
 4209              		.thumb_func
 4211              	fbi_fee:
 4212              	.LFB18:
2026:../Sources/drivers/mcg/mcg.c **** {
 4213              		.loc 1 2026 0
 4214              		.cfi_startproc
 4215              		@ args = 0, pretend = 0, frame = 8
 4216              		@ frame_needed = 0, uses_anonymous_args = 0
 4217              	.LVL434:
 4218 0000 30B5     		push	{r4, r5, lr}
 4219              	.LCFI16:
 4220              		.cfi_def_cfa_offset 12
 4221              		.cfi_offset 4, -12
 4222              		.cfi_offset 5, -8
 4223              		.cfi_offset 14, -4
2060:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4224              		.loc 1 2060 0
 4225 0002 4FF48043 		mov	r3, #16384
 4226 0006 C4F20603 		movt	r3, 16390
2026:../Sources/drivers/mcg/mcg.c **** {
 4227              		.loc 1 2026 0
 4228 000a 83B0     		sub	sp, sp, #12
 4229              	.LCFI17:
 4230              		.cfi_def_cfa_offset 24
2060:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4231              		.loc 1 2060 0
 4232 000c 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 4233 000e C4F38104 		ubfx	r4, r4, #2, #2
2059:../Sources/drivers/mcg/mcg.c ****     (
 4234              		.loc 1 2059 0
 4235 0012 012C     		cmp	r4, #1
 4236 0014 02D0     		beq	.L809
 4237              	.L766:
2067:../Sources/drivers/mcg/mcg.c ****         return 0x3;         // MCG not in correct mode return fail code
 4238              		.loc 1 2067 0
 4239 0016 0320     		movs	r0, #3
 4240              	.LVL435:
 4241              	.L749:
2208:../Sources/drivers/mcg/mcg.c **** }                   //fbi_fee
 4242              		.loc 1 2208 0
 4243 0018 03B0     		add	sp, sp, #12
 4244 001a 30BD     		pop	{r4, r5, pc}
 4245              	.LVL436:
 4246              	.L809:
2061:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 4247              		.loc 1 2061 0
 4248 001c 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 4249 001e 04F01004 		and	r4, r4, #16
 4250 0022 E4B2     		uxtb	r4, r4
 4251 0024 002C     		cmp	r4, #0
 4252 0026 F6D0     		beq	.L766
2062:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 4253              		.loc 1 2062 0
 4254 0028 9C79     		ldrb	r4, [r3, #6]	@ zero_extendqisi2
 4255 002a 04F02004 		and	r4, r4, #32
 4256 002e E4B2     		uxtb	r4, r4
 4257 0030 002C     		cmp	r4, #0
 4258 0032 F0D1     		bne	.L766
2063:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 4259              		.loc 1 2063 0
 4260 0034 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
2060:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)    // check CLKS mux has selct
 4261              		.loc 1 2060 0
 4262 0036 03F00203 		and	r3, r3, #2
 4263 003a DBB2     		uxtb	r3, r3
 4264 003c 002B     		cmp	r3, #0
 4265 003e EAD1     		bne	.L766
2072:../Sources/drivers/mcg/mcg.c ****     if(crystal_val > 50000000)
 4266              		.loc 1 2072 0
 4267 0040 4FF28003 		movw	r3, #61568
 4268 0044 C0F2FA23 		movt	r3, 762
 4269 0048 9842     		cmp	r0, r3
 4270 004a 01DD     		ble	.L810
2074:../Sources/drivers/mcg/mcg.c ****         return 0x21;
 4271              		.loc 1 2074 0
 4272 004c 2120     		movs	r0, #33
 4273              	.LVL437:
 4274 004e E3E7     		b	.L749
 4275              	.LVL438:
 4276              	.L810:
2079:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 4277              		.loc 1 2079 0
 4278 0050 A2B1     		cbz	r2, .L750
2081:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
 4279              		.loc 1 2081 0
 4280 0052 47F22F53 		movw	r3, #29999
 4281 0056 9842     		cmp	r0, r3
 4282 0058 01DC     		bgt	.L811
 4283              	.L770:
2083:../Sources/drivers/mcg/mcg.c ****             return 0x22;    // return error if one of the available crystal options is not availabl
 4284              		.loc 1 2083 0
 4285 005a 2220     		movs	r0, #34
 4286              	.LVL439:
 4287 005c DCE7     		b	.L749
 4288              	.LVL440:
 4289              	.L811:
2081:../Sources/drivers/mcg/mcg.c ****         if((crystal_val < 30000) || ((crystal_val > 40000) && (crystal_val < 3000000)) || (crystal_
 4290              		.loc 1 2081 0
 4291 005e A0F51C43 		sub	r3, r0, #39936
 4292 0062 42F67E24 		movw	r4, #10878
 4293 0066 413B     		subs	r3, r3, #65
 4294 0068 C0F22D04 		movt	r4, 45
 4295 006c A342     		cmp	r3, r4
 4296 006e F4D9     		bls	.L770
 4297 0070 4FF49043 		mov	r3, #18432
 4298 0074 C0F2E813 		movt	r3, 488
 4299 0078 9842     		cmp	r0, r3
 4300 007a EEDC     		bgt	.L770
 4301              	.L750:
2098:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 4302              		.loc 1 2098 0
 4303 007c 4FF48043 		mov	r3, #16384
 4304 0080 C4F20603 		movt	r3, 16390
2091:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 4305              		.loc 1 2091 0
 4306 0084 0031     		adds	r1, r1, #0
 4307              	.LVL441:
2098:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C2;
 4308              		.loc 1 2098 0
 4309 0086 5D78     		ldrb	r5, [r3, #1]	@ zero_extendqisi2
2099:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK);  // clear fields bef
 4310              		.loc 1 2099 0
 4311 0088 05F0C304 		and	r4, r5, #195
2100:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 4312              		.loc 1 2100 0
 4313 008c 49F64045 		movw	r5, #40000
2091:../Sources/drivers/mcg/mcg.c ****         hgo_val = 1;        // force hgo_val to 1 if > 0
 4314              		.loc 1 2091 0
 4315 0090 18BF     		it	ne
 4316 0092 0121     		movne	r1, #1
 4317              	.LVL442:
2100:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 40000)
 4318              		.loc 1 2100 0
 4319 0094 A842     		cmp	r0, r5
 4320 0096 71DC     		bgt	.L751
2102:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 4321              		.loc 1 2102 0
 4322 0098 44EA8205 		orr	r5, r4, r2, lsl #2
 4323 009c ECB2     		uxtb	r4, r5
 4324              	.LVL443:
 4325 009e 44EAC101 		orr	r1, r4, r1, lsl #3
 4326              	.LVL444:
2113:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 4327              		.loc 1 2113 0
 4328 00a2 5970     		strb	r1, [r3, #1]
 4329 00a4 0024     		movs	r4, #0
 4330 00a6 0123     		movs	r3, #1
 4331 00a8 2021     		movs	r1, #32
 4332              	.LVL445:
 4333              	.L752:
2145:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 4334              		.loc 1 2145 0
 4335 00aa 4FF48045 		mov	r5, #16384
 4336 00ae C4F20605 		movt	r5, 16390
 4337 00b2 6D78     		ldrb	r5, [r5, #1]	@ zero_extendqisi2
2156:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
 4338              		.loc 1 2156 0
 4339 00b4 0192     		str	r2, [sp, #4]
2145:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 4340              		.loc 1 2145 0
 4341 00b6 15F0300F 		tst	r5, #48
2147:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
 4342              		.loc 1 2147 0
 4343 00ba 14BF     		ite	ne
 4344 00bc 90FBF1F0 		sdivne	r0, r0, r1
 4345              	.LVL446:
2151:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 4346              		.loc 1 2151 0
 4347 00c0 90FBF3F0 		sdiveq	r0, r0, r3
 4348              	.LVL447:
2156:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
 4349              		.loc 1 2156 0
 4350 00c4 FFF7FEFF 		bl	fll_freq
 4351              	.LVL448:
2157:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 4352              		.loc 1 2157 0
 4353 00c8 3B28     		cmp	r0, #59
 4354 00ca 019A     		ldr	r2, [sp, #4]
 4355 00cc A4DD     		ble	.L749
2166:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 4356              		.loc 1 2166 0
 4357 00ce 4FF48041 		mov	r1, #16384
 4358 00d2 C4F20601 		movt	r1, 16390
 4359 00d6 0B78     		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 4360              	.LVL449:
2167:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);    // Clear CLKS, FRDI
 4361              		.loc 1 2167 0
 4362 00d8 03F00303 		and	r3, r3, #3
 4363              	.LVL450:
2168:../Sources/drivers/mcg/mcg.c ****     temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val));                     // Set the required
 4364              		.loc 1 2168 0
 4365 00dc 1C43     		orrs	r4, r4, r3
 4366              	.LVL451:
2169:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;
 4367              		.loc 1 2169 0
 4368 00de 0C70     		strb	r4, [r1, #0]
2173:../Sources/drivers/mcg/mcg.c ****     if(erefs_val)
 4369              		.loc 1 2173 0
 4370 00e0 F2B1     		cbz	r2, .L757
 4371 00e2 42F21073 		movw	r3, #10000
2177:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
 4372              		.loc 1 2177 0
 4373 00e6 0A46     		mov	r2, r1
 4374 00e8 08E0     		b	.L759
 4375              	.LVL452:
 4376              	.L812:
 4377 00ea 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 4378 00ec 9BB2     		uxth	r3, r3
 4379 00ee 01F00201 		and	r1, r1, #2
 4380 00f2 013B     		subs	r3, r3, #1
 4381 00f4 C9B2     		uxtb	r1, r1
 4382 00f6 9BB2     		uxth	r3, r3
 4383 00f8 39B9     		cbnz	r1, .L758
2175:../Sources/drivers/mcg/mcg.c ****         for(i = 0; i < 10000; i++)
 4384              		.loc 1 2175 0
 4385 00fa 33B1     		cbz	r3, .L758
 4386              	.L759:
2177:../Sources/drivers/mcg/mcg.c ****             if(MCG_S & MCG_S_OSCINIT0_MASK) break;                          // jump out early if OS
 4387              		.loc 1 2177 0
 4388 00fc 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 4389 00fe 01F00201 		and	r1, r1, #2
 4390 0102 C9B2     		uxtb	r1, r1
 4391 0104 013B     		subs	r3, r3, #1
 4392 0106 0029     		cmp	r1, #0
 4393 0108 EFD0     		beq	.L812
 4394              	.L758:
2180:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23;                     // check bit is really 
 4395              		.loc 1 2180 0
 4396 010a 4FF48042 		mov	r2, #16384
 4397 010e C4F20602 		movt	r2, 16390
 4398 0112 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 4399 0114 01F00203 		and	r3, r1, #2
 4400 0118 DAB2     		uxtb	r2, r3
 4401 011a 0AB9     		cbnz	r2, .L757
 4402 011c 2320     		movs	r0, #35
 4403              	.LVL453:
 4404 011e 7BE7     		b	.L749
 4405              	.LVL454:
 4406              	.L757:
2187:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
 4407              		.loc 1 2187 0
 4408 0120 4FF48042 		mov	r2, #16384
 4409 0124 C4F20602 		movt	r2, 16390
 4410 0128 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 4411 012a 01F01003 		and	r3, r1, #16
 4412 012e D9B2     		uxtb	r1, r3
 4413 0130 C1B1     		cbz	r1, .L760
 4414 0132 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 4415 0134 03F01001 		and	r1, r3, #16
 4416 0138 C9B2     		uxtb	r1, r1
 4417 013a 40F2CF73 		movw	r3, #1999
 4418 013e 89B1     		cbz	r1, .L760
 4419 0140 013B     		subs	r3, r3, #1
 4420 0142 08E0     		b	.L786
 4421              	.L813:
 4422 0144 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 4423 0146 9BB2     		uxth	r3, r3
 4424 0148 01F01001 		and	r1, r1, #16
 4425 014c 013B     		subs	r3, r3, #1
 4426 014e C9B2     		uxtb	r1, r1
 4427 0150 9BB2     		uxth	r3, r3
 4428 0152 39B1     		cbz	r1, .L760
2185:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4429              		.loc 1 2185 0
 4430 0154 33B1     		cbz	r3, .L760
 4431              	.L786:
2187:../Sources/drivers/mcg/mcg.c ****         if(!(MCG_S & MCG_S_IREFST_MASK)) break;                             // jump out early if IR
 4432              		.loc 1 2187 0
 4433 0156 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 4434 0158 01F01001 		and	r1, r1, #16
 4435 015c C9B2     		uxtb	r1, r1
 4436 015e 013B     		subs	r3, r3, #1
 4437 0160 0029     		cmp	r1, #0
 4438 0162 EFD1     		bne	.L813
 4439              	.L760:
2190:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 4440              		.loc 1 2190 0
 4441 0164 4FF48043 		mov	r3, #16384
 4442 0168 C4F20603 		movt	r3, 16390
 4443 016c 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 4444 016e 02F01001 		and	r1, r2, #16
 4445 0172 CAB2     		uxtb	r2, r1
 4446 0174 002A     		cmp	r2, #0
 4447 0176 45D0     		beq	.L814
 4448 0178 1120     		movs	r0, #17
 4449              	.LVL455:
 4450 017a 4DE7     		b	.L749
 4451              	.LVL456:
 4452              	.L751:
2104:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 8000000)
 4453              		.loc 1 2104 0
 4454 017c 4FF49055 		mov	r5, #4608
 4455 0180 C0F27A05 		movt	r5, 122
 4456 0184 A842     		cmp	r0, r5
 4457 0186 34DC     		bgt	.L753
2106:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 4458              		.loc 1 2106 0
 4459 0188 44F01005 		orr	r5, r4, #16
 4460 018c 45EA8204 		orr	r4, r5, r2, lsl #2
 4461              	.LVL457:
 4462 0190 E5B2     		uxtb	r5, r4
2118:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 4463              		.loc 1 2118 0
 4464 0192 41F2D024 		movw	r4, #4816
 4465 0196 C0F21304 		movt	r4, 19
2106:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 4466              		.loc 1 2106 0
 4467 019a 45EAC101 		orr	r1, r5, r1, lsl #3
 4468              	.LVL458:
2118:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 4469              		.loc 1 2118 0
 4470 019e A042     		cmp	r0, r4
2113:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 4471              		.loc 1 2113 0
 4472 01a0 5970     		strb	r1, [r3, #1]
2118:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 4473              		.loc 1 2118 0
 4474 01a2 52DD     		ble	.L815
 4475              	.LVL459:
 4476              	.L754:
2122:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 4477              		.loc 1 2122 0
 4478 01a4 42F2A053 		movw	r3, #9632
 4479 01a8 C0F22603 		movt	r3, 38
 4480 01ac 9842     		cmp	r0, r3
 4481 01ae 1CDD     		ble	.L772
2126:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 4482              		.loc 1 2126 0
 4483 01b0 44F64035 		movw	r5, #19264
 4484 01b4 C0F24C05 		movt	r5, 76
 4485 01b8 A842     		cmp	r0, r5
 4486 01ba 42DD     		ble	.L773
2130:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 4487              		.loc 1 2130 0
 4488 01bc 49F28064 		movw	r4, #38528
 4489 01c0 C0F29804 		movt	r4, 152
 4490 01c4 A042     		cmp	r0, r4
 4491 01c6 37DD     		ble	.L774
2134:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 20000000)
 4492              		.loc 1 2134 0
 4493 01c8 4FF43451 		mov	r1, #11520
 4494 01cc C0F23111 		movt	r1, 305
 4495 01d0 8842     		cmp	r0, r1
 4496 01d2 CCBF     		ite	gt
 4497 01d4 2824     		movgt	r4, #40
 4498 01d6 2024     		movle	r4, #32
 4499 01d8 CCBF     		ite	gt
 4500 01da 2023     		movgt	r3, #32
 4501 01dc 1023     		movle	r3, #16
 4502 01de CCBF     		ite	gt
 4503 01e0 4FF48061 		movgt	r1, #1024
 4504 01e4 4FF40071 		movle	r1, #512
 4505 01e8 5FE7     		b	.L752
 4506              	.L772:
2122:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 2500000)
 4507              		.loc 1 2122 0
 4508 01ea 0824     		movs	r4, #8
 4509 01ec 0223     		movs	r3, #2
 4510 01ee 4021     		movs	r1, #64
 4511 01f0 5BE7     		b	.L752
 4512              	.LVL460:
 4513              	.L753:
2110:../Sources/drivers/mcg/mcg.c ****         temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS
 4514              		.loc 1 2110 0
 4515 01f2 44F02004 		orr	r4, r4, #32
 4516              	.LVL461:
 4517 01f6 44EA8205 		orr	r5, r4, r2, lsl #2
 4518 01fa ECB2     		uxtb	r4, r5
 4519 01fc 44EAC101 		orr	r1, r4, r1, lsl #3
 4520              	.LVL462:
2113:../Sources/drivers/mcg/mcg.c ****     MCG_C2 = temp_reg;
 4521              		.loc 1 2113 0
 4522 0200 5970     		strb	r1, [r3, #1]
 4523 0202 CFE7     		b	.L754
 4524              	.LVL463:
 4525              	.L814:
2190:../Sources/drivers/mcg/mcg.c ****     if(MCG_S & MCG_S_IREFST_MASK) return 0x11;                              // check bit is really 
 4526              		.loc 1 2190 0
 4527 0204 4FF4FA62 		mov	r2, #2000
 4528 0208 06E0     		b	.L762
 4529              	.L816:
2196:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CL
 4530              		.loc 1 2196 0
 4531 020a 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4532 020c 11F00C0F 		tst	r1, #12
 4533 0210 08D0     		beq	.L761
 4534 0212 013A     		subs	r2, r2, #1
 4535 0214 92B2     		uxth	r2, r2
2194:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4536              		.loc 1 2194 0
 4537 0216 2AB1     		cbz	r2, .L761
 4538              	.L762:
2196:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CL
 4539              		.loc 1 2196 0
 4540 0218 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4541 021a 013A     		subs	r2, r2, #1
 4542 021c 11F00C0F 		tst	r1, #12
 4543 0220 92B2     		uxth	r2, r2
 4544 0222 F2D1     		bne	.L816
 4545              	.L761:
2199:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check FLLK is re
 4546              		.loc 1 2199 0
 4547 0224 4FF48043 		mov	r3, #16384
 4548 0228 C4F20603 		movt	r3, 16390
 4549 022c 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4550 022e 11F00C0F 		tst	r1, #12
 4551 0232 0ED0     		beq	.L817
 4552 0234 1820     		movs	r0, #24
 4553              	.LVL464:
 4554 0236 EFE6     		b	.L749
 4555              	.LVL465:
 4556              	.L774:
2130:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 10000000)
 4557              		.loc 1 2130 0
 4558 0238 1824     		movs	r4, #24
 4559 023a 0823     		movs	r3, #8
 4560 023c 4FF48071 		mov	r1, #256
 4561 0240 33E7     		b	.L752
 4562              	.L773:
2126:../Sources/drivers/mcg/mcg.c ****     else if(crystal_val <= 5000000)
 4563              		.loc 1 2126 0
 4564 0242 1024     		movs	r4, #16
 4565 0244 0423     		movs	r3, #4
 4566 0246 8021     		movs	r1, #128
 4567 0248 2FE7     		b	.L752
 4568              	.LVL466:
 4569              	.L815:
2118:../Sources/drivers/mcg/mcg.c ****     if(crystal_val <= 1250000)
 4570              		.loc 1 2118 0
 4571 024a 0024     		movs	r4, #0
 4572 024c 0123     		movs	r3, #1
 4573 024e 2021     		movs	r1, #32
 4574              	.LVL467:
 4575 0250 2BE7     		b	.L752
 4576              	.LVL468:
 4577              	.L817:
2206:../Sources/drivers/mcg/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;
 4578              		.loc 1 2206 0
 4579 0252 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 4580 0254 42F02001 		orr	r1, r2, #32
 4581 0258 5971     		strb	r1, [r3, #5]
2207:../Sources/drivers/mcg/mcg.c ****     return mcg_out; // MCGOUT frequency equals FLL frequency
 4582              		.loc 1 2207 0
 4583 025a DDE6     		b	.L749
 4584              		.cfi_endproc
 4585              	.LFE18:
 4587              		.section	.text.fbe_fee,"ax",%progbits
 4588              		.align	2
 4589              		.global	fbe_fee
 4590              		.thumb
 4591              		.thumb_func
 4593              	fbe_fee:
 4594              	.LFB12:
1405:../Sources/drivers/mcg/mcg.c **** {
 4595              		.loc 1 1405 0
 4596              		.cfi_startproc
 4597              		@ args = 0, pretend = 0, frame = 0
 4598              		@ frame_needed = 0, uses_anonymous_args = 0
 4599              	.LVL469:
 4600 0000 08B5     		push	{r3, lr}
 4601              	.LCFI18:
 4602              		.cfi_def_cfa_offset 8
 4603              		.cfi_offset 3, -8
 4604              		.cfi_offset 14, -4
1437:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 4605              		.loc 1 1437 0
 4606 0002 4FF48043 		mov	r3, #16384
 4607 0006 C4F20603 		movt	r3, 16390
 4608 000a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 4609 000c C2F38101 		ubfx	r1, r2, #2, #2
1436:../Sources/drivers/mcg/mcg.c ****     (
 4610              		.loc 1 1436 0
 4611 0010 0229     		cmp	r1, #2
 4612 0012 01D0     		beq	.L837
 4613              	.L827:
1444:../Sources/drivers/mcg/mcg.c ****         return 0x4; // return error code
 4614              		.loc 1 1444 0
 4615 0014 0420     		movs	r0, #4
 4616              	.LVL470:
 4617              	.L819:
1482:../Sources/drivers/mcg/mcg.c **** }   // fbe_fee
 4618              		.loc 1 1482 0
 4619 0016 08BD     		pop	{r3, pc}
 4620              	.LVL471:
 4621              	.L837:
1438:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 4622              		.loc 1 1438 0
 4623 0018 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 4624 001a 02F01001 		and	r1, r2, #16
 4625 001e CAB2     		uxtb	r2, r1
 4626 0020 002A     		cmp	r2, #0
 4627 0022 F7D1     		bne	.L827
1439:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 4628              		.loc 1 1439 0
 4629 0024 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4630 0026 01F02002 		and	r2, r1, #32
 4631 002a D1B2     		uxtb	r1, r2
 4632 002c 0029     		cmp	r1, #0
 4633 002e F1D1     		bne	.L827
1440:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 4634              		.loc 1 1440 0
 4635 0030 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
1437:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 4636              		.loc 1 1437 0
 4637 0032 02F00201 		and	r1, r2, #2
 4638 0036 CAB2     		uxtb	r2, r1
 4639 0038 002A     		cmp	r2, #0
 4640 003a EBD1     		bne	.L827
1449:../Sources/drivers/mcg/mcg.c ****     if(((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 4641              		.loc 1 1449 0
 4642 003c 5978     		ldrb	r1, [r3, #1]	@ zero_extendqisi2
 4643 003e 11F0300F 		tst	r1, #48
 4644 0042 2FD0     		beq	.L820
1451:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)))
 4645              		.loc 1 1451 0
 4646 0044 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 4647 0046 2021     		movs	r1, #32
 4648 0048 C2F3C203 		ubfx	r3, r2, #3, #3
 4649 004c 01FA03F2 		lsl	r2, r1, r3
 4650 0050 90FBF2F0 		sdiv	r0, r0, r2
 4651              	.LVL472:
 4652 0054 81B2     		uxth	r1, r0
 4653              	.LVL473:
 4654              	.L821:
1460:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(fll_ref_freq);   // FLL reference frequency calculated from ext ref freq and
 4655              		.loc 1 1460 0
 4656 0056 08B2     		sxth	r0, r1
 4657 0058 FFF7FEFF 		bl	fll_freq
 4658              	.LVL474:
1461:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 4659              		.loc 1 1461 0
 4660 005c 3B28     		cmp	r0, #59
 4661 005e DADD     		ble	.L819
1468:../Sources/drivers/mcg/mcg.c ****     MCG_C1 &= ~MCG_C1_CLKS_MASK;        // clear CLKS to select FLL output
 4662              		.loc 1 1468 0
 4663 0060 4FF48042 		mov	r2, #16384
 4664 0064 C4F20602 		movt	r2, 16390
 4665 0068 4FF4FA63 		mov	r3, #2000
 4666 006c 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 4667 006e 01F03F01 		and	r1, r1, #63
 4668 0072 1170     		strb	r1, [r2, #0]
 4669              	.LVL475:
 4670 0074 06E0     		b	.L823
 4671              	.LVL476:
 4672              	.L838:
1474:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out early i
 4673              		.loc 1 1474 0
 4674 0076 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 4675 0078 11F00C0F 		tst	r1, #12
 4676 007c 08D0     		beq	.L822
 4677 007e 013B     		subs	r3, r3, #1
 4678 0080 9BB2     		uxth	r3, r3
1472:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4679              		.loc 1 1472 0
 4680 0082 2BB1     		cbz	r3, .L822
 4681              	.L823:
1474:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out early i
 4682              		.loc 1 1474 0
 4683 0084 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 4684 0086 013B     		subs	r3, r3, #1
 4685 0088 11F00C0F 		tst	r1, #12
 4686 008c 9BB2     		uxth	r3, r3
 4687 008e F2D1     		bne	.L838
 4688              	.L822:
1477:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check FLL is rea
 4689              		.loc 1 1477 0
 4690 0090 4FF48042 		mov	r2, #16384
 4691 0094 C4F20602 		movt	r2, 16390
 4692 0098 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 4693 009a 11F00C0F 		tst	r1, #12
 4694 009e 18BF     		it	ne
 4695 00a0 1820     		movne	r0, #24
 4696              	.LVL477:
 4697 00a2 08BD     		pop	{r3, pc}
 4698              	.LVL478:
 4699              	.L820:
1455:../Sources/drivers/mcg/mcg.c ****         fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIF
 4700              		.loc 1 1455 0
 4701 00a4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4702 00a6 0122     		movs	r2, #1
 4703 00a8 C3F30111 		ubfx	r1, r3, #4, #2
 4704 00ac 02FA01F3 		lsl	r3, r2, r1
 4705 00b0 90FBF3F0 		sdiv	r0, r0, r3
 4706              	.LVL479:
 4707 00b4 81B2     		uxth	r1, r0
 4708              	.LVL480:
 4709 00b6 CEE7     		b	.L821
 4710              		.cfi_endproc
 4711              	.LFE12:
 4713              		.section	.text.fbe_fei,"ax",%progbits
 4714              		.align	2
 4715              		.global	fbe_fei
 4716              		.thumb
 4717              		.thumb_func
 4719              	fbe_fei:
 4720              	.LFB10:
1120:../Sources/drivers/mcg/mcg.c **** {
 4721              		.loc 1 1120 0
 4722              		.cfi_startproc
 4723              		@ args = 0, pretend = 0, frame = 0
 4724              		@ frame_needed = 0, uses_anonymous_args = 0
 4725              	.LVL481:
 4726 0000 10B5     		push	{r4, lr}
 4727              	.LCFI19:
 4728              		.cfi_def_cfa_offset 8
 4729              		.cfi_offset 4, -8
 4730              		.cfi_offset 14, -4
1153:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 4731              		.loc 1 1153 0
 4732 0002 4FF48044 		mov	r4, #16384
 4733 0006 C4F20604 		movt	r4, 16390
 4734 000a A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4735 000c C3F38101 		ubfx	r1, r3, #2, #2
1152:../Sources/drivers/mcg/mcg.c ****     (
 4736              		.loc 1 1152 0
 4737 0010 0229     		cmp	r1, #2
 4738 0012 01D0     		beq	.L863
 4739              	.L848:
1160:../Sources/drivers/mcg/mcg.c ****         return 0x4;     // return error code
 4740              		.loc 1 1160 0
 4741 0014 0420     		movs	r0, #4
 4742              	.LVL482:
 4743 0016 10BD     		pop	{r4, pc}
 4744              	.LVL483:
 4745              	.L863:
1154:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 4746              		.loc 1 1154 0
 4747 0018 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4748 001a 03F01001 		and	r1, r3, #16
 4749 001e CBB2     		uxtb	r3, r1
 4750 0020 002B     		cmp	r3, #0
 4751 0022 F7D1     		bne	.L848
1155:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 4752              		.loc 1 1155 0
 4753 0024 A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 4754 0026 01F02003 		and	r3, r1, #32
 4755 002a D9B2     		uxtb	r1, r3
 4756 002c 0029     		cmp	r1, #0
 4757 002e F1D1     		bne	.L848
1156:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 4758              		.loc 1 1156 0
 4759 0030 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
1153:../Sources/drivers/mcg/mcg.c ****         !((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)    // check CLKS mux has selct
 4760              		.loc 1 1153 0
 4761 0032 03F00201 		and	r1, r3, #2
 4762 0036 CBB2     		uxtb	r3, r1
 4763 0038 002B     		cmp	r3, #0
 4764 003a EBD1     		bne	.L848
1165:../Sources/drivers/mcg/mcg.c ****     if((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4765              		.loc 1 1165 0
 4766 003c A0F5F442 		sub	r2, r0, #31232
 4767 0040 123A     		subs	r2, r2, #18
 4768 0042 41F68561 		movw	r1, #7813
 4769 0046 8A42     		cmp	r2, r1
 4770 0048 01D9     		bls	.L864
1167:../Sources/drivers/mcg/mcg.c ****         return 0x31;
 4771              		.loc 1 1167 0
 4772 004a 3120     		movs	r0, #49
 4773              	.LVL484:
 4774 004c 10BD     		pop	{r4, pc}
 4775              	.LVL485:
 4776              	.L864:
1172:../Sources/drivers/mcg/mcg.c ****     mcg_out = fll_freq(slow_irc_freq);
 4777              		.loc 1 1172 0
 4778 004e FFF7FEFF 		bl	fll_freq
 4779              	.LVL486:
1174:../Sources/drivers/mcg/mcg.c ****     if(mcg_out < 0x3C)
 4780              		.loc 1 1174 0
 4781 0052 3B28     		cmp	r0, #59
 4782 0054 26DD     		ble	.L840
1181:../Sources/drivers/mcg/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;                    //This assumes OSC0 is used as the external clo
 4783              		.loc 1 1181 0
 4784 0056 6379     		ldrb	r3, [r4, #5]	@ zero_extendqisi2
 4785 0058 03F0DF02 		and	r2, r3, #223
 4786 005c 6271     		strb	r2, [r4, #5]
1185:../Sources/drivers/mcg/mcg.c ****     temp_reg = MCG_C1;
 4787              		.loc 1 1185 0
 4788 005e 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 4789              	.LVL487:
1186:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~MCG_C1_CLKS_MASK;                  // clear CLKS to select FLL output
 4790              		.loc 1 1186 0
 4791 0060 01F03F03 		and	r3, r1, #63
 4792              	.LVL488:
1187:../Sources/drivers/mcg/mcg.c ****     temp_reg |= MCG_C1_IREFS_MASK;                  // select internal reference clock
 4793              		.loc 1 1187 0
 4794 0064 43F00402 		orr	r2, r3, #4
 4795              	.LVL489:
1188:../Sources/drivers/mcg/mcg.c ****     MCG_C1 = temp_reg;                              // update MCG_C1
 4796              		.loc 1 1188 0
 4797 0068 2270     		strb	r2, [r4, #0]
 4798              	.LVL490:
 4799 006a 4FF4FA63 		mov	r3, #2000
 4800 006e 08E0     		b	.L842
 4801              	.LVL491:
 4802              	.L865:
1194:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
 4803              		.loc 1 1194 0
 4804 0070 A279     		ldrb	r2, [r4, #6]	@ zero_extendqisi2
 4805 0072 9BB2     		uxth	r3, r3
 4806 0074 02F01001 		and	r1, r2, #16
 4807 0078 CAB2     		uxtb	r2, r1
 4808 007a 591E     		subs	r1, r3, #1
 4809 007c 8BB2     		uxth	r3, r1
 4810 007e 3AB9     		cbnz	r2, .L841
1192:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4811              		.loc 1 1192 0
 4812 0080 33B1     		cbz	r3, .L841
 4813              	.L842:
1194:../Sources/drivers/mcg/mcg.c ****         if(MCG_S & MCG_S_IREFST_MASK) break;        // jump out early if IREFST sets before loop fi
 4814              		.loc 1 1194 0
 4815 0082 A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 4816 0084 01F01002 		and	r2, r1, #16
 4817 0088 D1B2     		uxtb	r1, r2
 4818 008a 013B     		subs	r3, r3, #1
 4819 008c 0029     		cmp	r1, #0
 4820 008e EFD0     		beq	.L865
 4821              	.L841:
1197:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 4822              		.loc 1 1197 0
 4823 0090 4FF48043 		mov	r3, #16384
 4824 0094 C4F20603 		movt	r3, 16390
 4825 0098 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 4826 009a 02F01001 		and	r1, r2, #16
 4827 009e CAB2     		uxtb	r2, r1
 4828 00a0 0AB9     		cbnz	r2, .L866
 4829 00a2 1220     		movs	r0, #18
 4830              	.LVL492:
 4831              	.L840:
1211:../Sources/drivers/mcg/mcg.c **** }   // fbe_fei
 4832              		.loc 1 1211 0
 4833 00a4 10BD     		pop	{r4, pc}
 4834              	.LVL493:
 4835              	.L866:
1197:../Sources/drivers/mcg/mcg.c ****     if(!(MCG_S & MCG_S_IREFST_MASK)) return 0x12;   // check bit is really set and return with erro
 4836              		.loc 1 1197 0
 4837 00a6 4FF4FA62 		mov	r2, #2000
 4838 00aa 06E0     		b	.L844
 4839              	.L867:
1203:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out early i
 4840              		.loc 1 1203 0
 4841 00ac 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4842 00ae 11F00C0F 		tst	r1, #12
 4843 00b2 08D0     		beq	.L843
 4844 00b4 013A     		subs	r2, r2, #1
 4845 00b6 92B2     		uxth	r2, r2
1201:../Sources/drivers/mcg/mcg.c ****     for(i = 0; i < 2000; i++)
 4846              		.loc 1 1201 0
 4847 00b8 2AB1     		cbz	r2, .L843
 4848              	.L844:
1203:../Sources/drivers/mcg/mcg.c ****         if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break;     // jump out early i
 4849              		.loc 1 1203 0
 4850 00ba 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4851 00bc 013A     		subs	r2, r2, #1
 4852 00be 11F00C0F 		tst	r1, #12
 4853 00c2 92B2     		uxth	r2, r2
 4854 00c4 F2D1     		bne	.L867
 4855              	.L843:
1206:../Sources/drivers/mcg/mcg.c ****     if(((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18;   // check EXT CLK is
 4856              		.loc 1 1206 0
 4857 00c6 4FF48043 		mov	r3, #16384
 4858 00ca C4F20603 		movt	r3, 16390
 4859 00ce 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4860 00d0 11F00C0F 		tst	r1, #12
 4861 00d4 18BF     		it	ne
 4862 00d6 1820     		movne	r0, #24
 4863              	.LVL494:
 4864 00d8 10BD     		pop	{r4, pc}
 4865              		.cfi_endproc
 4866              	.LFE10:
 4868 00da 00BF     		.section	.text.what_mcg_mode,"ax",%progbits
 4869              		.align	2
 4870              		.global	what_mcg_mode
 4871              		.thumb
 4872              		.thumb_func
 4874              	what_mcg_mode:
 4875              	.LFB26:
3157:../Sources/drivers/mcg/mcg.c **** 
3158:../Sources/drivers/mcg/mcg.c **** /* */
3159:../Sources/drivers/mcg/mcg.c **** 
3160:../Sources/drivers/mcg/mcg.c **** unsigned char what_mcg_mode(void)
3161:../Sources/drivers/mcg/mcg.c **** {
 4876              		.loc 1 3161 0
 4877              		.cfi_startproc
 4878              		@ args = 0, pretend = 0, frame = 0
 4879              		@ frame_needed = 0, uses_anonymous_args = 0
 4880              		@ link register save eliminated.
3162:../Sources/drivers/mcg/mcg.c ****     // check if in FEI mode
3163:../Sources/drivers/mcg/mcg.c **** 
3164:../Sources/drivers/mcg/mcg.c ****     if
3165:../Sources/drivers/mcg/mcg.c ****     (
3166:../Sources/drivers/mcg/mcg.c ****         (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)  // check CLKS mux has selcted F
 4881              		.loc 1 3166 0
 4882 0000 4FF48043 		mov	r3, #16384
 4883 0004 C4F20603 		movt	r3, 16390
 4884 0008 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
3165:../Sources/drivers/mcg/mcg.c ****     (
 4885              		.loc 1 3165 0
 4886 000a 12F00C0F 		tst	r2, #12
 4887 000e 05D1     		bne	.L869
3167:../Sources/drivers/mcg/mcg.c ****     &&  (MCG_S & MCG_S_IREFST_MASK) // check FLL ref is internal ref clk
 4888              		.loc 1 3167 0
 4889 0010 9879     		ldrb	r0, [r3, #6]	@ zero_extendqisi2
 4890 0012 00F01001 		and	r1, r0, #16
 4891 0016 CAB2     		uxtb	r2, r1
 4892 0018 002A     		cmp	r2, #0
 4893 001a 4ED1     		bne	.L899
 4894              	.L869:
3168:../Sources/drivers/mcg/mcg.c ****     &&  (!(MCG_S & MCG_S_PLLST_MASK))
3169:../Sources/drivers/mcg/mcg.c ****     )               // check PLLS mux has selected FLL
3170:../Sources/drivers/mcg/mcg.c ****     {
3171:../Sources/drivers/mcg/mcg.c ****         return FEI; // return FEI code
3172:../Sources/drivers/mcg/mcg.c ****     }
3173:../Sources/drivers/mcg/mcg.c **** 
3174:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PEE mode
3175:../Sources/drivers/mcg/mcg.c **** 
3176:../Sources/drivers/mcg/mcg.c ****     else if
3177:../Sources/drivers/mcg/mcg.c ****         (
3178:../Sources/drivers/mcg/mcg.c ****             (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3)  // check CLKS mux has selct
 4895              		.loc 1 3178 0
 4896 001c 4FF48043 		mov	r3, #16384
 4897 0020 C4F20603 		movt	r3, 16390
 4898 0024 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 4899 0026 C2F38100 		ubfx	r0, r2, #2, #2
3177:../Sources/drivers/mcg/mcg.c ****         (
 4900              		.loc 1 3177 0
 4901 002a 0328     		cmp	r0, #3
 4902 002c 4DD0     		beq	.L900
 4903              	.L871:
3179:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
3180:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)
3181:../Sources/drivers/mcg/mcg.c ****         )           // check PLLS mux has selected PLL
3182:../Sources/drivers/mcg/mcg.c ****     {
3183:../Sources/drivers/mcg/mcg.c ****         return PEE; // return PEE code
3184:../Sources/drivers/mcg/mcg.c ****     }
3185:../Sources/drivers/mcg/mcg.c **** 
3186:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in PBE mode
3187:../Sources/drivers/mcg/mcg.c **** 
3188:../Sources/drivers/mcg/mcg.c ****     else if
3189:../Sources/drivers/mcg/mcg.c ****         (
3190:../Sources/drivers/mcg/mcg.c ****             (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)  // check CLKS mux has selct
 4904              		.loc 1 3190 0
 4905 002e 4FF48040 		mov	r0, #16384
 4906 0032 C4F20600 		movt	r0, 16390
 4907 0036 8379     		ldrb	r3, [r0, #6]	@ zero_extendqisi2
 4908 0038 C3F38101 		ubfx	r1, r3, #2, #2
3189:../Sources/drivers/mcg/mcg.c ****         (
 4909              		.loc 1 3189 0
 4910 003c 0229     		cmp	r1, #2
 4911 003e 52D0     		beq	.L901
 4912              	.L872:
3191:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
3192:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
3193:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
3194:../Sources/drivers/mcg/mcg.c ****         )           // check MCG_C2[LP] bit is not set
3195:../Sources/drivers/mcg/mcg.c ****     {
3196:../Sources/drivers/mcg/mcg.c ****         return PBE; // return PBE code
3197:../Sources/drivers/mcg/mcg.c ****     }
3198:../Sources/drivers/mcg/mcg.c **** 
3199:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FBE mode
3200:../Sources/drivers/mcg/mcg.c **** 
3201:../Sources/drivers/mcg/mcg.c ****     else if
3202:../Sources/drivers/mcg/mcg.c ****         (
3203:../Sources/drivers/mcg/mcg.c ****             (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)  // check CLKS mux has selct
 4913              		.loc 1 3203 0
 4914 0040 4FF48041 		mov	r1, #16384
 4915 0044 C4F20601 		movt	r1, 16390
 4916 0048 8879     		ldrb	r0, [r1, #6]	@ zero_extendqisi2
 4917 004a C0F38102 		ubfx	r2, r0, #2, #2
3202:../Sources/drivers/mcg/mcg.c ****         (
 4918              		.loc 1 3202 0
 4919 004e 022A     		cmp	r2, #2
 4920 0050 5DD0     		beq	.L902
 4921              	.L873:
3204:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
3205:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
3206:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
3207:../Sources/drivers/mcg/mcg.c ****         )           // check MCG_C2[LP] bit is not set
3208:../Sources/drivers/mcg/mcg.c ****     {
3209:../Sources/drivers/mcg/mcg.c ****         return FBE; // return FBE code
3210:../Sources/drivers/mcg/mcg.c ****     }
3211:../Sources/drivers/mcg/mcg.c **** 
3212:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in BLPE mode
3213:../Sources/drivers/mcg/mcg.c **** 
3214:../Sources/drivers/mcg/mcg.c ****     else if
3215:../Sources/drivers/mcg/mcg.c ****         (
3216:../Sources/drivers/mcg/mcg.c ****             (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)  // check CLKS mux has selct
 4922              		.loc 1 3216 0
 4923 0052 4FF48041 		mov	r1, #16384
 4924 0056 C4F20601 		movt	r1, 16390
 4925 005a 8A79     		ldrb	r2, [r1, #6]	@ zero_extendqisi2
 4926 005c C2F38103 		ubfx	r3, r2, #2, #2
3215:../Sources/drivers/mcg/mcg.c ****         (
 4927              		.loc 1 3215 0
 4928 0060 022B     		cmp	r3, #2
 4929 0062 68D0     		beq	.L903
 4930              	.L874:
3217:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
3218:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
3219:../Sources/drivers/mcg/mcg.c ****         )               // check MCG_C2[LP] bit is set
3220:../Sources/drivers/mcg/mcg.c ****     {
3221:../Sources/drivers/mcg/mcg.c ****         return BLPE;    // return BLPE code
3222:../Sources/drivers/mcg/mcg.c ****     }
3223:../Sources/drivers/mcg/mcg.c **** 
3224:../Sources/drivers/mcg/mcg.c ****     // check if in BLPI mode
3225:../Sources/drivers/mcg/mcg.c **** 
3226:../Sources/drivers/mcg/mcg.c ****     else if
3227:../Sources/drivers/mcg/mcg.c ****         (
3228:../Sources/drivers/mcg/mcg.c ****             (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)  // check CLKS mux has selct
 4931              		.loc 1 3228 0
 4932 0064 4FF48043 		mov	r3, #16384
 4933 0068 C4F20603 		movt	r3, 16390
 4934 006c 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4935 006e C1F38100 		ubfx	r0, r1, #2, #2
3227:../Sources/drivers/mcg/mcg.c ****         (
 4936              		.loc 1 3227 0
 4937 0072 0128     		cmp	r0, #1
 4938 0074 6DD0     		beq	.L904
 4939              	.L875:
3229:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
3230:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
3231:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
3232:../Sources/drivers/mcg/mcg.c ****         )               // check LP bit is set
3233:../Sources/drivers/mcg/mcg.c ****     {
3234:../Sources/drivers/mcg/mcg.c ****         return BLPI;    // return BLPI code
3235:../Sources/drivers/mcg/mcg.c ****     }
3236:../Sources/drivers/mcg/mcg.c **** 
3237:../Sources/drivers/mcg/mcg.c ****     // check if in FBI mode
3238:../Sources/drivers/mcg/mcg.c **** 
3239:../Sources/drivers/mcg/mcg.c ****     else if
3240:../Sources/drivers/mcg/mcg.c ****         (
3241:../Sources/drivers/mcg/mcg.c ****             (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)  // check CLKS mux has selct
 4940              		.loc 1 3241 0
 4941 0076 4FF48040 		mov	r0, #16384
 4942 007a C4F20600 		movt	r0, 16390
 4943 007e 8379     		ldrb	r3, [r0, #6]	@ zero_extendqisi2
 4944 0080 C3F38102 		ubfx	r2, r3, #2, #2
3240:../Sources/drivers/mcg/mcg.c ****         (
 4945              		.loc 1 3240 0
 4946 0084 012A     		cmp	r2, #1
 4947 0086 78D0     		beq	.L905
 4948              	.L876:
3242:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
3243:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
3244:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
3245:../Sources/drivers/mcg/mcg.c ****         )           // check LP bit is clear
3246:../Sources/drivers/mcg/mcg.c ****     {
3247:../Sources/drivers/mcg/mcg.c ****         return FBI; // return FBI code
3248:../Sources/drivers/mcg/mcg.c ****     }
3249:../Sources/drivers/mcg/mcg.c **** 
3250:../Sources/drivers/mcg/mcg.c ****     // Check MCG is in FEE mode
3251:../Sources/drivers/mcg/mcg.c **** 
3252:../Sources/drivers/mcg/mcg.c ****     else if
3253:../Sources/drivers/mcg/mcg.c ****         (
3254:../Sources/drivers/mcg/mcg.c ****             (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0)  // check CLKS mux has selct
 4949              		.loc 1 3254 0
 4950 0088 4FF48041 		mov	r1, #16384
 4951 008c C4F20601 		movt	r1, 16390
 4952 0090 8A79     		ldrb	r2, [r1, #6]	@ zero_extendqisi2
 4953 0092 C2F38100 		ubfx	r0, r2, #2, #2
3253:../Sources/drivers/mcg/mcg.c ****         (
 4954              		.loc 1 3253 0
 4955 0096 08B1     		cbz	r0, .L906
3255:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
3256:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
3257:../Sources/drivers/mcg/mcg.c ****         )           // check PLLS mux has selected FLL
3258:../Sources/drivers/mcg/mcg.c ****     {
3259:../Sources/drivers/mcg/mcg.c ****         return FEE; // return FEE code
3260:../Sources/drivers/mcg/mcg.c ****     }
3261:../Sources/drivers/mcg/mcg.c ****     else
3262:../Sources/drivers/mcg/mcg.c ****     {
3263:../Sources/drivers/mcg/mcg.c ****         return 0;   // error condition
 4956              		.loc 1 3263 0
 4957 0098 0020     		movs	r0, #0
 4958              	.L870:
3264:../Sources/drivers/mcg/mcg.c ****     }
3265:../Sources/drivers/mcg/mcg.c **** }                   // what_mcg_mode
 4959              		.loc 1 3265 0
 4960 009a 7047     		bx	lr
 4961              	.L906:
3255:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 4962              		.loc 1 3255 0
 4963 009c 8B79     		ldrb	r3, [r1, #6]	@ zero_extendqisi2
 4964 009e 03F01002 		and	r2, r3, #16
 4965 00a2 D3B2     		uxtb	r3, r2
 4966 00a4 002B     		cmp	r3, #0
 4967 00a6 F8D1     		bne	.L870
3256:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))
 4968              		.loc 1 3256 0
 4969 00a8 8879     		ldrb	r0, [r1, #6]	@ zero_extendqisi2
 4970 00aa 00F02001 		and	r1, r0, #32
 4971 00ae CAB2     		uxtb	r2, r1
3259:../Sources/drivers/mcg/mcg.c ****         return FEE; // return FEE code
 4972              		.loc 1 3259 0
 4973 00b0 002A     		cmp	r2, #0
 4974 00b2 0CBF     		ite	eq
 4975 00b4 0420     		moveq	r0, #4
 4976 00b6 0020     		movne	r0, #0
 4977 00b8 7047     		bx	lr
 4978              	.L899:
3168:../Sources/drivers/mcg/mcg.c ****     &&  (!(MCG_S & MCG_S_PLLST_MASK))
 4979              		.loc 1 3168 0
 4980 00ba 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 4981 00bc 03F02000 		and	r0, r3, #32
 4982 00c0 C1B2     		uxtb	r1, r0
 4983 00c2 0029     		cmp	r1, #0
 4984 00c4 AAD1     		bne	.L869
3171:../Sources/drivers/mcg/mcg.c ****         return FEI; // return FEI code
 4985              		.loc 1 3171 0
 4986 00c6 0320     		movs	r0, #3
 4987 00c8 7047     		bx	lr
 4988              	.L900:
3179:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 4989              		.loc 1 3179 0
 4990 00ca 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 4991 00cc 01F01002 		and	r2, r1, #16
 4992 00d0 D0B2     		uxtb	r0, r2
 4993 00d2 0028     		cmp	r0, #0
 4994 00d4 ABD1     		bne	.L871
3180:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)
 4995              		.loc 1 3180 0
 4996 00d6 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 4997 00d8 03F02001 		and	r1, r3, #32
 4998 00dc CAB2     		uxtb	r2, r1
 4999 00de 002A     		cmp	r2, #0
 5000 00e0 A5D0     		beq	.L871
3183:../Sources/drivers/mcg/mcg.c ****         return PEE; // return PEE code
 5001              		.loc 1 3183 0
 5002 00e2 0820     		movs	r0, #8
 5003 00e4 7047     		bx	lr
 5004              	.L901:
3191:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 5005              		.loc 1 3191 0
 5006 00e6 8279     		ldrb	r2, [r0, #6]	@ zero_extendqisi2
 5007 00e8 02F01003 		and	r3, r2, #16
 5008 00ec D9B2     		uxtb	r1, r3
 5009 00ee 0029     		cmp	r1, #0
 5010 00f0 A6D1     		bne	.L872
3192:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_PLLST_MASK)      // check PLLS mux has selected PLL
 5011              		.loc 1 3192 0
 5012 00f2 8279     		ldrb	r2, [r0, #6]	@ zero_extendqisi2
 5013 00f4 02F02003 		and	r3, r2, #32
 5014 00f8 D9B2     		uxtb	r1, r3
 5015 00fa 0029     		cmp	r1, #0
 5016 00fc A0D0     		beq	.L872
3193:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 5017              		.loc 1 3193 0
 5018 00fe 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 5019 0100 00F00202 		and	r2, r0, #2
 5020 0104 D3B2     		uxtb	r3, r2
 5021 0106 002B     		cmp	r3, #0
 5022 0108 9AD1     		bne	.L872
3196:../Sources/drivers/mcg/mcg.c ****         return PBE; // return PBE code
 5023              		.loc 1 3196 0
 5024 010a 0720     		movs	r0, #7
 5025 010c 7047     		bx	lr
 5026              	.L902:
3204:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 5027              		.loc 1 3204 0
 5028 010e 8B79     		ldrb	r3, [r1, #6]	@ zero_extendqisi2
 5029 0110 03F01000 		and	r0, r3, #16
 5030 0114 C2B2     		uxtb	r2, r0
 5031 0116 002A     		cmp	r2, #0
 5032 0118 9BD1     		bne	.L873
3205:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 5033              		.loc 1 3205 0
 5034 011a 8B79     		ldrb	r3, [r1, #6]	@ zero_extendqisi2
 5035 011c 03F02000 		and	r0, r3, #32
 5036 0120 C2B2     		uxtb	r2, r0
 5037 0122 002A     		cmp	r2, #0
 5038 0124 95D1     		bne	.L873
3206:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 5039              		.loc 1 3206 0
 5040 0126 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 5041 0128 01F00203 		and	r3, r1, #2
 5042 012c D8B2     		uxtb	r0, r3
 5043 012e 0028     		cmp	r0, #0
 5044 0130 8FD1     		bne	.L873
3209:../Sources/drivers/mcg/mcg.c ****         return FBE; // return FBE code
 5045              		.loc 1 3209 0
 5046 0132 0520     		movs	r0, #5
 5047 0134 7047     		bx	lr
 5048              	.L903:
3217:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_IREFST_MASK))  // check FLL ref is external ref clk
 5049              		.loc 1 3217 0
 5050 0136 8879     		ldrb	r0, [r1, #6]	@ zero_extendqisi2
 5051 0138 00F01002 		and	r2, r0, #16
 5052 013c D3B2     		uxtb	r3, r2
 5053 013e 002B     		cmp	r3, #0
 5054 0140 90D1     		bne	.L874
3218:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
 5055              		.loc 1 3218 0
 5056 0142 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 5057 0144 01F00200 		and	r0, r1, #2
 5058 0148 C2B2     		uxtb	r2, r0
 5059 014a 002A     		cmp	r2, #0
 5060 014c 8AD0     		beq	.L874
3221:../Sources/drivers/mcg/mcg.c ****         return BLPE;    // return BLPE code
 5061              		.loc 1 3221 0
 5062 014e 0620     		movs	r0, #6
 5063 0150 7047     		bx	lr
 5064              	.L904:
3229:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 5065              		.loc 1 3229 0
 5066 0152 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 5067 0154 02F01001 		and	r1, r2, #16
 5068 0158 CAB2     		uxtb	r2, r1
 5069 015a 002A     		cmp	r2, #0
 5070 015c 8BD0     		beq	.L875
3230:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 5071              		.loc 1 3230 0
 5072 015e 9979     		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 5073 0160 01F02002 		and	r2, r1, #32
 5074 0164 D1B2     		uxtb	r1, r2
 5075 0166 0029     		cmp	r1, #0
 5076 0168 85D1     		bne	.L875
3231:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_C2 & MCG_C2_LP_MASK)
 5077              		.loc 1 3231 0
 5078 016a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 5079 016c 03F00202 		and	r2, r3, #2
 5080 0170 D1B2     		uxtb	r1, r2
 5081 0172 0029     		cmp	r1, #0
 5082 0174 3FF47FAF 		beq	.L875
 5083 0178 8FE7     		b	.L870
 5084              	.L905:
3242:../Sources/drivers/mcg/mcg.c ****         &&  (MCG_S & MCG_S_IREFST_MASK)     // check FLL ref is internal ref clk
 5085              		.loc 1 3242 0
 5086 017a 8179     		ldrb	r1, [r0, #6]	@ zero_extendqisi2
 5087 017c 01F01003 		and	r3, r1, #16
 5088 0180 DAB2     		uxtb	r2, r3
 5089 0182 002A     		cmp	r2, #0
 5090 0184 80D0     		beq	.L876
3243:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_S & MCG_S_PLLST_MASK))   // check PLLS mux has selected FLL
 5091              		.loc 1 3243 0
 5092 0186 8179     		ldrb	r1, [r0, #6]	@ zero_extendqisi2
 5093 0188 01F02003 		and	r3, r1, #32
 5094 018c DAB2     		uxtb	r2, r3
 5095 018e 002A     		cmp	r2, #0
 5096 0190 7FF47AAF 		bne	.L876
3244:../Sources/drivers/mcg/mcg.c ****         &&  (!(MCG_C2 & MCG_C2_LP_MASK))
 5097              		.loc 1 3244 0
 5098 0194 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 5099 0196 00F00201 		and	r1, r0, #2
 5100 019a CBB2     		uxtb	r3, r1
 5101 019c 002B     		cmp	r3, #0
 5102 019e 7FF473AF 		bne	.L876
3247:../Sources/drivers/mcg/mcg.c ****         return FBI; // return FBI code
 5103              		.loc 1 3247 0
 5104 01a2 0220     		movs	r0, #2
 5105 01a4 7047     		bx	lr
 5106              		.cfi_endproc
 5107              	.LFE26:
 5109              		.global	__aeabi_i2f
 5110              		.global	__aeabi_fdiv
 5111              		.global	__aeabi_fmul
 5112              		.global	__aeabi_f2uiz
 5113 01a6 00BF     		.section	.text.atc,"ax",%progbits
 5114              		.align	2
 5115              		.global	atc
 5116              		.thumb
 5117              		.thumb_func
 5119              	atc:
 5120              	.LFB24:
2859:../Sources/drivers/mcg/mcg.c **** {
 5121              		.loc 1 2859 0
 5122              		.cfi_startproc
 5123              		@ args = 0, pretend = 0, frame = 0
 5124              		@ frame_needed = 0, uses_anonymous_args = 0
 5125              	.LVL495:
 5126 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 5127              	.LCFI20:
 5128              		.cfi_def_cfa_offset 24
 5129              		.cfi_offset 3, -24
 5130              		.cfi_offset 4, -20
 5131              		.cfi_offset 5, -16
 5132              		.cfi_offset 6, -12
 5133              		.cfi_offset 7, -8
 5134              		.cfi_offset 14, -4
2859:../Sources/drivers/mcg/mcg.c **** {
 5135              		.loc 1 2859 0
 5136 0002 0D46     		mov	r5, r1
 5137 0004 1446     		mov	r4, r2
 5138 0006 0646     		mov	r6, r0
 5139              	.LVL496:
2896:../Sources/drivers/mcg/mcg.c ****     mcg_mode = what_mcg_mode();                                     // get present MCG mode
 5140              		.loc 1 2896 0
 5141 0008 FFF7FEFF 		bl	what_mcg_mode
 5142              	.LVL497:
2897:../Sources/drivers/mcg/mcg.c ****     if((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 5143              		.loc 1 2897 0
 5144 000c C21F     		subs	r2, r0, #7
 5145 000e D1B2     		uxtb	r1, r2
 5146 0010 0129     		cmp	r1, #1
 5147 0012 03D9     		bls	.L908
2897:../Sources/drivers/mcg/mcg.c ****     if((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 5148              		.loc 1 2897 0 is_stmt 0
 5149 0014 0528     		cmp	r0, #5
 5150 0016 01D0     		beq	.L908
2899:../Sources/drivers/mcg/mcg.c ****         return 1;                                                   // return error code if not in 
 5151              		.loc 1 2899 0 is_stmt 1
 5152 0018 0120     		movs	r0, #1
 5153              	.LVL498:
3000:../Sources/drivers/mcg/mcg.c **** }   // atc
 5154              		.loc 1 3000 0
 5155 001a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5156              	.LVL499:
 5157              	.L908:
2902:../Sources/drivers/mcg/mcg.c ****     orig_div = SIM_CLKDIV1;                                         //store present clock divider v
 5158              		.loc 1 2902 0
 5159 001c 48F24003 		movw	r3, #32832
2903:../Sources/drivers/mcg/mcg.c ****     bus_clk_div_val = mcg_out_freq / 16000000;                      // calculate bus clock divider 
 5160              		.loc 1 2903 0
 5161 0020 4DF68360 		movw	r0, #56963
 5162              	.LVL500:
2902:../Sources/drivers/mcg/mcg.c ****     orig_div = SIM_CLKDIV1;                                         //store present clock divider v
 5163              		.loc 1 2902 0
 5164 0024 C4F20403 		movt	r3, 16388
2903:../Sources/drivers/mcg/mcg.c ****     bus_clk_div_val = mcg_out_freq / 16000000;                      // calculate bus clock divider 
 5165              		.loc 1 2903 0
 5166 0028 C4F21B30 		movt	r0, 17179
 5167 002c 80FB0412 		smull	r1, r2, r0, r4
 5168              	.LVL501:
 5169 0030 E017     		asrs	r0, r4, #31
2902:../Sources/drivers/mcg/mcg.c ****     orig_div = SIM_CLKDIV1;                                         //store present clock divider v
 5170              		.loc 1 2902 0
 5171 0032 5F68     		ldr	r7, [r3, #4]
 5172              	.LVL502:
2904:../Sources/drivers/mcg/mcg.c ****     temp_reg = SIM_CLKDIV1;
 5173              		.loc 1 2904 0
 5174 0034 5968     		ldr	r1, [r3, #4]
 5175              	.LVL503:
2903:../Sources/drivers/mcg/mcg.c ****     bus_clk_div_val = mcg_out_freq / 16000000;                      // calculate bus clock divider 
 5176              		.loc 1 2903 0
 5177 0036 C0EBA252 		rsb	r2, r0, r2, asr #22
2909:../Sources/drivers/mcg/mcg.c ****     temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
 5178              		.loc 1 2909 0
 5179 003a 1004     		lsls	r0, r2, #16
 5180 003c 00F47022 		and	r2, r0, #983040
2905:../Sources/drivers/mcg/mcg.c ****     temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK;                          // clear dividers except core
 5181              		.loc 1 2905 0
 5182 0040 21F47021 		bic	r1, r1, #983040
 5183              	.LVL504:
2909:../Sources/drivers/mcg/mcg.c ****     temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
 5184              		.loc 1 2909 0
 5185 0044 0A43     		orrs	r2, r2, r1
 5186              	.LVL505:
2910:../Sources/drivers/mcg/mcg.c ****     SIM_CLKDIV1 = temp_reg;                                         // set actual dividers
 5187              		.loc 1 2910 0
 5188 0046 5A60     		str	r2, [r3, #4]
2911:../Sources/drivers/mcg/mcg.c ****     bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16) + 1);    //For KL25, flash and bus use t
 5189              		.loc 1 2911 0
 5190 0048 5868     		ldr	r0, [r3, #4]
 5191 004a 020C     		lsrs	r2, r0, #16
 5192              	.LVL506:
 5193 004c 511C     		adds	r1, r2, #1
 5194 004e B4FBF1F0 		udiv	r0, r4, r1
 5195              	.LVL507:
2912:../Sources/drivers/mcg/mcg.c ****     if((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
 5196              		.loc 1 2912 0
 5197 0052 A0F5F401 		sub	r1, r0, #7995392
 5198 0056 4FF49052 		mov	r2, #4608
 5199 005a A1F59051 		sub	r1, r1, #4608
 5200 005e C0F27A02 		movt	r2, 122
 5201 0062 9142     		cmp	r1, r2
 5202 0064 02D9     		bls	.L910
2914:../Sources/drivers/mcg/mcg.c ****         SIM_CLKDIV1 = orig_div;     // set SIM_CLKDIV1 back to original value
 5203              		.loc 1 2914 0
 5204 0066 5F60     		str	r7, [r3, #4]
2915:../Sources/drivers/mcg/mcg.c ****         return 3;                   // error, bus clock frequency is not within 8MHz to 16MHz
 5205              		.loc 1 2915 0
 5206 0068 0320     		movs	r0, #3
 5207              	.LVL508:
 5208 006a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5209              	.LVL509:
 5210              	.L910:
2891:../Sources/drivers/mcg/mcg.c ****     if(irc_select > 0)  // force irc to 1 if greater than 0
 5211              		.loc 1 2891 0
 5212 006c 0036     		adds	r6, r6, #0
 5213 006e 18BF     		it	ne
 5214 0070 0126     		movne	r6, #1
 5215              	.LVL510:
2918:../Sources/drivers/mcg/mcg.c ****     if(!irc_select)                 //determine if slow or fast IRC to be trimmed
 5216              		.loc 1 2918 0
 5217 0072 36B9     		cbnz	r6, .L911
2920:../Sources/drivers/mcg/mcg.c ****         if(irc_freq < 31250)        // check frequency is above min spec.
 5218              		.loc 1 2920 0
 5219 0074 47F61122 		movw	r2, #31249
 5220 0078 9542     		cmp	r5, r2
 5221 007a 0BDC     		bgt	.L912
2922:../Sources/drivers/mcg/mcg.c ****             SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5222              		.loc 1 2922 0
 5223 007c 5F60     		str	r7, [r3, #4]
2923:../Sources/drivers/mcg/mcg.c ****             return 4;
 5224              		.loc 1 2923 0
 5225 007e 0420     		movs	r0, #4
 5226              	.LVL511:
 5227 0080 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5228              	.LVL512:
 5229              	.L911:
2934:../Sources/drivers/mcg/mcg.c ****         if(irc_freq < 3000000)      // check frequency is above min spec.
 5230              		.loc 1 2934 0
 5231 0082 4CF2BF62 		movw	r2, #50879
 5232 0086 C0F22D02 		movt	r2, 45
 5233 008a 9542     		cmp	r5, r2
 5234 008c 09DC     		bgt	.L914
2936:../Sources/drivers/mcg/mcg.c ****             SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5235              		.loc 1 2936 0
 5236 008e 5F60     		str	r7, [r3, #4]
2937:../Sources/drivers/mcg/mcg.c ****             return 6;
 5237              		.loc 1 2937 0
 5238 0090 0620     		movs	r0, #6
 5239              	.LVL513:
 5240 0092 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5241              	.LVL514:
 5242              	.L912:
2926:../Sources/drivers/mcg/mcg.c ****         if(irc_freq > 39062)        // check frequency is below max spec.
 5243              		.loc 1 2926 0
 5244 0094 49F69601 		movw	r1, #39062
 5245 0098 8D42     		cmp	r5, r1
 5246 009a 0BDD     		ble	.L913
2928:../Sources/drivers/mcg/mcg.c ****             SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5247              		.loc 1 2928 0
 5248 009c 5F60     		str	r7, [r3, #4]
2929:../Sources/drivers/mcg/mcg.c ****             return 5;
 5249              		.loc 1 2929 0
 5250 009e 0520     		movs	r0, #5
 5251              	.LVL515:
 5252 00a0 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5253              	.LVL516:
 5254              	.L914:
2940:../Sources/drivers/mcg/mcg.c ****         if(irc_freq > 5000000)      // check frequency is below max spec.
 5255              		.loc 1 2940 0
 5256 00a2 44F64031 		movw	r1, #19264
 5257 00a6 C0F24C01 		movt	r1, 76
 5258 00aa 8D42     		cmp	r5, r1
 5259 00ac 39DD     		ble	.L915
2942:../Sources/drivers/mcg/mcg.c ****             SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5260              		.loc 1 2942 0
 5261 00ae 5F60     		str	r7, [r3, #4]
2943:../Sources/drivers/mcg/mcg.c ****             return 7;
 5262              		.loc 1 2943 0
 5263 00b0 0720     		movs	r0, #7
 5264              	.LVL517:
 5265 00b2 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5266              	.LVL518:
 5267              	.L913:
2952:../Sources/drivers/mcg/mcg.c ****         atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
 5268              		.loc 1 2952 0
 5269 00b4 FFF7FEFF 		bl	__aeabi_i2f
 5270              	.LVL519:
 5271 00b8 0446     		mov	r4, r0
 5272              	.LVL520:
 5273 00ba 2846     		mov	r0, r5
 5274 00bc FFF7FEFF 		bl	__aeabi_i2f
 5275              	.LVL521:
 5276 00c0 0146     		mov	r1, r0
 5277 00c2 2046     		mov	r0, r4
 5278 00c4 FFF7FEFF 		bl	__aeabi_fdiv
 5279              	.LVL522:
 5280 00c8 0021     		movs	r1, #0
 5281 00ca C4F2A811 		movt	r1, 16808
 5282 00ce FFF7FEFF 		bl	__aeabi_fmul
 5283              	.LVL523:
 5284 00d2 FFF7FEFF 		bl	__aeabi_f2uiz
 5285              	.LVL524:
 5286 00d6 80B2     		uxth	r0, r0
 5287              	.LVL525:
 5288              	.L916:
2954:../Sources/drivers/mcg/mcg.c ****     MCG_ATCVL = (atcv & 0xFF);          //Set ATCVL to lower 8 bits of count value
 5289              		.loc 1 2954 0
 5290 00d8 4FF48041 		mov	r1, #16384
 5291 00dc C4F20601 		movt	r1, 16390
 5292 00e0 C3B2     		uxtb	r3, r0
2955:../Sources/drivers/mcg/mcg.c ****     MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
 5293              		.loc 1 2955 0
 5294 00e2 020A     		lsrs	r2, r0, #8
2954:../Sources/drivers/mcg/mcg.c ****     MCG_ATCVL = (atcv & 0xFF);          //Set ATCVL to lower 8 bits of count value
 5295              		.loc 1 2954 0
 5296 00e4 CB72     		strb	r3, [r1, #11]
2955:../Sources/drivers/mcg/mcg.c ****     MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
 5297              		.loc 1 2955 0
 5298 00e6 8A72     		strb	r2, [r1, #10]
2959:../Sources/drivers/mcg/mcg.c ****     MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK | MCG_SC_ATMF_MASK);    // clear auto trim sett
 5299              		.loc 1 2959 0
 5300 00e8 087A     		ldrb	r0, [r1, #8]	@ zero_extendqisi2
 5301              	.LVL526:
 5302 00ea 00F01F03 		and	r3, r0, #31
 5303 00ee 0B72     		strb	r3, [r1, #8]
2961:../Sources/drivers/mcg/mcg.c ****     MCG_SC |= temp_reg;
 5304              		.loc 1 2961 0
 5305 00f0 0A7A     		ldrb	r2, [r1, #8]	@ zero_extendqisi2
2960:../Sources/drivers/mcg/mcg.c ****     temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT));      //Select IRC to trim an
 5306              		.loc 1 2960 0
 5307 00f2 42EA8610 		orr	r0, r2, r6, lsl #6
2961:../Sources/drivers/mcg/mcg.c ****     MCG_SC |= temp_reg;
 5308              		.loc 1 2961 0
 5309 00f6 40F08003 		orr	r3, r0, #128
 5310 00fa 0B72     		strb	r3, [r1, #8]
 5311              	.L917:
2963:../Sources/drivers/mcg/mcg.c ****     while(MCG_SC & MCG_SC_ATME_MASK)
 5312              		.loc 1 2963 0
 5313 00fc 0A7A     		ldrb	r2, [r1, #8]	@ zero_extendqisi2
 5314 00fe 4FF48043 		mov	r3, #16384
 5315 0102 1006     		lsls	r0, r2, #24
 5316 0104 C4F20603 		movt	r3, 16390
 5317 0108 F8D4     		bmi	.L917
2969:../Sources/drivers/mcg/mcg.c ****     if(MCG_SC & MCG_SC_ATMF_MASK)       // check if error flag set
 5318              		.loc 1 2969 0
 5319 010a 197A     		ldrb	r1, [r3, #8]	@ zero_extendqisi2
 5320 010c 01F02000 		and	r0, r1, #32
 5321 0110 C2B2     		uxtb	r2, r0
 5322 0112 EAB1     		cbz	r2, .L918
2971:../Sources/drivers/mcg/mcg.c ****         SIM_CLKDIV1 = orig_div;         // set SIM_CLKDIV1 back to original value
 5323              		.loc 1 2971 0
 5324 0114 48F24001 		movw	r1, #32832
 5325 0118 C4F20401 		movt	r1, 16388
2972:../Sources/drivers/mcg/mcg.c ****         return 8;
 5326              		.loc 1 2972 0
 5327 011c 0820     		movs	r0, #8
2971:../Sources/drivers/mcg/mcg.c ****         SIM_CLKDIV1 = orig_div;         // set SIM_CLKDIV1 back to original value
 5328              		.loc 1 2971 0
 5329 011e 4F60     		str	r7, [r1, #4]
2972:../Sources/drivers/mcg/mcg.c ****         return 8;
 5330              		.loc 1 2972 0
 5331 0120 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5332              	.LVL527:
 5333              	.L915:
2950:../Sources/drivers/mcg/mcg.c ****         atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
 5334              		.loc 1 2950 0
 5335 0122 FFF7FEFF 		bl	__aeabi_i2f
 5336              	.LVL528:
 5337 0126 0446     		mov	r4, r0
 5338              	.LVL529:
 5339 0128 2846     		mov	r0, r5
 5340 012a FFF7FEFF 		bl	__aeabi_i2f
 5341              	.LVL530:
 5342 012e 0146     		mov	r1, r0
 5343 0130 2046     		mov	r0, r4
 5344 0132 FFF7FEFF 		bl	__aeabi_fdiv
 5345              	.LVL531:
 5346 0136 0021     		movs	r1, #0
 5347 0138 C4F2A811 		movt	r1, 16808
 5348 013c FFF7FEFF 		bl	__aeabi_fmul
 5349              	.LVL532:
 5350 0140 4FF08641 		mov	r1, #1124073472
 5351 0144 FFF7FEFF 		bl	__aeabi_fmul
 5352              	.LVL533:
 5353 0148 FFF7FEFF 		bl	__aeabi_f2uiz
 5354              	.LVL534:
 5355 014c 80B2     		uxth	r0, r0
 5356              	.LVL535:
 5357 014e C3E7     		b	.L916
 5358              	.LVL536:
 5359              	.L918:
2976:../Sources/drivers/mcg/mcg.c ****         if(!irc_select)
 5360              		.loc 1 2976 0
 5361 0150 5EB9     		cbnz	r6, .L919
2978:../Sources/drivers/mcg/mcg.c ****             if((MCG_C3 == 0xFF) || (MCG_C3 == 0))
 5362              		.loc 1 2978 0
 5363 0152 9978     		ldrb	r1, [r3, #2]	@ zero_extendqisi2
 5364 0154 FF29     		cmp	r1, #255
 5365 0156 01D0     		beq	.L920
2978:../Sources/drivers/mcg/mcg.c ****             if((MCG_C3 == 0xFF) || (MCG_C3 == 0))
 5366              		.loc 1 2978 0 is_stmt 0
 5367 0158 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 5368 015a B0B9     		cbnz	r0, .L921
 5369              	.L920:
2980:../Sources/drivers/mcg/mcg.c ****                 SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5370              		.loc 1 2980 0 is_stmt 1
 5371 015c 48F24002 		movw	r2, #32832
 5372 0160 C4F20402 		movt	r2, 16388
2981:../Sources/drivers/mcg/mcg.c ****                 return 9;
 5373              		.loc 1 2981 0
 5374 0164 0920     		movs	r0, #9
2980:../Sources/drivers/mcg/mcg.c ****                 SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5375              		.loc 1 2980 0
 5376 0166 5760     		str	r7, [r2, #4]
2981:../Sources/drivers/mcg/mcg.c ****                 return 9;
 5377              		.loc 1 2981 0
 5378 0168 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5379              	.L919:
2988:../Sources/drivers/mcg/mcg.c ****                 (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF)
 5380              		.loc 1 2988 0
 5381 016a D978     		ldrb	r1, [r3, #3]	@ zero_extendqisi2
 5382 016c C1F34300 		ubfx	r0, r1, #1, #4
2987:../Sources/drivers/mcg/mcg.c ****             (
 5383              		.loc 1 2987 0
 5384 0170 0F28     		cmp	r0, #15
 5385 0172 03D0     		beq	.L922
2989:../Sources/drivers/mcg/mcg.c ****             ||  (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0)
 5386              		.loc 1 2989 0
 5387 0174 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 5388 0176 13F01E0F 		tst	r3, #30
 5389 017a 06D1     		bne	.L921
 5390              	.L922:
2992:../Sources/drivers/mcg/mcg.c ****                 SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5391              		.loc 1 2992 0
 5392 017c 48F24002 		movw	r2, #32832
 5393 0180 C4F20402 		movt	r2, 16388
2993:../Sources/drivers/mcg/mcg.c ****                 return 10;
 5394              		.loc 1 2993 0
 5395 0184 0A20     		movs	r0, #10
2992:../Sources/drivers/mcg/mcg.c ****                 SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5396              		.loc 1 2992 0
 5397 0186 5760     		str	r7, [r2, #4]
2993:../Sources/drivers/mcg/mcg.c ****                 return 10;
 5398              		.loc 1 2993 0
 5399 0188 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5400              	.L921:
2998:../Sources/drivers/mcg/mcg.c ****     SIM_CLKDIV1 = orig_div;             // set SIM_CLKDIV1 back to original value
 5401              		.loc 1 2998 0
 5402 018a 48F24003 		movw	r3, #32832
 5403 018e C4F20403 		movt	r3, 16388
2999:../Sources/drivers/mcg/mcg.c ****     return 0;
 5404              		.loc 1 2999 0
 5405 0192 0020     		movs	r0, #0
2998:../Sources/drivers/mcg/mcg.c ****     SIM_CLKDIV1 = orig_div;             // set SIM_CLKDIV1 back to original value
 5406              		.loc 1 2998 0
 5407 0194 5F60     		str	r7, [r3, #4]
2999:../Sources/drivers/mcg/mcg.c ****     return 0;
 5408              		.loc 1 2999 0
 5409 0196 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5410              		.cfi_endproc
 5411              	.LFE24:
 5413              		.section	.text.clk_monitor_0,"ax",%progbits
 5414              		.align	2
 5415              		.global	clk_monitor_0
 5416              		.thumb
 5417              		.thumb_func
 5419              	clk_monitor_0:
 5420              	.LFB27:
3266:../Sources/drivers/mcg/mcg.c **** 
3267:../Sources/drivers/mcg/mcg.c **** /********************************************************************/
3268:../Sources/drivers/mcg/mcg.c **** 
3269:../Sources/drivers/mcg/mcg.c **** /* Functon name : clk_monitor_0
3270:../Sources/drivers/mcg/mcg.c ****  *
3271:../Sources/drivers/mcg/mcg.c ****  * This function simply enables or disables the OSC 0 clock monitor. This is
3272:../Sources/drivers/mcg/mcg.c ****  * achieved by setting or clearing the MCG_C6[CME] bit. It is recommended to
3273:../Sources/drivers/mcg/mcg.c ****  * enable this monitor in external clock modes (FEE, FBE, BLPE, PBE and PEE.
3274:../Sources/drivers/mcg/mcg.c ****  * It MUST be disabled in all other modes or a reset may be generated. It must
3275:../Sources/drivers/mcg/mcg.c ****  * also be disabled if it is desired to enter VLPR from BLPE mode.
3276:../Sources/drivers/mcg/mcg.c ****  *
3277:../Sources/drivers/mcg/mcg.c ****  * Parameters: en_dis - enables (= 1) or disables (= 0) the OSC 0 clock monitor
3278:../Sources/drivers/mcg/mcg.c ****  *
3279:../Sources/drivers/mcg/mcg.c ****  * Return value : none
3280:../Sources/drivers/mcg/mcg.c ****  */
3281:../Sources/drivers/mcg/mcg.c **** 
3282:../Sources/drivers/mcg/mcg.c **** void clk_monitor_0
3283:../Sources/drivers/mcg/mcg.c **** (unsigned char   en_dis)
3284:../Sources/drivers/mcg/mcg.c **** {
 5421              		.loc 1 3284 0
 5422              		.cfi_startproc
 5423              		@ args = 0, pretend = 0, frame = 0
 5424              		@ frame_needed = 0, uses_anonymous_args = 0
 5425              		@ link register save eliminated.
 5426              	.LVL537:
3285:../Sources/drivers/mcg/mcg.c ****     if(en_dis)
3286:../Sources/drivers/mcg/mcg.c ****     {
3287:../Sources/drivers/mcg/mcg.c ****         MCG_C6 |= MCG_C6_CME0_MASK;
 5427              		.loc 1 3287 0
 5428 0000 4FF48043 		mov	r3, #16384
 5429 0004 C4F20603 		movt	r3, 16390
 5430 0008 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
3285:../Sources/drivers/mcg/mcg.c ****     if(en_dis)
 5431              		.loc 1 3285 0
 5432 000a 18B9     		cbnz	r0, .L934
3288:../Sources/drivers/mcg/mcg.c ****     }
3289:../Sources/drivers/mcg/mcg.c ****     else
3290:../Sources/drivers/mcg/mcg.c ****     {
3291:../Sources/drivers/mcg/mcg.c ****         MCG_C6 &= ~MCG_C6_CME0_MASK;
 5433              		.loc 1 3291 0
 5434 000c 02F0DF00 		and	r0, r2, #223
 5435              	.LVL538:
 5436 0010 5871     		strb	r0, [r3, #5]
 5437 0012 7047     		bx	lr
 5438              	.LVL539:
 5439              	.L934:
3287:../Sources/drivers/mcg/mcg.c ****         MCG_C6 |= MCG_C6_CME0_MASK;
 5440              		.loc 1 3287 0
 5441 0014 42F02001 		orr	r1, r2, #32
 5442 0018 5971     		strb	r1, [r3, #5]
 5443 001a 7047     		bx	lr
 5444              		.cfi_endproc
 5445              	.LFE27:
 5447              		.comm	dmx32_val,1,1
 5448              		.comm	drs_val,1,1
 5449              		.text
 5450              	.Letext0:
 5451              		.file 2 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 5452              		.file 3 "C:/Users/ehughes/Dropbox/FRDM/FRDM-JAM/SRC/MonkeyJam/MonkeyJam/Project_Headers/MK20D5.h"
DEFINED SYMBOLS
                            *ABS*:00000000 mcg.c
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:19     .text.pll_init:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:24     .text.pll_init:00000000 pll_init
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:519    .text.new_pll_freq:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:524    .text.new_pll_freq:00000000 new_pll_freq
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:799    .text.pee_pbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:804    .text.pee_pbe:00000000 pee_pbe
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:882    .text.pbe_pee:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:887    .text.pbe_pee:00000000 pbe_pee
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1032   .text.pbe_fbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1037   .text.pbe_fbe:00000000 pbe_fbe
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1123   .text.fbe_pbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1128   .text.fbe_pbe:00000000 fbe_pbe
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1323   .text.pbe_blpe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1328   .text.pbe_blpe:00000000 pbe_blpe
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1381   .text.blpe_pbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1386   .text.blpe_pbe:00000000 blpe_pbe
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1569   .text.blpe_fbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1574   .text.blpe_fbe:00000000 blpe_fbe
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1658   .text.fbe_blpe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1663   .text.fbe_blpe:00000000 fbe_blpe
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1716   .text.fei_fbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:1721   .text.fei_fbe:00000000 fei_fbe
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2059   .text.fee_fbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2064   .text.fee_fbe:00000000 fee_fbe
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2141   .text.fbe_fbi:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2146   .text.fbe_fbi:00000000 fbe_fbi
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2415   .text.fbi_fbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2420   .text.fbi_fbe:00000000 fbi_fbe
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2761   .text.fbi_blpi:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2766   .text.fbi_blpi:00000000 fbi_blpi
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2837   .text.blpi_fbi:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2842   .text.blpi_fbi:00000000 blpi_fbi
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2913   .text.fee_fbi:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:2918   .text.fee_fbi:00000000 fee_fbi
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:3166   .text.fei_fbi:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:3171   .text.fei_fbi:00000000 fei_fbi
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:3387   .text.fll_freq:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:3392   .text.fll_freq:00000000 fll_freq
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:3594   .text.fee_fei:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:3599   .text.fee_fei:00000000 fee_fei
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:3705   .text.fei_fee:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:3710   .text.fei_fee:00000000 fei_fee
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:4055   .text.fbi_fei:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:4060   .text.fbi_fei:00000000 fbi_fei
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:4206   .text.fbi_fee:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:4211   .text.fbi_fee:00000000 fbi_fee
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:4588   .text.fbe_fee:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:4593   .text.fbe_fee:00000000 fbe_fee
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:4714   .text.fbe_fei:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:4719   .text.fbe_fei:00000000 fbe_fei
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:4869   .text.what_mcg_mode:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:4874   .text.what_mcg_mode:00000000 what_mcg_mode
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:5114   .text.atc:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:5119   .text.atc:00000000 atc
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:5414   .text.clk_monitor_0:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cc0AOL3P.s:5419   .text.clk_monitor_0:00000000 clk_monitor_0
                            *COM*:00000001 dmx32_val
                            *COM*:00000001 drs_val
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_i2f
__aeabi_fdiv
__aeabi_fmul
__aeabi_f2uiz
